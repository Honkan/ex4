
AVR32 FreeRTOS Template.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001a  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00003b04  80002020  80002020  00002420  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80005c00  80005c00  00006000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80005e00  80005e00  00006200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00000160  80005e18  80005e18  00006218  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  80005f78  00006408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  80005f80  00006410  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  80005f88  00006418  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          00000000  0000001c  80005f8c  0000641c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         000005d8  0000001c  80005f8c  0000641c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          00000430  00000610  00000610  00000000  2**2
                  ALLOC
 14 .heap         0000e5c0  00000a40  00000a40  00000000  2**0
                  ALLOC
 15 .comment      00000030  00000000  00000000  000069f4  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 00000ce0  00000000  00000000  00006a24  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 000019b8  00000000  00000000  00007704  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   00025b88  00000000  00000000  000090bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 000047af  00000000  00000000  0002ec44  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   0000f065  00000000  00000000  000333f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00001e04  00000000  00000000  00042458  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    00007e0c  00000000  00000000  0004425c  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    000044ec  00000000  00000000  0004c068  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 014adad4  00000000  00000000  00050554  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00000d68  00000000  00000000  014fe028  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	fe cf ff e0 	sub	pc,pc,-32

Disassembly of section .init:

80002004 <_init>:
80002004:	eb cd 40 40 	pushm	r6,lr
80002008:	48 26       	lddpc	r6,80002010 <_init+0xc>
8000200a:	1e 26       	rsub	r6,pc
8000200c:	c0 48       	rjmp	80002014 <_init+0x10>
8000200e:	d7 03       	nop
80002010:	80 00       	ld.sh	r0,r0[0x0]
80002012:	1f ee       	ld.ub	lr,pc[0x6]
80002014:	c5 ec       	rcall	800020d0 <frame_dummy>
80002016:	e0 a0 1d 7b 	rcall	80005b0c <__do_global_ctors_aux>
8000201a:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002020 <_stext>:
80002020:	30 07       	mov	r7,0
80002022:	49 5a       	lddpc	r10,80002074 <_stext+0x54>
80002024:	5b fa       	cp.w	r10,-1
80002026:	f4 0d 17 10 	movne	sp,r10
8000202a:	49 4b       	lddpc	r11,80002078 <_stext+0x58>
8000202c:	49 4c       	lddpc	r12,8000207c <_stext+0x5c>
8000202e:	18 3b       	cp.w	r11,r12
80002030:	c0 60       	breq	8000203c <_stext+0x1c>
80002032:	49 4a       	lddpc	r10,80002080 <_stext+0x60>
80002034:	b7 09       	ld.d	r8,r11++
80002036:	b9 28       	st.d	r12++,r8
80002038:	14 3c       	cp.w	r12,r10
8000203a:	cf d5       	brlt	80002034 <_stext+0x14>
8000203c:	49 2a       	lddpc	r10,80002084 <_stext+0x64>
8000203e:	49 1c       	lddpc	r12,80002080 <_stext+0x60>
80002040:	30 08       	mov	r8,0
80002042:	30 09       	mov	r9,0
80002044:	b9 28       	st.d	r12++,r8
80002046:	14 3c       	cp.w	r12,r10
80002048:	cf e5       	brlt	80002044 <_stext+0x24>
8000204a:	e0 a0 11 93 	rcall	80004370 <_init_startup>
8000204e:	fe cc c2 4e 	sub	r12,pc,-15794
80002052:	e0 a0 16 13 	rcall	80004c78 <atexit>
80002056:	cd 7f       	rcall	80002004 <_init>
80002058:	1a 9c       	mov	r12,sp
8000205a:	30 0b       	mov	r11,0
8000205c:	e0 a0 19 0a 	rcall	80005270 <_init_argv>
80002060:	5b fc       	cp.w	r12,-1
80002062:	f9 bc 00 00 	moveq	r12,0
80002066:	f9 ba 00 00 	moveq	r10,0
8000206a:	14 1d       	sub	sp,r10
8000206c:	e0 a0 15 ba 	rcall	80004be0 <main>
80002070:	e0 a0 16 0c 	rcall	80004c88 <exit>
80002074:	00 01       	add	r1,r0
80002076:	00 00       	add	r0,r0
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	5f 78       	srpl	r8
8000207c:	00 00       	add	r0,r0
8000207e:	00 08       	add	r8,r0
80002080:	00 00       	add	r0,r0
80002082:	05 f8       	ld.ub	r8,r2[0x7]
80002084:	00 00       	add	r0,r0
80002086:	0a 40       	or	r0,r5

80002088 <__do_global_dtors_aux>:
80002088:	d4 21       	pushm	r4-r7,lr
8000208a:	48 e8       	lddpc	r8,800020c0 <__do_global_dtors_aux+0x38>
8000208c:	11 89       	ld.ub	r9,r8[0x0]
8000208e:	30 08       	mov	r8,0
80002090:	f0 09 18 00 	cp.b	r9,r8
80002094:	c1 41       	brne	800020bc <__do_global_dtors_aux+0x34>
80002096:	48 c8       	lddpc	r8,800020c4 <__do_global_dtors_aux+0x3c>
80002098:	48 c6       	lddpc	r6,800020c8 <__do_global_dtors_aux+0x40>
8000209a:	10 95       	mov	r5,r8
8000209c:	10 16       	sub	r6,r8
8000209e:	48 c7       	lddpc	r7,800020cc <__do_global_dtors_aux+0x44>
800020a0:	a3 46       	asr	r6,0x2
800020a2:	20 16       	sub	r6,1
800020a4:	c0 68       	rjmp	800020b0 <__do_global_dtors_aux+0x28>
800020a6:	2f f8       	sub	r8,-1
800020a8:	8f 08       	st.w	r7[0x0],r8
800020aa:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020ae:	5d 18       	icall	r8
800020b0:	6e 08       	ld.w	r8,r7[0x0]
800020b2:	0c 38       	cp.w	r8,r6
800020b4:	cf 93       	brcs	800020a6 <__do_global_dtors_aux+0x1e>
800020b6:	30 19       	mov	r9,1
800020b8:	48 28       	lddpc	r8,800020c0 <__do_global_dtors_aux+0x38>
800020ba:	b0 89       	st.b	r8[0x0],r9
800020bc:	d8 22       	popm	r4-r7,pc
800020be:	d7 03       	nop
800020c0:	00 00       	add	r0,r0
800020c2:	06 10       	sub	r0,r3
800020c4:	00 00       	add	r0,r0
800020c6:	00 10       	sub	r0,r0
800020c8:	00 00       	add	r0,r0
800020ca:	00 14       	sub	r4,r0
800020cc:	00 00       	add	r0,r0
800020ce:	06 14       	sub	r4,r3

800020d0 <frame_dummy>:
800020d0:	d4 01       	pushm	lr
800020d2:	48 5c       	lddpc	r12,800020e4 <frame_dummy+0x14>
800020d4:	78 08       	ld.w	r8,r12[0x0]
800020d6:	58 08       	cp.w	r8,0
800020d8:	c0 50       	breq	800020e2 <frame_dummy+0x12>
800020da:	48 48       	lddpc	r8,800020e8 <frame_dummy+0x18>
800020dc:	58 08       	cp.w	r8,0
800020de:	c0 20       	breq	800020e2 <frame_dummy+0x12>
800020e0:	5d 18       	icall	r8
800020e2:	d8 02       	popm	pc
800020e4:	00 00       	add	r0,r0
800020e6:	00 18       	sub	r8,r0
800020e8:	00 00       	add	r0,r0
	...

800020ec <board_init>:
#endif



void board_init (void)
{
800020ec:	d4 01       	pushm	lr
    gpio_configure_pin (LED0_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800020ee:	30 3b       	mov	r11,3
800020f0:	32 3c       	mov	r12,35
800020f2:	f0 1f 00 1b 	mcall	8000215c <board_init+0x70>
    gpio_configure_pin (LED1_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800020f6:	30 3b       	mov	r11,3
800020f8:	34 9c       	mov	r12,73
800020fa:	f0 1f 00 19 	mcall	8000215c <board_init+0x70>
    gpio_configure_pin (LED2_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800020fe:	30 3b       	mov	r11,3
80002100:	32 2c       	mov	r12,34
80002102:	f0 1f 00 17 	mcall	8000215c <board_init+0x70>
    gpio_configure_pin (LED3_GPIO, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002106:	30 3b       	mov	r11,3
80002108:	32 6c       	mov	r12,38
8000210a:	f0 1f 00 15 	mcall	8000215c <board_init+0x70>
	
	gpio_configure_pin (AVR32_PIN_PA31, GPIO_DIR_INPUT);
8000210e:	30 0b       	mov	r11,0
80002110:	31 fc       	mov	r12,31
80002112:	f0 1f 00 13 	mcall	8000215c <board_init+0x70>
	gpio_enable_pin_pull_up(AVR32_PIN_PA31);
80002116:	31 fc       	mov	r12,31
80002118:	f0 1f 00 12 	mcall	80002160 <board_init+0x74>
	//gpio_enable_pin_interrupt(AVR32_PIN_PA31, GPIO_FALLING_EDGE);
	gpio_configure_pin (AVR32_PIN_PA29, GPIO_DIR_INPUT);
8000211c:	30 0b       	mov	r11,0
8000211e:	31 dc       	mov	r12,29
80002120:	f0 1f 00 0f 	mcall	8000215c <board_init+0x70>
	gpio_enable_pin_pull_up(AVR32_PIN_PA29);
80002124:	31 dc       	mov	r12,29
80002126:	f0 1f 00 0f 	mcall	80002160 <board_init+0x74>
	//gpio_enable_pin_interrupt(AVR32_PIN_PA29, GPIO_FALLING_EDGE);
	gpio_configure_pin (AVR32_PIN_PA27, GPIO_DIR_INPUT);
8000212a:	30 0b       	mov	r11,0
8000212c:	31 bc       	mov	r12,27
8000212e:	f0 1f 00 0c 	mcall	8000215c <board_init+0x70>
	gpio_enable_pin_pull_up(AVR32_PIN_PA27);
80002132:	31 bc       	mov	r12,27
80002134:	f0 1f 00 0b 	mcall	80002160 <board_init+0x74>
	//gpio_enable_pin_interrupt(AVR32_PIN_PA27, GPIO_FALLING_EDGE);
	
	gpio_configure_pin (AVR32_PIN_PA30, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002138:	30 3b       	mov	r11,3
8000213a:	31 ec       	mov	r12,30
8000213c:	f0 1f 00 08 	mcall	8000215c <board_init+0x70>
	gpio_configure_pin (AVR32_PIN_PA28, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002140:	30 3b       	mov	r11,3
80002142:	31 cc       	mov	r12,28
80002144:	f0 1f 00 06 	mcall	8000215c <board_init+0x70>
	gpio_configure_pin (AVR32_PIN_PB00, GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002148:	30 3b       	mov	r11,3
8000214a:	32 0c       	mov	r12,32
8000214c:	f0 1f 00 04 	mcall	8000215c <board_init+0x70>

    gpio_configure_pin (GPIO_PUSH_BUTTON_0, (GPIO_DIR_INPUT | GPIO_PULL_UP));
80002150:	30 4b       	mov	r11,4
80002152:	32 1c       	mov	r12,33
80002154:	f0 1f 00 02 	mcall	8000215c <board_init+0x70>
     * the platform Xplained board has configured basic clock settings,
     * GPIO pin mapping, interrupt controller options, etc.
     */
    sensor_board_init ();
#endif
}
80002158:	d8 02       	popm	pc
8000215a:	00 00       	add	r0,r0
8000215c:	80 00       	ld.sh	r0,r0[0x0]
8000215e:	21 7a       	sub	r10,23
80002160:	80 00       	ld.sh	r0,r0[0x0]
80002162:	21 64       	sub	r4,22

80002164 <gpio_enable_pin_pull_up>:
#endif


void gpio_enable_pin_pull_up(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002164:	f8 08 16 05 	lsr	r8,r12,0x5
80002168:	a9 68       	lsl	r8,0x8
8000216a:	e0 28 f0 00 	sub	r8,61440
  gpio_port->puers = 1 << (pin & 0x1F);
8000216e:	30 19       	mov	r9,1
80002170:	f2 0c 09 4c 	lsl	r12,r9,r12
80002174:	f1 4c 00 74 	st.w	r8[116],r12
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) || defined(AVR32_GPIO_212_H_INCLUDED)
  gpio_port->pderc = 1 << (pin & 0x1F);
#endif
}
80002178:	5e fc       	retal	r12

8000217a <gpio_configure_pin>:

#endif

void gpio_configure_pin(uint32_t pin, uint32_t flags)
{  
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];  
8000217a:	f8 08 16 05 	lsr	r8,r12,0x5
8000217e:	a9 68       	lsl	r8,0x8
80002180:	e0 28 f0 00 	sub	r8,61440
    if (flags & GPIO_PULL_DOWN)
            gpio_port->pders = 1 << (pin & 0x1F);
    else
            gpio_port->pderc = 1 << (pin & 0x1F);
#endif    
    if (flags & GPIO_PULL_UP)
80002184:	16 99       	mov	r9,r11
80002186:	e2 19 00 04 	andl	r9,0x4,COH
8000218a:	c0 70       	breq	80002198 <gpio_configure_pin+0x1e>
            gpio_port->puers = 1 << (pin & 0x1F);
8000218c:	30 19       	mov	r9,1
8000218e:	f2 0c 09 49 	lsl	r9,r9,r12
80002192:	f1 49 00 74 	st.w	r8[116],r9
80002196:	c0 68       	rjmp	800021a2 <gpio_configure_pin+0x28>
    else
            gpio_port->puerc = 1 << (pin & 0x1F);
80002198:	30 19       	mov	r9,1
8000219a:	f2 0c 09 49 	lsl	r9,r9,r12
8000219e:	f1 49 00 78 	st.w	r8[120],r9
            else
                    gpio_port->odcr1c = 1 << (pin & 0x1F);
#endif

    /* Select interrupt level for group */
    if (flags & GPIO_INTERRUPT) {
800021a2:	16 99       	mov	r9,r11
800021a4:	e2 19 00 80 	andl	r9,0x80,COH
800021a8:	c2 40       	breq	800021f0 <gpio_configure_pin+0x76>
            if (flags & GPIO_BOTHEDGES)
800021aa:	16 99       	mov	r9,r11
800021ac:	e2 19 01 80 	andl	r9,0x180,COH
800021b0:	c0 90       	breq	800021c2 <gpio_configure_pin+0x48>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
800021b2:	30 19       	mov	r9,1
800021b4:	f2 0c 09 49 	lsl	r9,r9,r12
800021b8:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
800021bc:	f1 49 00 b8 	st.w	r8[184],r9
800021c0:	c1 88       	rjmp	800021f0 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_RISING)
800021c2:	16 99       	mov	r9,r11
800021c4:	e2 19 02 80 	andl	r9,0x280,COH
800021c8:	c0 90       	breq	800021da <gpio_configure_pin+0x60>
            {
                   gpio_port->imr0s = 1 << (pin & 0x1F);
800021ca:	30 19       	mov	r9,1
800021cc:	f2 0c 09 49 	lsl	r9,r9,r12
800021d0:	f1 49 00 a4 	st.w	r8[164],r9
                   gpio_port->imr1c = 1 << (pin & 0x1F);
800021d4:	f1 49 00 b8 	st.w	r8[184],r9
800021d8:	c0 c8       	rjmp	800021f0 <gpio_configure_pin+0x76>
            }
            else if (flags & GPIO_FALLING)
800021da:	16 99       	mov	r9,r11
800021dc:	e2 19 03 80 	andl	r9,0x380,COH
800021e0:	c0 80       	breq	800021f0 <gpio_configure_pin+0x76>
            {
                   gpio_port->imr0c = 1 << (pin & 0x1F);
800021e2:	30 19       	mov	r9,1
800021e4:	f2 0c 09 49 	lsl	r9,r9,r12
800021e8:	f1 49 00 a8 	st.w	r8[168],r9
                   gpio_port->imr1s = 1 << (pin & 0x1F);
800021ec:	f1 49 00 b4 	st.w	r8[180],r9
            }
    }

    /* Select direction and initial pin state */
    if (flags & GPIO_DIR_OUTPUT) {
800021f0:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
800021f4:	c1 50       	breq	8000221e <gpio_configure_pin+0xa4>
            if (flags & GPIO_INIT_HIGH)
800021f6:	e2 1b 00 02 	andl	r11,0x2,COH
800021fa:	c0 70       	breq	80002208 <gpio_configure_pin+0x8e>
                    gpio_port->ovrs = 1 << (pin & 0x1F);
800021fc:	30 19       	mov	r9,1
800021fe:	f2 0c 09 49 	lsl	r9,r9,r12
80002202:	f1 49 00 54 	st.w	r8[84],r9
80002206:	c0 68       	rjmp	80002212 <gpio_configure_pin+0x98>
            else
                    gpio_port->ovrc = 1 << (pin & 0x1F);
80002208:	30 19       	mov	r9,1
8000220a:	f2 0c 09 49 	lsl	r9,r9,r12
8000220e:	f1 49 00 58 	st.w	r8[88],r9
            gpio_port->oders = 1 << (pin & 0x1F);
80002212:	30 19       	mov	r9,1
80002214:	f2 0c 09 49 	lsl	r9,r9,r12
80002218:	f1 49 00 44 	st.w	r8[68],r9
8000221c:	c0 68       	rjmp	80002228 <gpio_configure_pin+0xae>
    } else {
            gpio_port->oderc = 1 << (pin & 0x1F);
8000221e:	30 19       	mov	r9,1
80002220:	f2 0c 09 49 	lsl	r9,r9,r12
80002224:	f1 49 00 48 	st.w	r8[72],r9
    }

    /* Enable GPIO */
    gpio_port->gpers = 1 << (pin & 0x1F);
80002228:	30 19       	mov	r9,1
8000222a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000222e:	91 1c       	st.w	r8[0x4],r12
}
80002230:	5e fc       	retal	r12

80002232 <gpio_get_pin_value>:
    gpio_port->gpers = mask;
}

int gpio_get_pin_value(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002232:	f8 08 16 05 	lsr	r8,r12,0x5
80002236:	a9 68       	lsl	r8,0x8
80002238:	e0 28 f0 00 	sub	r8,61440
  return (gpio_port->pvr >> (pin & 0x1F)) & 1;
8000223c:	71 88       	ld.w	r8,r8[0x60]
8000223e:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80002242:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002246:	5e fc       	retal	r12

80002248 <gpio_set_pin_high>:
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
}

void gpio_set_pin_high(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002248:	f8 08 16 05 	lsr	r8,r12,0x5
8000224c:	a9 68       	lsl	r8,0x8
8000224e:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrs  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 1.
80002252:	30 19       	mov	r9,1
80002254:	f2 0c 09 4c 	lsl	r12,r9,r12
80002258:	f1 4c 00 54 	st.w	r8[84],r12
}
8000225c:	5e fc       	retal	r12

8000225e <gpio_set_pin_low>:
}


void gpio_set_pin_low(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
8000225e:	f8 08 16 05 	lsr	r8,r12,0x5
80002262:	a9 68       	lsl	r8,0x8
80002264:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrc  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 0.
80002268:	30 19       	mov	r9,1
8000226a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000226e:	f1 4c 00 58 	st.w	r8[88],r12
}
80002272:	5e fc       	retal	r12

80002274 <gpio_toggle_pin>:
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
}

void gpio_toggle_pin(uint32_t pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80002274:	f8 08 16 05 	lsr	r8,r12,0x5
80002278:	a9 68       	lsl	r8,0x8
8000227a:	e0 28 f0 00 	sub	r8,61440
  gpio_port->ovrt  = 1 << (pin & 0x1F); // Toggle the I/O line.
8000227e:	30 19       	mov	r9,1
80002280:	f2 0c 09 4c 	lsl	r12,r9,r12
80002284:	f1 4c 00 5c 	st.w	r8[92],r12
}
80002288:	5e fc       	retal	r12

8000228a <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000228a:	c0 08       	rjmp	8000228a <_unhandled_interrupt>

8000228c <INTC_register_interrupt>:


void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_level)
{
  // Determine the group of the IRQ.
  unsigned int int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000228c:	f6 08 16 05 	lsr	r8,r11,0x5

  // Store in _int_line_handler_table_x the pointer to the interrupt handler, so
  // that _get_interrupt_handler can retrieve it when the interrupt is vectored.
  _int_handler_table[int_grp]._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP] = handler;
80002290:	48 99       	lddpc	r9,800022b4 <INTC_register_interrupt+0x28>
80002292:	f2 08 00 39 	add	r9,r9,r8<<0x3
80002296:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000229a:	72 19       	ld.w	r9,r9[0x4]
8000229c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
  // Program the corresponding IPRX register to set the interrupt priority level
  // and the interrupt vector offset that will be fetched by the core interrupt
  // system.
  // NOTE: The _intx functions are intermediate assembly functions between the
  // core interrupt system and the user interrupt handler.
  AVR32_INTC.ipr[int_grp] = ipr_val[int_level & (AVR32_INTC_IPR_INTLEVEL_MASK >> AVR32_INTC_IPR_INTLEVEL_OFFSET)];
800022a0:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
800022a4:	48 59       	lddpc	r9,800022b8 <INTC_register_interrupt+0x2c>
800022a6:	f2 0a 03 2a 	ld.w	r10,r9[r10<<0x2]
800022aa:	fe 79 08 00 	mov	r9,-63488
800022ae:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
}
800022b2:	5e fc       	retal	r12
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	5e 18       	retne	r8
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	5d 3c       	musfr	r12

800022bc <INTC_init_interrupts>:
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
}

void INTC_init_interrupts(void)
{
800022bc:	d4 21       	pushm	r4-r7,lr
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
800022be:	49 18       	lddpc	r8,80002300 <INTC_init_interrupts+0x44>
800022c0:	e3 b8 00 01 	mtsr	0x4,r8
800022c4:	49 0e       	lddpc	lr,80002304 <INTC_init_interrupts+0x48>
800022c6:	30 07       	mov	r7,0
800022c8:	0e 94       	mov	r4,r7
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
800022ca:	49 0c       	lddpc	r12,80002308 <INTC_init_interrupts+0x4c>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
800022cc:	49 08       	lddpc	r8,8000230c <INTC_init_interrupts+0x50>
800022ce:	70 05       	ld.w	r5,r8[0x0]
800022d0:	fe 76 08 00 	mov	r6,-63488
800022d4:	c1 08       	rjmp	800022f4 <INTC_init_interrupts+0x38>
}

//! Init EVBA address. This sequence might also be done in the utils/startup/startup_uc3.S file.
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int)&_evba );
800022d6:	08 98       	mov	r8,r4
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
800022d8:	7c 1b       	ld.w	r11,lr[0x4]

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
800022da:	7c 0a       	ld.w	r10,lr[0x0]
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
800022dc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
800022e0:	2f f8       	sub	r8,-1
800022e2:	10 3a       	cp.w	r10,r8
800022e4:	fe 9b ff fc 	brhi	800022dc <INTC_init_interrupts+0x20>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
800022e8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
  unsigned int int_grp, int_req;

  INTC_init_evba();

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800022ec:	2f f7       	sub	r7,-1
800022ee:	2f 8e       	sub	lr,-8
800022f0:	59 e7       	cp.w	r7,30
800022f2:	c0 50       	breq	800022fc <INTC_init_interrupts+0x40>
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
800022f4:	7c 08       	ld.w	r8,lr[0x0]
800022f6:	58 08       	cp.w	r8,0
800022f8:	ce f1       	brne	800022d6 <INTC_init_interrupts+0x1a>
800022fa:	cf 7b       	rjmp	800022e8 <INTC_init_interrupts+0x2c>
800022fc:	d8 22       	popm	r4-r7,pc
800022fe:	00 00       	add	r0,r0
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	5c 00       	acr	r0
80002304:	80 00       	ld.sh	r0,r0[0x0]
80002306:	5e 18       	retne	r8
80002308:	80 00       	ld.sh	r0,r0[0x0]
8000230a:	22 8a       	sub	r10,40
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	5d 3c       	musfr	r12

80002310 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(unsigned int int_level)
{
  // ICR3 is mapped first, ICR0 last.
  // Code in exception.S puts int_level in R12 which is used by AVR32-GCC to
  // pass a single argument to a function.
  unsigned int int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002310:	fe 78 08 00 	mov	r8,-63488
80002314:	e0 69 00 83 	mov	r9,131
80002318:	f2 0c 01 0c 	sub	r12,r9,r12
8000231c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
  unsigned int int_req = AVR32_INTC.irr[int_grp];
80002320:	f2 ca ff c0 	sub	r10,r9,-64
80002324:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
  // exception.S will provide the interrupt handler with a clean interrupt stack
  // frame, with nothing more pushed onto the stack. The interrupt handler must
  // manage the `rete' instruction, what can be done thanks to pure assembly,
  // inline assembly or the `__attribute__((__interrupt__))' C function
  // attribute.
  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
80002328:	58 08       	cp.w	r8,0
8000232a:	c0 21       	brne	8000232e <_get_interrupt_handler+0x1e>
8000232c:	5e fd       	retal	0
8000232e:	f0 08 12 00 	clz	r8,r8
80002332:	48 5a       	lddpc	r10,80002344 <_get_interrupt_handler+0x34>
80002334:	f4 09 00 39 	add	r9,r10,r9<<0x3
80002338:	f0 08 11 1f 	rsub	r8,r8,31
8000233c:	72 19       	ld.w	r9,r9[0x4]
8000233e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
}
80002342:	5e fc       	retal	r12
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	5e 18       	retne	r8

80002348 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002348:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000234a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000234e:	99 a8       	st.w	r12[0x28],r8
}
80002350:	5e fc       	retal	r12
80002352:	d7 03       	nop

80002354 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002354:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002356:	ec 5b bb 9f 	cp.w	r11,899999
8000235a:	e0 8b 00 04 	brhi	80002362 <pm_enable_osc0_crystal+0xe>
8000235e:	30 4b       	mov	r11,4
80002360:	c1 38       	rjmp	80002386 <pm_enable_osc0_crystal+0x32>
80002362:	e0 68 c6 bf 	mov	r8,50879
80002366:	ea 18 00 2d 	orh	r8,0x2d
8000236a:	10 3b       	cp.w	r11,r8
8000236c:	e0 8b 00 04 	brhi	80002374 <pm_enable_osc0_crystal+0x20>
80002370:	30 5b       	mov	r11,5
80002372:	c0 a8       	rjmp	80002386 <pm_enable_osc0_crystal+0x32>
80002374:	e0 68 12 00 	mov	r8,4608
80002378:	ea 18 00 7a 	orh	r8,0x7a
8000237c:	10 3b       	cp.w	r11,r8
8000237e:	f9 bb 03 06 	movlo	r11,6
80002382:	f9 bb 02 07 	movhs	r11,7
80002386:	f0 1f 00 02 	mcall	8000238c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000238a:	d8 02       	popm	pc
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	23 48       	sub	r8,52

80002390 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002390:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002392:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002396:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002398:	78 08       	ld.w	r8,r12[0x0]
8000239a:	a3 a8       	sbr	r8,0x2
8000239c:	99 08       	st.w	r12[0x0],r8
}
8000239e:	5e fc       	retal	r12

800023a0 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800023a0:	79 58       	ld.w	r8,r12[0x54]
800023a2:	e2 18 00 80 	andl	r8,0x80,COH
800023a6:	cf d0       	breq	800023a0 <pm_wait_for_clk0_ready>
}
800023a8:	5e fc       	retal	r12
800023aa:	d7 03       	nop

800023ac <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800023ac:	eb cd 40 80 	pushm	r7,lr
800023b0:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800023b2:	f0 1f 00 04 	mcall	800023c0 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800023b6:	0e 9c       	mov	r12,r7
800023b8:	f0 1f 00 03 	mcall	800023c4 <pm_enable_clk0+0x18>
}
800023bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800023c0:	80 00       	ld.sh	r0,r0[0x0]
800023c2:	23 90       	sub	r0,57
800023c4:	80 00       	ld.sh	r0,r0[0x0]
800023c6:	23 a0       	sub	r0,58

800023c8 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800023c8:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800023ca:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800023ce:	99 08       	st.w	r12[0x0],r8
}
800023d0:	5e fc       	retal	r12
800023d2:	d7 03       	nop

800023d4 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800023d4:	eb cd 40 c0 	pushm	r6-r7,lr
800023d8:	18 97       	mov	r7,r12
800023da:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800023dc:	f0 1f 00 06 	mcall	800023f4 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
800023e0:	0c 9b       	mov	r11,r6
800023e2:	0e 9c       	mov	r12,r7
800023e4:	f0 1f 00 05 	mcall	800023f8 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
800023e8:	30 1b       	mov	r11,1
800023ea:	0e 9c       	mov	r12,r7
800023ec:	f0 1f 00 04 	mcall	800023fc <pm_switch_to_osc0+0x28>
}
800023f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800023f4:	80 00       	ld.sh	r0,r0[0x0]
800023f6:	23 54       	sub	r4,53
800023f8:	80 00       	ld.sh	r0,r0[0x0]
800023fa:	23 ac       	sub	r12,58
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	23 c8       	sub	r8,60

80002400 <pcl_switch_to_osc>:
        return PASS;
}
#endif // UC3C device-specific implementation

long int pcl_switch_to_osc(pcl_osc_t osc, unsigned int fcrystal, unsigned int startup)
{
80002400:	d4 01       	pushm	lr
#ifndef AVR32_PM_VERSION_RESETVALUE
// Implementation for UC3A, UC3A3, UC3B parts.
  if(PCL_OSC0 == osc)
80002402:	58 0c       	cp.w	r12,0
80002404:	c0 40       	breq	8000240c <pcl_switch_to_osc+0xc>
80002406:	fe 7c d8 f0 	mov	r12,-10000
8000240a:	d8 02       	popm	pc
  {
    // Configure OSC0 in crystal mode, external crystal with a FOSC0 Hz frequency,
    // enable the OSC0, set the main clock source as being OSC0.
    pm_switch_to_osc0(&AVR32_PM, fcrystal, startup);
8000240c:	fe 7c 0c 00 	mov	r12,-62464
80002410:	f0 1f 00 02 	mcall	80002418 <pcl_switch_to_osc+0x18>
80002414:	d8 0a       	popm	pc,r12=0
80002416:	00 00       	add	r0,r0
80002418:	80 00       	ld.sh	r0,r0[0x0]
8000241a:	23 d4       	sub	r4,61

8000241c <udd_include_vbus_monitoring>:


bool udd_include_vbus_monitoring(void)
{
	return true;
}
8000241c:	5e ff       	retal	1

8000241e <udd_is_high_speed>:
#ifdef USB_DEVICE_HS_SUPPORT
	return !Is_udd_full_speed_mode();
#else
	return false;
#endif
}
8000241e:	5e fd       	retal	0

80002420 <udd_set_address>:


void udd_set_address(uint8_t address)
{
	udd_disable_address();
80002420:	fe 68 00 00 	mov	r8,-131072
80002424:	70 09       	ld.w	r9,r8[0x0]
80002426:	a7 d9       	cbr	r9,0x7
80002428:	91 09       	st.w	r8[0x0],r9
	udd_configure_address(address);
8000242a:	70 09       	ld.w	r9,r8[0x0]
8000242c:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
80002430:	e0 19 ff 80 	andl	r9,0xff80
80002434:	f9 e9 10 09 	or	r9,r12,r9
80002438:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
8000243a:	70 09       	ld.w	r9,r8[0x0]
8000243c:	a7 b9       	sbr	r9,0x7
8000243e:	91 09       	st.w	r8[0x0],r9
}
80002440:	5e fc       	retal	r12

80002442 <udd_getaddress>:


uint8_t udd_getaddress(void)
{
	return udd_get_configured_address();
80002442:	fe 68 00 00 	mov	r8,-131072
80002446:	70 0c       	ld.w	r12,r8[0x0]
}
80002448:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
8000244c:	5e fc       	retal	r12

8000244e <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
	return udd_frame_number();
8000244e:	fe 68 00 00 	mov	r8,-131072
80002452:	70 8c       	ld.w	r12,r8[0x20]
}
80002454:	f9 dc c0 6b 	bfextu	r12,r12,0x3,0xb
80002458:	5e fc       	retal	r12

8000245a <udd_get_micro_frame_number>:

uint16_t udd_get_micro_frame_number(void)
{
	return udd_micro_frame_number();
8000245a:	fe 68 00 00 	mov	r8,-131072
8000245e:	70 8c       	ld.w	r12,r8[0x20]
}
80002460:	f9 dc c0 0e 	bfextu	r12,r12,0x0,0xe
80002464:	5e fc       	retal	r12
80002466:	d7 03       	nop

80002468 <udd_set_setup_payload>:
}


void udd_set_setup_payload( uint8_t *payload,	uint16_t payload_size )
{
	udd_g_ctrlreq.payload = payload;
80002468:	48 28       	lddpc	r8,80002470 <udd_set_setup_payload+0x8>
8000246a:	91 2c       	st.w	r8[0x8],r12
	udd_g_ctrlreq.payload_size = payload_size;
8000246c:	b0 6b       	st.h	r8[0xc],r11
}
8000246e:	5e fc       	retal	r12
80002470:	00 00       	add	r0,r0
80002472:	0a 10       	sub	r0,r5

80002474 <udd_ep_is_halted>:
}


bool udd_ep_is_halted(udd_ep_id_t ep)
{
	return Is_udd_endpoint_stall_requested(ep & USB_EP_ADDR_MASK);
80002474:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
80002478:	a3 68       	lsl	r8,0x2
8000247a:	e0 38 fe 40 	sub	r8,130624
8000247e:	70 0c       	ld.w	r12,r8[0x0]
}
80002480:	f9 dc c2 61 	bfextu	r12,r12,0x13,0x1
80002484:	5e fc       	retal	r12
80002486:	d7 03       	nop

80002488 <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
	udd_ep_job_t *ptr_job;
	uint8_t index = ep & USB_EP_ADDR_MASK;
80002488:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4

	if (USB_DEVICE_MAX_EP < index)
8000248c:	30 38       	mov	r8,3
8000248e:	f0 0c 18 00 	cp.b	r12,r8
80002492:	e0 8b 00 35 	brhi	800024fc <udd_ep_set_halt+0x74>
		return false;

	ptr_job = &udd_ep_job[index - 1];
80002496:	18 99       	mov	r9,r12
80002498:	f8 c8 00 01 	sub	r8,r12,1
8000249c:	a5 68       	lsl	r8,0x4
8000249e:	49 9a       	lddpc	r10,80002500 <udd_ep_set_halt+0x78>
800024a0:	f4 08 00 08 	add	r8,r10,r8
	if (ptr_job->busy == true) {
800024a4:	70 0a       	ld.w	r10,r8[0x0]
800024a6:	58 0a       	cp.w	r10,0
800024a8:	c2 a5       	brlt	800024fc <udd_ep_set_halt+0x74>
		return false;	// Job on going, stall impossible
	}
	
	if (0 != udd_nb_busy_bank(index)) {
800024aa:	a3 69       	lsl	r9,0x2
800024ac:	fe 6b 01 30 	mov	r11,-130768
800024b0:	f2 0b 00 0a 	add	r10,r9,r11
800024b4:	74 0a       	ld.w	r10,r10[0x0]
800024b6:	f5 da c1 82 	bfextu	r10,r10,0xc,0x2
800024ba:	c1 10       	breq	800024dc <udd_ep_set_halt+0x54>
		// Wait end of transfer on USB line before stall endpoint
		// Flag a stall requested
		ptr_job->stall_requested = true;
800024bc:	70 0b       	ld.w	r11,r8[0x0]
800024be:	30 1a       	mov	r10,1
800024c0:	f7 da d3 81 	bfins	r11,r10,0x1c,0x1
800024c4:	91 0b       	st.w	r8[0x0],r11
		udd_enable_bank_interrupt(index);
800024c6:	e0 39 fe 10 	sub	r9,130576
800024ca:	e0 68 10 00 	mov	r8,4096
800024ce:	93 08       	st.w	r9[0x0],r8
		udd_enable_endpoint_interrupt(index);
800024d0:	f0 0c 09 4c 	lsl	r12,r8,r12
800024d4:	fe 69 00 00 	mov	r9,-131072
800024d8:	93 6c       	st.w	r9[0x18],r12
800024da:	5e fa       	retal	r10
	} else {
		// Stall endpoint
		udd_disable_endpoint_bank_autoswitch(index);
800024dc:	fe 6a 01 00 	mov	r10,-130816
800024e0:	f2 0a 00 08 	add	r8,r9,r10
800024e4:	70 0a       	ld.w	r10,r8[0x0]
800024e6:	a9 da       	cbr	r10,0x9
800024e8:	91 0a       	st.w	r8[0x0],r10
		udd_enable_stall_handshake(index);
800024ea:	e0 39 fe 10 	sub	r9,130576
800024ee:	e8 68 00 00 	mov	r8,524288
800024f2:	93 08       	st.w	r9[0x0],r8
		udd_reset_data_toggle(index);
800024f4:	e4 68 00 00 	mov	r8,262144
800024f8:	93 08       	st.w	r9[0x0],r8
800024fa:	5e ff       	retal	1
800024fc:	5e fd       	retal	0
800024fe:	00 00       	add	r0,r0
80002500:	00 00       	add	r0,r0
80002502:	07 28       	ld.uh	r8,r3++

80002504 <udd_ep_clear_halt>:
	return true;
}


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
80002504:	d4 01       	pushm	lr
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
80002506:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
8000250a:	30 38       	mov	r8,3
8000250c:	f0 0c 18 00 	cp.b	r12,r8
80002510:	e0 88 00 03 	brls	80002516 <udd_ep_clear_halt+0x12>
80002514:	d8 0a       	popm	pc,r12=0
		return false;
	ptr_job = &udd_ep_job[ep - 1];
80002516:	f8 c8 00 01 	sub	r8,r12,1
8000251a:	a5 68       	lsl	r8,0x4
8000251c:	49 69       	lddpc	r9,80002574 <udd_ep_clear_halt+0x70>
8000251e:	f2 08 00 08 	add	r8,r9,r8

	if (Is_udd_endpoint_stall_requested(ep)	// Endpoint stalled
80002522:	a3 6c       	lsl	r12,0x2
80002524:	fe 6a 01 c0 	mov	r10,-130624
80002528:	f8 0a 00 09 	add	r9,r12,r10
8000252c:	72 09       	ld.w	r9,r9[0x0]
8000252e:	e6 19 00 08 	andh	r9,0x8,COH
80002532:	c0 51       	brne	8000253c <udd_ep_clear_halt+0x38>
			|| ptr_job->stall_requested) {	// Endpoint stall is requested
80002534:	70 09       	ld.w	r9,r8[0x0]
80002536:	e6 19 10 00 	andh	r9,0x1000,COH
8000253a:	c1 c0       	breq	80002572 <udd_ep_clear_halt+0x6e>
		// Remove request to stall
		ptr_job->stall_requested = false;
8000253c:	70 09       	ld.w	r9,r8[0x0]
8000253e:	30 0a       	mov	r10,0
80002540:	f3 da d3 81 	bfins	r9,r10,0x1c,0x1
80002544:	91 09       	st.w	r8[0x0],r9
		// Remove stall
		udd_disable_stall_handshake(ep);
80002546:	fe 6a 02 20 	mov	r10,-130528
8000254a:	f8 0a 00 09 	add	r9,r12,r10
8000254e:	e8 6a 00 00 	mov	r10,524288
80002552:	93 0a       	st.w	r9[0x0],r10
		udd_enable_endpoint_bank_autoswitch(ep);	
80002554:	e0 3c ff 00 	sub	r12,130816
80002558:	78 09       	ld.w	r9,r12[0x0]
8000255a:	a9 b9       	sbr	r9,0x9
8000255c:	99 09       	st.w	r12[0x0],r9
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
8000255e:	70 09       	ld.w	r9,r8[0x0]
80002560:	58 09       	cp.w	r9,0
80002562:	c0 84       	brge	80002572 <udd_ep_clear_halt+0x6e>
			ptr_job->busy = false;
80002564:	30 0a       	mov	r10,0
80002566:	f3 da d3 e1 	bfins	r9,r10,0x1f,0x1
8000256a:	91 09       	st.w	r8[0x0],r9
			ptr_job->call_nohalt();
8000256c:	70 38       	ld.w	r8,r8[0xc]
8000256e:	5d 18       	icall	r8
80002570:	da 0a       	popm	pc,r12=1
80002572:	da 0a       	popm	pc,r12=1
80002574:	00 00       	add	r0,r0
80002576:	07 28       	ld.uh	r8,r3++

80002578 <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
80002578:	30 59       	mov	r9,5
8000257a:	48 58       	lddpc	r8,8000258c <udd_ctrl_stall_data+0x14>
8000257c:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(0);
8000257e:	e8 69 00 00 	mov	r9,524288
80002582:	fe 68 01 f0 	mov	r8,-130576
80002586:	91 09       	st.w	r8[0x0],r9
}
80002588:	5e fc       	retal	r12
8000258a:	00 00       	add	r0,r0
8000258c:	00 00       	add	r0,r0
8000258e:	07 5c       	ld.sh	r12,--r3

80002590 <udd_ctrl_endofrequest>:
	cpu_irq_restore(flags);
}


static void udd_ctrl_endofrequest(void)
{
80002590:	d4 01       	pushm	lr
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
80002592:	48 48       	lddpc	r8,800025a0 <udd_ctrl_endofrequest+0x10>
80002594:	70 48       	ld.w	r8,r8[0x10]
80002596:	58 08       	cp.w	r8,0
80002598:	c0 20       	breq	8000259c <udd_ctrl_endofrequest+0xc>
		udd_g_ctrlreq.callback();
8000259a:	5d 18       	icall	r8
8000259c:	d8 02       	popm	pc
8000259e:	00 00       	add	r0,r0
800025a0:	00 00       	add	r0,r0
800025a2:	0a 10       	sub	r0,r5

800025a4 <udd_ep_finish_job>:
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
}


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort)
{
800025a4:	d4 01       	pushm	lr
800025a6:	16 99       	mov	r9,r11
	if (ptr_job->busy == false)
800025a8:	78 08       	ld.w	r8,r12[0x0]
800025aa:	58 08       	cp.w	r8,0
800025ac:	c0 b4       	brge	800025c2 <udd_ep_finish_job+0x1e>
		return;	// No on-going job
	ptr_job->busy = false;
800025ae:	30 0a       	mov	r10,0
800025b0:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
800025b4:	99 08       	st.w	r12[0x0],r8
	if (NULL == ptr_job->call_trans)
800025b6:	78 38       	ld.w	r8,r12[0xc]
800025b8:	58 08       	cp.w	r8,0
800025ba:	c0 40       	breq	800025c2 <udd_ep_finish_job+0x1e>
		return;	// No callback linked to job
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
800025bc:	78 2b       	ld.w	r11,r12[0x8]
800025be:	12 9c       	mov	r12,r9
800025c0:	5d 18       	icall	r8
800025c2:	d8 02       	popm	pc

800025c4 <udd_ep_abort_job>:
	}
}


static void udd_ep_abort_job(udd_ep_id_t ep)
{
800025c4:	d4 01       	pushm	lr
	ep &= USB_EP_ADDR_MASK;
	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true);
800025c6:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
800025ca:	20 18       	sub	r8,1
800025cc:	a5 68       	lsl	r8,0x4
800025ce:	30 1b       	mov	r11,1
800025d0:	48 3c       	lddpc	r12,800025dc <udd_ep_abort_job+0x18>
800025d2:	10 0c       	add	r12,r8
800025d4:	f0 1f 00 03 	mcall	800025e0 <udd_ep_abort_job+0x1c>
}
800025d8:	d8 02       	popm	pc
800025da:	00 00       	add	r0,r0
800025dc:	00 00       	add	r0,r0
800025de:	07 28       	ld.uh	r8,r3++
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	25 a4       	sub	r4,90

800025e4 <udd_ep_free>:
	return true;
}


void udd_ep_free(udd_ep_id_t ep)
{
800025e4:	d4 01       	pushm	lr
	udd_disable_endpoint(ep & USB_EP_ADDR_MASK);
800025e6:	fe 69 00 00 	mov	r9,-131072
800025ea:	72 7b       	ld.w	r11,r9[0x1c]
800025ec:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4
800025f0:	30 1a       	mov	r10,1
800025f2:	f4 08 09 4a 	lsl	r10,r10,r8
800025f6:	5c da       	com	r10
800025f8:	16 6a       	and	r10,r11
800025fa:	93 7a       	st.w	r9[0x1c],r10
	udd_unallocate_memory(ep & USB_EP_ADDR_MASK);
800025fc:	a3 68       	lsl	r8,0x2
800025fe:	e0 38 ff 00 	sub	r8,130816
80002602:	70 09       	ld.w	r9,r8[0x0]
80002604:	a1 d9       	cbr	r9,0x1
80002606:	91 09       	st.w	r8[0x0],r9
	udd_ep_abort_job(ep);
80002608:	f0 1f 00 02 	mcall	80002610 <udd_ep_free+0x2c>
}
8000260c:	d8 02       	popm	pc
8000260e:	00 00       	add	r0,r0
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	25 c4       	sub	r4,92

80002614 <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
80002614:	eb cd 40 fc 	pushm	r2-r7,lr
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
	ep &= USB_EP_ADDR_MASK;
80002618:	fd dc c0 04 	bfextu	lr,r12,0x0,0x4
	if (USB_DEVICE_MAX_EP < ep)
8000261c:	30 37       	mov	r7,3
8000261e:	ee 0e 18 00 	cp.b	lr,r7
80002622:	e0 8b 00 99 	brhi	80002754 <udd_ep_run+0x140>
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
80002626:	fe 67 00 00 	mov	r7,-131072
8000262a:	6e 76       	ld.w	r6,r7[0x1c]
8000262c:	1c 95       	mov	r5,lr
8000262e:	30 17       	mov	r7,1
80002630:	ee 0e 09 47 	lsl	r7,r7,lr
80002634:	0c 67       	and	r7,r6
80002636:	e0 80 00 8f 	breq	80002754 <udd_ep_run+0x140>
			|| Is_udd_endpoint_stall_requested(ep)
8000263a:	fc 06 15 02 	lsl	r6,lr,0x2
8000263e:	fe 64 01 c0 	mov	r4,-130624
80002642:	ec 04 00 07 	add	r7,r6,r4
80002646:	6e 07       	ld.w	r7,r7[0x0]
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
80002648:	e6 17 00 08 	andh	r7,0x8,COH
8000264c:	e0 81 00 84 	brne	80002754 <udd_ep_run+0x140>
	ep &= USB_EP_ADDR_MASK;
	if (USB_DEVICE_MAX_EP < ep)
		return false;

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
80002650:	fc c7 00 01 	sub	r7,lr,1
80002654:	a5 67       	lsl	r7,0x4
80002656:	4c 14       	lddpc	r4,80002758 <udd_ep_run+0x144>
80002658:	e8 07 00 07 	add	r7,r4,r7

	if ((!Is_udd_endpoint_enabled(ep))
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested)
8000265c:	6e 04       	ld.w	r4,r7[0x0]
8000265e:	e6 14 10 00 	andh	r4,0x1000,COH
80002662:	c7 91       	brne	80002754 <udd_ep_run+0x140>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002664:	e1 b4 00 00 	mfsr	r4,0x0
	cpu_irq_disable();
80002668:	d3 03       	ssrf	0x10
		return false;	// Endpoint is halted

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
8000266a:	6e 03       	ld.w	r3,r7[0x0]
8000266c:	58 03       	cp.w	r3,0
8000266e:	c0 54       	brge	80002678 <udd_ep_run+0x64>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002670:	e3 b4 00 00 	mtsr	0x0,r4
#endif
	barrier();
80002674:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
	bool b_dir_in;
	uint32_t udd_dma_ctrl = 0;
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	b_dir_in = (USB_EP_DIR_IN == (ep & USB_EP_DIR_IN));
80002678:	f9 dc c0 e8 	bfextu	r12,r12,0x7,0x8
	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
		cpu_irq_restore(flags);
		return false;	// Job already on going
	}
	ptr_job->busy = true;
8000267c:	6e 03       	ld.w	r3,r7[0x0]
8000267e:	30 12       	mov	r2,1
80002680:	e7 d2 d3 e1 	bfins	r3,r2,0x1f,0x1
80002684:	8f 03       	st.w	r7[0x0],r3
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002686:	e3 b4 00 00 	mtsr	0x0,r4
	cpu_irq_restore(flags);
	ptr_job->buf = buf;
8000268a:	8f 1a       	st.w	r7[0x4],r10
	ptr_job->call_trans = callback;
8000268c:	8f 38       	st.w	r7[0xc],r8
	ptr_job->b_raise_dma = false;
8000268e:	6e 08       	ld.w	r8,r7[0x0]
80002690:	30 04       	mov	r4,0
80002692:	f1 d4 d3 a1 	bfins	r8,r4,0x1d,0x1
80002696:	8f 08       	st.w	r7[0x0],r8

	// The USBB supports a maximum transfer size of 64KB
	if (0x10000 <= buf_size) {
80002698:	e0 49 ff ff 	cp.w	r9,65535
8000269c:	e0 88 00 07 	brls	800026aa <udd_ep_run+0x96>
		// Transfer size = 64KB
		ptr_job->buf_size = 0x10000;
800026a0:	e0 78 00 00 	mov	r8,65536
800026a4:	8f 28       	st.w	r7[0x8],r8
800026a6:	08 99       	mov	r9,r4
800026a8:	c3 58       	rjmp	80002712 <udd_ep_run+0xfe>
		buf_size = 0;
	} else {
		ptr_job->buf_size = buf_size;
800026aa:	8f 29       	st.w	r7[0x8],r9
		if (b_dir_in) {
800026ac:	58 0c       	cp.w	r12,0
800026ae:	c3 20       	breq	80002712 <udd_ep_run+0xfe>
			if (buf_size==0) {
800026b0:	58 09       	cp.w	r9,0
800026b2:	c1 71       	brne	800026e0 <udd_ep_run+0xcc>
				// The USB DMA can't send a empty buffer
				// thus we raise the DMA interrupt end of transfert 
				// to execute ZLP process
				ptr_job->b_raise_dma = true;
800026b4:	6e 08       	ld.w	r8,r7[0x0]
800026b6:	30 1c       	mov	r12,1
				ptr_job->b_send_zlp = true;
800026b8:	bd b8       	sbr	r8,0x1d
800026ba:	f1 dc d3 c1 	bfins	r8,r12,0x1e,0x1
800026be:	8f 08       	st.w	r7[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800026c0:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
800026c4:	d3 03       	ssrf	0x10
				flags = cpu_irq_save();
				udd_enable_endpoint_dma_interrupt(ep);
800026c6:	20 15       	sub	r5,1
800026c8:	fc 19 02 00 	movh	r9,0x200
800026cc:	f2 05 09 49 	lsl	r9,r9,r5
800026d0:	fe 68 00 00 	mov	r8,-131072
800026d4:	91 69       	st.w	r8[0x18],r9
				udd_raise_endpoint_dma_interrupt(ep);
800026d6:	91 39       	st.w	r8[0xc],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800026d8:	e3 ba 00 00 	mtsr	0x0,r10
				cpu_irq_restore(flags);
				return true;
800026dc:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
			}
			if (0 != buf_size % udd_get_endpoint_size(ep)) {
800026e0:	e0 36 ff 00 	sub	r6,130816
800026e4:	6c 08       	ld.w	r8,r6[0x0]
800026e6:	f1 d8 c0 83 	bfextu	r8,r8,0x4,0x3
800026ea:	30 86       	mov	r6,8
800026ec:	ec 08 09 48 	lsl	r8,r6,r8
800026f0:	20 18       	sub	r8,1
800026f2:	12 68       	and	r8,r9
800026f4:	c0 b0       	breq	8000270a <udd_ep_run+0xf6>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
800026f6:	6e 08       	ld.w	r8,r7[0x0]
800026f8:	30 0b       	mov	r11,0
800026fa:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
800026fe:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
80002700:	a5 6e       	lsl	lr,0x4
80002702:	e0 3e fd 00 	sub	lr,130304
80002706:	9d 1a       	st.w	lr[0x4],r10
80002708:	c1 18       	rjmp	8000272a <udd_ep_run+0x116>
				// Force short packet option to send a shortpacket on IN,
				// else the DMA transfer is accepted and interrupt DMA valid but nothing is sent.
				b_shortpacket = true;
				ptr_job->b_send_zlp = false;
			}else{
				ptr_job->b_send_zlp = b_shortpacket;
8000270a:	6e 08       	ld.w	r8,r7[0x0]
8000270c:	f1 db d3 c1 	bfins	r8,r11,0x1e,0x1
80002710:	8f 08       	st.w	r7[0x0],r8
			}
		}
	}

	// Start USB DMA to fill or read fifo of the selected endpoint
	udd_endpoint_dma_set_addr(ep, (U32) buf);
80002712:	a5 6e       	lsl	lr,0x4
80002714:	e0 3e fd 00 	sub	lr,130304
80002718:	9d 1a       	st.w	lr[0x4],r10
	if (b_shortpacket) {
8000271a:	58 0b       	cp.w	r11,0
8000271c:	c0 31       	brne	80002722 <udd_ep_run+0x10e>
8000271e:	30 08       	mov	r8,0
80002720:	c0 68       	rjmp	8000272c <udd_ep_run+0x118>
		if (b_dir_in) {
80002722:	58 0c       	cp.w	r12,0
80002724:	c0 31       	brne	8000272a <udd_ep_run+0x116>
80002726:	31 48       	mov	r8,20
80002728:	c0 28       	rjmp	8000272c <udd_ep_run+0x118>
8000272a:	30 88       	mov	r8,8
		} else {
			udd_dma_ctrl = AVR32_USBB_UDDMA1_CONTROL_EOT_IRQ_EN_MASK
					| AVR32_USBB_UDDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
		}
	}
	udd_dma_ctrl |= (buf_size <<
8000272c:	e8 18 00 21 	orl	r8,0x21
			AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
			& AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
	udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
80002730:	f1 e9 11 09 	or	r9,r8,r9<<0x10
			AVR32_USBB_UDDMA1_CONTROL_CH_EN_MASK;
	udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
80002734:	9d 29       	st.w	lr[0x8],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002736:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
8000273a:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_endpoint_dma_interrupt(ep);
8000273c:	20 15       	sub	r5,1
8000273e:	fc 19 02 00 	movh	r9,0x200
80002742:	f2 05 09 45 	lsl	r5,r9,r5
80002746:	fe 69 00 00 	mov	r9,-131072
8000274a:	93 65       	st.w	r9[0x18],r5
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000274c:	e3 b8 00 00 	mtsr	0x0,r8
#endif
	barrier();
80002750:	e3 cf 90 fc 	ldm	sp++,r2-r7,pc,r12=1
	cpu_irq_restore(flags);

	return true;
80002754:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80002758:	00 00       	add	r0,r0
8000275a:	07 28       	ld.uh	r8,r3++

8000275c <udd_sleep_mode>:
 * 
 * \param b_enable   true to authorize powerdown mode
 */
static void udd_sleep_mode(bool b_idle)
{
	if (!b_idle && udd_b_idle) {
8000275c:	58 0c       	cp.w	r12,0
8000275e:	c1 11       	brne	80002780 <udd_sleep_mode+0x24>
80002760:	49 18       	lddpc	r8,800027a4 <udd_sleep_mode+0x48>
80002762:	11 89       	ld.ub	r9,r8[0x0]
80002764:	30 08       	mov	r8,0
80002766:	f0 09 18 00 	cp.b	r9,r8
8000276a:	c1 a0       	breq	8000279e <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000276c:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002770:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
80002772:	48 e8       	lddpc	r8,800027a8 <udd_sleep_mode+0x4c>
80002774:	11 9a       	ld.ub	r10,r8[0x1]
80002776:	2f fa       	sub	r10,-1
80002778:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000277a:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
8000277e:	c1 08       	rjmp	8000279e <udd_sleep_mode+0x42>
		sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	if (b_idle && !udd_b_idle) {
80002780:	48 98       	lddpc	r8,800027a4 <udd_sleep_mode+0x48>
80002782:	11 89       	ld.ub	r9,r8[0x0]
80002784:	30 08       	mov	r8,0
80002786:	f0 09 18 00 	cp.b	r9,r8
8000278a:	c0 a1       	brne	8000279e <udd_sleep_mode+0x42>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000278c:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002790:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode]);

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
80002792:	48 68       	lddpc	r8,800027a8 <udd_sleep_mode+0x4c>
80002794:	11 9a       	ld.ub	r10,r8[0x1]
80002796:	20 1a       	sub	r10,1
80002798:	b0 9a       	st.b	r8[0x1],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000279a:	e3 b9 00 00 	mtsr	0x0,r9
		sleepmgr_unlock_mode(USBB_SLEEP_MODE_USB_IDLE);
	}
	udd_b_idle = b_idle;
8000279e:	48 28       	lddpc	r8,800027a4 <udd_sleep_mode+0x48>
800027a0:	b0 8c       	st.b	r8[0x0],r12
}
800027a2:	5e fc       	retal	r12
800027a4:	00 00       	add	r0,r0
800027a6:	07 58       	ld.sh	r8,--r3
800027a8:	00 00       	add	r0,r0
800027aa:	0a 28       	rsub	r8,r5

800027ac <udd_detach>:
	cpu_irq_restore(flags);
}


void udd_detach(void)
{
800027ac:	d4 01       	pushm	lr
	otg_unfreeze_clock();
800027ae:	fe 68 00 00 	mov	r8,-131072
800027b2:	f0 f9 08 00 	ld.w	r9,r8[2048]
800027b6:	af c9       	cbr	r9,0xe
800027b8:	f1 49 08 00 	st.w	r8[2048],r9
	// Detach device from the bus
	udd_detach_device();
800027bc:	70 09       	ld.w	r9,r8[0x0]
800027be:	a9 a9       	sbr	r9,0x8
800027c0:	91 09       	st.w	r8[0x0],r9
	udd_sleep_mode(false);
800027c2:	30 0c       	mov	r12,0
800027c4:	f0 1f 00 02 	mcall	800027cc <udd_detach+0x20>
}
800027c8:	d8 02       	popm	pc
800027ca:	00 00       	add	r0,r0
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	27 5c       	sub	r12,117

800027d0 <udd_ctrl_init>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800027d0:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
800027d4:	d3 03       	ssrf	0x10
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI), 
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI 
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
800027d6:	30 1a       	mov	r10,1
800027d8:	fe 69 02 20 	mov	r9,-130528
800027dc:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800027de:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);
	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
800027e2:	30 29       	mov	r9,2
800027e4:	fe 68 01 60 	mov	r8,-130720
800027e8:	91 09       	st.w	r8[0x0],r9

	udd_g_ctrlreq.callback = NULL;
800027ea:	48 59       	lddpc	r9,800027fc <udd_ctrl_init+0x2c>
800027ec:	30 08       	mov	r8,0
800027ee:	93 48       	st.w	r9[0x10],r8
	udd_g_ctrlreq.over_under_run = NULL;
800027f0:	93 58       	st.w	r9[0x14],r8
	udd_g_ctrlreq.payload_size = 0;
800027f2:	b2 68       	st.h	r9[0xc],r8
	udd_ep_control_state = UDD_EPCTRL_SETUP;
800027f4:	48 39       	lddpc	r9,80002800 <udd_ctrl_init+0x30>
800027f6:	93 08       	st.w	r9[0x0],r8
}
800027f8:	5e fc       	retal	r12
800027fa:	00 00       	add	r0,r0
800027fc:	00 00       	add	r0,r0
800027fe:	0a 10       	sub	r0,r5
80002800:	00 00       	add	r0,r0
80002802:	07 5c       	ld.sh	r12,--r3

80002804 <udd_ctrl_send_zlp_in>:

static void udd_ctrl_send_zlp_in(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
80002804:	30 39       	mov	r9,3
80002806:	48 a8       	lddpc	r8,8000282c <udd_ctrl_send_zlp_in+0x28>
80002808:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000280a:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
8000280e:	d3 03       	ssrf	0x10
	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
80002810:	fe 6a 01 60 	mov	r10,-130720
80002814:	30 19       	mov	r9,1
80002816:	95 09       	st.w	r10[0x0],r9
	udd_enable_in_send_interrupt(0);
80002818:	fe 68 01 f0 	mov	r8,-130576
8000281c:	91 09       	st.w	r8[0x0],r9
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
8000281e:	30 89       	mov	r9,8
80002820:	95 09       	st.w	r10[0x0],r9
	udd_enable_nak_out_interrupt(0);
80002822:	91 09       	st.w	r8[0x0],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002824:	e3 bb 00 00 	mtsr	0x0,r11
	cpu_irq_restore(flags);
}
80002828:	5e fc       	retal	r12
8000282a:	00 00       	add	r0,r0
8000282c:	00 00       	add	r0,r0
8000282e:	07 5c       	ld.sh	r12,--r3

80002830 <udd_ctrl_in_sent>:
	}
}


static void udd_ctrl_in_sent(void)
{
80002830:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002834:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80002838:	d3 03       	ssrf	0x10
	uint8_t i;
	uint8_t *ptr_dest, *ptr_src;
	irqflags_t flags;

	flags = cpu_irq_save();
	udd_disable_in_send_interrupt(0);
8000283a:	30 1a       	mov	r10,1
8000283c:	fe 69 02 20 	mov	r9,-130528
80002840:	93 0a       	st.w	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002842:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
80002846:	4c 38       	lddpc	r8,80002950 <udd_ctrl_in_sent+0x120>
80002848:	70 08       	ld.w	r8,r8[0x0]
8000284a:	58 38       	cp.w	r8,3
8000284c:	c0 71       	brne	8000285a <udd_ctrl_in_sent+0x2a>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
8000284e:	f0 1f 00 42 	mcall	80002954 <udd_ctrl_in_sent+0x124>
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002852:	f0 1f 00 42 	mcall	80002958 <udd_ctrl_in_sent+0x128>
		return;
80002856:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
8000285a:	4c 18       	lddpc	r8,8000295c <udd_ctrl_in_sent+0x12c>
8000285c:	90 68       	ld.sh	r8,r8[0xc]
8000285e:	4c 19       	lddpc	r9,80002960 <udd_ctrl_in_sent+0x130>
80002860:	92 07       	ld.sh	r7,r9[0x0]
80002862:	f0 07 01 07 	sub	r7,r8,r7
80002866:	5c 87       	casts.h	r7
	if (0 == nb_remain) {
80002868:	c3 b1       	brne	800028de <udd_ctrl_in_sent+0xae>
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
8000286a:	4b f9       	lddpc	r9,80002964 <udd_ctrl_in_sent+0x134>
8000286c:	13 8a       	ld.ub	r10,r9[0x0]
8000286e:	30 09       	mov	r9,0
80002870:	f2 0a 18 00 	cp.b	r10,r9
80002874:	c1 21       	brne	80002898 <udd_ctrl_in_sent+0x68>

static void udd_ctrl_send_zlp_out(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
80002876:	30 49       	mov	r9,4
80002878:	4b 68       	lddpc	r8,80002950 <udd_ctrl_in_sent+0x120>
8000287a:	91 09       	st.w	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000287c:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002880:	d3 03       	ssrf	0x10
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
	udd_ack_nak_in(0);
80002882:	31 08       	mov	r8,16
80002884:	fe 6a 01 60 	mov	r10,-130720
80002888:	95 08       	st.w	r10[0x0],r8
	udd_enable_nak_in_interrupt(0);
8000288a:	fe 6a 01 f0 	mov	r10,-130576
8000288e:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002890:	e3 b9 00 00 	mtsr	0x0,r9
		// All content of current buffer payload are sent
		if (!udd_ctrl_payload_need_in_zlp) {
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
80002894:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
80002898:	4b 19       	lddpc	r9,8000295c <udd_ctrl_in_sent+0x12c>
8000289a:	92 b9       	ld.uh	r9,r9[0x6]
8000289c:	5c 78       	castu.h	r8
8000289e:	4b 3a       	lddpc	r10,80002968 <udd_ctrl_in_sent+0x138>
800028a0:	94 8a       	ld.uh	r10,r10[0x0]
800028a2:	14 08       	add	r8,r10
800028a4:	10 39       	cp.w	r9,r8
800028a6:	e0 89 00 08 	brgt	800028b6 <udd_ctrl_in_sent+0x86>
								+
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
800028aa:	4a d8       	lddpc	r8,8000295c <udd_ctrl_in_sent+0x12c>
800028ac:	70 5c       	ld.w	r12,r8[0x14]
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
800028ae:	58 0c       	cp.w	r12,0
800028b0:	c0 30       	breq	800028b6 <udd_ctrl_in_sent+0x86>
800028b2:	5d 1c       	icall	r12
800028b4:	c0 51       	brne	800028be <udd_ctrl_in_sent+0x8e>
								udd_g_ctrlreq.
								payload_size))
				|| (!udd_g_ctrlreq.over_under_run)
				|| (!udd_g_ctrlreq.over_under_run())) {
			// Underrun or data packet complette than send zlp on IN (note don't change DataToggle)
			udd_ctrl_payload_need_in_zlp = false;
800028b6:	30 09       	mov	r9,0
800028b8:	4a b8       	lddpc	r8,80002964 <udd_ctrl_in_sent+0x134>
800028ba:	b0 89       	st.b	r8[0x0],r9
			// It is the end of data phase, because the last data packet is a short packet
			// then generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		if ((udd_g_ctrlreq.req.wLength > (udd_ctrl_prev_payload_nb_trans
800028bc:	c1 18       	rjmp	800028de <udd_ctrl_in_sent+0xae>
			udd_ctrl_payload_need_in_zlp = false;
			// nb_remain==0 allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			// Update number of total data sending by previous playlaod buffer
			udd_ctrl_prev_payload_nb_trans +=
800028be:	4a b9       	lddpc	r9,80002968 <udd_ctrl_in_sent+0x138>
800028c0:	4a 88       	lddpc	r8,80002960 <udd_ctrl_in_sent+0x130>
800028c2:	90 0b       	ld.sh	r11,r8[0x0]
800028c4:	92 0a       	ld.sh	r10,r9[0x0]
800028c6:	f6 0a 00 0a 	add	r10,r11,r10
800028ca:	b2 0a       	st.h	r9[0x0],r10
					udd_ctrl_payload_nb_trans;
			// Update maangement of current playoad transfer
			udd_ctrl_payload_nb_trans = 0;
800028cc:	30 09       	mov	r9,0
800028ce:	b0 09       	st.h	r8[0x0],r9
			nb_remain = udd_g_ctrlreq.payload_size;
800028d0:	4a 38       	lddpc	r8,8000295c <udd_ctrl_in_sent+0x12c>
800028d2:	90 67       	ld.sh	r7,r8[0xc]
			// Compute if an IN ZLP must be send after IN data
			udd_ctrl_payload_need_in_zlp =
800028d4:	f1 d7 c0 06 	bfextu	r8,r7,0x0,0x6
800028d8:	5f 09       	sreq	r9
800028da:	4a 38       	lddpc	r8,80002964 <udd_ctrl_in_sent+0x134>
800028dc:	b0 89       	st.b	r8[0x0],r9
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
800028de:	4a 08       	lddpc	r8,8000295c <udd_ctrl_in_sent+0x12c>
800028e0:	70 2a       	ld.w	r10,r8[0x8]
800028e2:	4a 08       	lddpc	r8,80002960 <udd_ctrl_in_sent+0x130>
800028e4:	90 09       	ld.sh	r9,r8[0x0]

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800028e6:	e1 bb 00 00 	mfsr	r11,0x0
	cpu_irq_disable();
800028ea:	d3 03       	ssrf	0x10
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write 
	// and if no OUT ZLP is recevied the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
800028ec:	fe 68 01 30 	mov	r8,-130768
800028f0:	70 08       	ld.w	r8,r8[0x0]
800028f2:	e2 18 00 02 	andl	r8,0x2,COH
800028f6:	c0 91       	brne	80002908 <udd_ctrl_in_sent+0xd8>
800028f8:	34 08       	mov	r8,64
800028fa:	f0 07 19 00 	cp.h	r7,r8
800028fe:	f9 b7 0b 40 	movhi	r7,64
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
80002902:	58 07       	cp.w	r7,0
80002904:	c0 91       	brne	80002916 <udd_ctrl_in_sent+0xe6>
80002906:	c1 48       	rjmp	8000292e <udd_ctrl_in_sent+0xfe>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002908:	e3 bb 00 00 	mtsr	0x0,r11
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
8000290c:	30 49       	mov	r9,4
8000290e:	49 18       	lddpc	r8,80002950 <udd_ctrl_in_sent+0x120>
80002910:	91 09       	st.w	r8[0x0],r9
		return;	// Exit of IN DATA phase
80002912:	e3 cd 80 80 	ldm	sp++,r7,pc
	if (nb_remain > USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002916:	5c 79       	castu.h	r9
80002918:	f4 09 00 09 	add	r9,r10,r9
8000291c:	fc 18 e0 00 	movh	r8,0xe000
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
		*ptr_dest++ = *ptr_src++;
80002920:	13 3a       	ld.ub	r10,r9++
80002922:	10 ca       	st.b	r8++,r10
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return;	// Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
80002924:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80002928:	ee 0a 19 00 	cp.h	r10,r7
8000292c:	cf a3       	brcs	80002920 <udd_ctrl_in_sent+0xf0>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_remain;
8000292e:	48 d8       	lddpc	r8,80002960 <udd_ctrl_in_sent+0x130>
80002930:	90 09       	ld.sh	r9,r8[0x0]
80002932:	f2 07 00 07 	add	r7,r9,r7
80002936:	b0 07       	st.h	r8[0x0],r7

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
80002938:	30 18       	mov	r8,1
8000293a:	fe 69 01 60 	mov	r9,-130720
8000293e:	93 08       	st.w	r9[0x0],r8
	udd_enable_in_send_interrupt(0);
80002940:	fe 69 01 f0 	mov	r9,-130576
80002944:	93 08       	st.w	r9[0x0],r8
80002946:	e3 bb 00 00 	mtsr	0x0,r11
#endif
	barrier();
8000294a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000294e:	00 00       	add	r0,r0
80002950:	00 00       	add	r0,r0
80002952:	07 5c       	ld.sh	r12,--r3
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	25 90       	sub	r0,89
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	27 d0       	sub	r0,125
8000295c:	00 00       	add	r0,r0
8000295e:	0a 10       	sub	r0,r5
80002960:	00 00       	add	r0,r0
80002962:	07 5a       	ld.sh	r10,--r3
80002964:	00 00       	add	r0,r0
80002966:	07 60       	ld.uh	r0,--r3
80002968:	00 00       	add	r0,r0
8000296a:	07 24       	ld.uh	r4,r3++

8000296c <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
8000296c:	eb cd 40 e0 	pushm	r5-r7,lr
	bool b_dir_in;
	uint16_t ep_allocated;
	uint8_t bank, i;

	b_dir_in = ep & USB_EP_DIR_IN;
	ep = ep & USB_EP_ADDR_MASK;
80002970:	f1 dc c0 04 	bfextu	r8,r12,0x0,0x4

	if (ep > USB_DEVICE_MAX_EP)
80002974:	30 39       	mov	r9,3
80002976:	f2 08 18 00 	cp.b	r8,r9
8000297a:	e0 8b 00 88 	brhi	80002a8a <udd_ep_alloc+0x11e>
		return false;
	if (Is_udd_endpoint_enabled(ep))
8000297e:	fe 69 00 00 	mov	r9,-131072
80002982:	72 79       	ld.w	r9,r9[0x1c]
80002984:	30 17       	mov	r7,1
80002986:	ee 08 09 47 	lsl	r7,r7,r8
8000298a:	ef e9 00 09 	and	r9,r7,r9
8000298e:	c7 e1       	brne	80002a8a <udd_ep_alloc+0x11e>
		return false;

	// Bank choise
	switch(bmAttributes&USB_EP_TYPE_MASK) {
80002990:	f3 db c0 02 	bfextu	r9,r11,0x0,0x2
80002994:	58 19       	cp.w	r9,1
80002996:	c7 a5       	brlt	80002a8a <udd_ep_alloc+0x11e>
80002998:	58 29       	cp.w	r9,2
8000299a:	e0 8a 00 06 	brle	800029a6 <udd_ep_alloc+0x3a>
8000299e:	58 39       	cp.w	r9,3
800029a0:	c7 51       	brne	80002a8a <udd_ep_alloc+0x11e>
800029a2:	30 06       	mov	r6,0
800029a4:	c0 28       	rjmp	800029a8 <udd_ep_alloc+0x3c>
800029a6:	30 16       	mov	r6,1
	Assert(MaxEndpointSize < 1024);
	Assert((MaxEndpointSize == 1023) || !(MaxEndpointSize & (MaxEndpointSize - 1)));
	Assert(MaxEndpointSize >= 8);
		   
	// Set configuration of new endpoint
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
800029a8:	f0 09 15 02 	lsl	r9,r8,0x2
800029ac:	e0 39 ff 00 	sub	r9,130816
800029b0:	72 0e       	ld.w	lr,r9[0x0]
800029b2:	5c 7a       	castu.h	r10
800029b4:	30 85       	mov	r5,8
800029b6:	f4 05 0c 4a 	max	r10,r10,r5
800029ba:	e0 65 04 00 	mov	r5,1024
800029be:	f4 05 0d 4a 	min	r10,r10,r5
800029c2:	a1 7a       	lsl	r10,0x1
800029c4:	20 1a       	sub	r10,1
800029c6:	f4 0a 12 00 	clz	r10,r10
800029ca:	f9 dc c0 e1 	bfextu	r12,r12,0x7,0x1
800029ce:	ab 7b       	lsl	r11,0xb
800029d0:	e2 1b 18 00 	andl	r11,0x1800,COH
800029d4:	f7 ec 10 8c 	or	r12,r11,r12<<0x8
800029d8:	f4 0b 11 1c 	rsub	r11,r10,28
800029dc:	f9 eb 10 4b 	or	r11,r12,r11<<0x4
800029e0:	f7 e6 10 2b 	or	r11,r11,r6<<0x2
800029e4:	e2 1b 19 7c 	andl	r11,0x197c,COH
800029e8:	1c 9a       	mov	r10,lr
800029ea:	e0 1a e6 83 	andl	r10,0xe683
800029ee:	f7 ea 10 0a 	or	r10,r11,r10
800029f2:	93 0a       	st.w	r9[0x0],r10
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;
800029f4:	5c 87       	casts.h	r7

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
800029f6:	30 29       	mov	r9,2
800029f8:	f2 08 18 00 	cp.b	r8,r9
800029fc:	e0 8b 00 1d 	brhi	80002a36 <udd_ep_alloc+0xca>
80002a00:	fe 6a 01 0c 	mov	r10,-130804
80002a04:	30 39       	mov	r9,3
		if (Is_udd_endpoint_enabled(i)) {
80002a06:	fe 6c 00 00 	mov	r12,-131072
80002a0a:	30 16       	mov	r6,1
80002a0c:	78 7e       	ld.w	lr,r12[0x1c]
80002a0e:	ec 09 09 4b 	lsl	r11,r6,r9
80002a12:	f7 ee 00 0e 	and	lr,r11,lr
80002a16:	c0 b0       	breq	80002a2c <udd_ep_alloc+0xc0>
			ep_allocated |= 1 << i;
80002a18:	f7 e7 10 07 	or	r7,r11,r7
80002a1c:	5c 87       	casts.h	r7
			udd_disable_endpoint(i);
80002a1e:	78 7e       	ld.w	lr,r12[0x1c]
80002a20:	5c db       	com	r11
80002a22:	1c 6b       	and	r11,lr
80002a24:	99 7b       	st.w	r12[0x1c],r11
			udd_unallocate_memory(i);
80002a26:	74 0b       	ld.w	r11,r10[0x0]
80002a28:	a1 db       	cbr	r11,0x1
80002a2a:	95 0b       	st.w	r10[0x0],r11
80002a2c:	20 19       	sub	r9,1
80002a2e:	20 4a       	sub	r10,4
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
80002a30:	f2 08 18 00 	cp.b	r8,r9
80002a34:	ce c3       	brcs	80002a0c <udd_ep_alloc+0xa0>
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
		if (ep_allocated & (1 << i)) {
80002a36:	0e 9c       	mov	r12,r7
80002a38:	5c 7c       	castu.h	r12
			udd_allocate_memory(i);
			udd_enable_endpoint(i);
80002a3a:	fe 6e 00 00 	mov	lr,-131072
80002a3e:	30 16       	mov	r6,1
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
80002a40:	30 37       	mov	r7,3
		if (ep_allocated & (1 << i)) {
80002a42:	f8 08 08 49 	asr	r9,r12,r8
80002a46:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80002a4a:	c1 80       	breq	80002a7a <udd_ep_alloc+0x10e>
			udd_allocate_memory(i);
80002a4c:	f0 0b 15 02 	lsl	r11,r8,0x2
80002a50:	fe 65 01 00 	mov	r5,-130816
80002a54:	f6 05 00 09 	add	r9,r11,r5
80002a58:	72 05       	ld.w	r5,r9[0x0]
80002a5a:	a1 b5       	sbr	r5,0x1
80002a5c:	93 05       	st.w	r9[0x0],r5
			udd_enable_endpoint(i);
80002a5e:	7c 75       	ld.w	r5,lr[0x1c]
80002a60:	ec 08 09 4a 	lsl	r10,r6,r8
80002a64:	0a 4a       	or	r10,r5
80002a66:	9d 7a       	st.w	lr[0x1c],r10
			if (!Is_udd_endpoint_configured(i))
80002a68:	e0 3b fe d0 	sub	r11,130768
80002a6c:	76 0a       	ld.w	r10,r11[0x0]
80002a6e:	e6 1a 00 04 	andh	r10,0x4,COH
80002a72:	c0 c0       	breq	80002a8a <udd_ep_alloc+0x11e>
				return false;
			udd_enable_endpoint_bank_autoswitch(i);	
80002a74:	72 0a       	ld.w	r10,r9[0x0]
80002a76:	a9 ba       	sbr	r10,0x9
80002a78:	93 0a       	st.w	r9[0x0],r10
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
80002a7a:	2f f8       	sub	r8,-1
80002a7c:	5c 58       	castu.b	r8
80002a7e:	ee 08 18 00 	cp.b	r8,r7
80002a82:	fe 98 ff e0 	brls	80002a42 <udd_ep_alloc+0xd6>
80002a86:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002a8a:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0

80002a8e <udd_reset_ep_ctrl>:

static void udd_reset_ep_ctrl(void)
{
	irqflags_t flags;
	// Reset USB address to 0
	udd_configure_address(0);
80002a8e:	fe 68 00 00 	mov	r8,-131072
80002a92:	70 09       	ld.w	r9,r8[0x0]
80002a94:	e0 19 ff 80 	andl	r9,0xff80
80002a98:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
80002a9a:	70 09       	ld.w	r9,r8[0x0]
80002a9c:	a7 b9       	sbr	r9,0x7
80002a9e:	91 09       	st.w	r8[0x0],r9
	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
80002aa0:	fe 69 01 00 	mov	r9,-130816
80002aa4:	72 0b       	ld.w	r11,r9[0x0]
80002aa6:	30 8c       	mov	r12,8
80002aa8:	34 0a       	mov	r10,64
80002aaa:	f4 0c 0c 4a 	max	r10,r10,r12
80002aae:	e0 6c 04 00 	mov	r12,1024
80002ab2:	f4 0c 0d 4a 	min	r10,r10,r12
80002ab6:	a1 7a       	lsl	r10,0x1
80002ab8:	20 1a       	sub	r10,1
80002aba:	f4 0a 12 00 	clz	r10,r10
80002abe:	f4 0a 11 1c 	rsub	r10,r10,28
80002ac2:	a5 6a       	lsl	r10,0x4
80002ac4:	e2 1a 19 7c 	andl	r10,0x197c,COH
80002ac8:	e0 1b e6 83 	andl	r11,0xe683
80002acc:	16 4a       	or	r10,r11
80002ace:	93 0a       	st.w	r9[0x0],r10
			USB_EP_TYPE_CONTROL,
			0,
			USB_DEVICE_EP_CTRL_SIZE, AVR32_USBB_UECFG0_EPBK_SINGLE);

	udd_allocate_memory(0);
80002ad0:	72 0a       	ld.w	r10,r9[0x0]
80002ad2:	a1 ba       	sbr	r10,0x1
80002ad4:	93 0a       	st.w	r9[0x0],r10
	udd_enable_endpoint(0);
80002ad6:	70 79       	ld.w	r9,r8[0x1c]
80002ad8:	a1 a9       	sbr	r9,0x0
80002ada:	91 79       	st.w	r8[0x1c],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002adc:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80002ae0:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_setup_received_interrupt(0);
80002ae2:	fe 69 01 f0 	mov	r9,-130576
80002ae6:	30 4b       	mov	r11,4
80002ae8:	93 0b       	st.w	r9[0x0],r11
	udd_enable_out_received_interrupt(0);
80002aea:	30 2b       	mov	r11,2
80002aec:	93 0b       	st.w	r9[0x0],r11
	udd_enable_endpoint_interrupt(0);
80002aee:	e0 69 10 00 	mov	r9,4096
80002af2:	91 69       	st.w	r8[0x18],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002af4:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);
}
80002af8:	5e fc       	retal	r12
80002afa:	d7 03       	nop

80002afc <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
80002afc:	eb cd 40 c0 	pushm	r6-r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002b00:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80002b04:	d3 03       	ssrf	0x10
	irqflags_t flags;
	flags = cpu_irq_save();

	// At startup the USB bus state is unknown, 
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
80002b06:	30 1c       	mov	r12,1
80002b08:	f0 1f 00 15 	mcall	80002b5c <udd_attach+0x60>
	otg_unfreeze_clock();
80002b0c:	fe 67 00 00 	mov	r7,-131072
80002b10:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b14:	af c8       	cbr	r8,0xe
80002b16:	ef 48 08 00 	st.w	r7[2048],r8
#else
	// Check USB clock because the source can be a PLL
	while( !Is_clock_usable() );
#endif
	// Authorize attach if VBus is present
	udd_attach_device();
80002b1a:	6e 08       	ld.w	r8,r7[0x0]
80002b1c:	a9 c8       	cbr	r8,0x8
80002b1e:	8f 08       	st.w	r7[0x0],r8

	// (RESET_AND_WAKEUP)
	// After the attach and the first USB suspend, the following USB Reset time can be inferior to CPU restart clock time.
	// Thus, the USB Reset state is not detected and endpoint control is not allocated
	// In this case, a Reset is do automatically after attach.
	udc_reset();	// Reset USB Device Stack Core
80002b20:	f0 1f 00 10 	mcall	80002b60 <udd_attach+0x64>
	udd_reset_ep_ctrl();	// Reset endpoint control
80002b24:	f0 1f 00 10 	mcall	80002b64 <udd_attach+0x68>
	udd_ctrl_init();	// Reset endpoint control management
80002b28:	f0 1f 00 10 	mcall	80002b68 <udd_attach+0x6c>

	// Enable USB line events
	udd_enable_reset_interrupt();
80002b2c:	30 8b       	mov	r11,8
80002b2e:	8f 6b       	st.w	r7[0x18],r11
	udd_enable_suspend_interrupt();
80002b30:	30 19       	mov	r9,1
80002b32:	8f 69       	st.w	r7[0x18],r9
	udd_enable_wake_up_interrupt();
80002b34:	31 08       	mov	r8,16
80002b36:	8f 68       	st.w	r7[0x18],r8
	udd_enable_sof_interrupt();
80002b38:	30 4a       	mov	r10,4
80002b3a:	8f 6a       	st.w	r7[0x18],r10
#ifdef USB_DEVICE_HS_SUPPORT
	udd_enable_msof_interrupt();
#endif
	// Reset following interupts flag
	udd_ack_reset();
80002b3c:	8f 2b       	st.w	r7[0x8],r11
	udd_ack_sof();
80002b3e:	8f 2a       	st.w	r7[0x8],r10
	udd_ack_msof();
80002b40:	30 2a       	mov	r10,2
80002b42:	8f 2a       	st.w	r7[0x8],r10

	// The first suspend interrupt must be forced
#if UC3A3
	// With UTMI, the first suspend is detected but must be cleared to reoccur interrupt
	udd_ack_suspend();
80002b44:	8f 29       	st.w	r7[0x8],r9
#else
	// The first suspend interrupt is not detected else raise it
	udd_raise_suspend();
#endif
	udd_ack_wake_up();
80002b46:	8f 28       	st.w	r7[0x8],r8
	otg_freeze_clock();
80002b48:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b4c:	af a8       	sbr	r8,0xe
80002b4e:	ef 48 08 00 	st.w	r7[2048],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002b52:	e3 b6 00 00 	mtsr	0x0,r6
	cpu_irq_restore(flags);
}
80002b56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002b5a:	00 00       	add	r0,r0
80002b5c:	80 00       	ld.sh	r0,r0[0x0]
80002b5e:	27 5c       	sub	r12,117
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	3a 30       	mov	r0,-93
80002b64:	80 00       	ld.sh	r0,r0[0x0]
80002b66:	2a 8e       	sub	lr,-88
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	27 d0       	sub	r0,125

80002b6c <udd_enable>:
	return true;
}


void udd_enable(void)
{
80002b6c:	eb cd 40 c0 	pushm	r6-r7,lr
	irqflags_t flags;
	sysclk_enable_usb();
80002b70:	f0 1f 00 39 	mcall	80002c54 <udd_enable+0xe8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002b74:	e1 b6 00 00 	mfsr	r6,0x0
	cpu_irq_disable();
80002b78:	d3 03       	ssrf	0x10

	flags = cpu_irq_save();

	//** Enable USB hardware
	otg_disable();
80002b7a:	fe 67 00 00 	mov	r7,-131072
80002b7e:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b82:	af d8       	cbr	r8,0xf
80002b84:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_enabled();
80002b88:	ee f8 08 00 	ld.w	r8,r7[2048]
	// Check UID pin state before enter in USB device mode
	if (!Is_otg_id_device())
		return false;
#else
	// Here, only the Device mode is possible, then link USBB interrupt to UDD interrupt
	irq_register_handler(udd_interrupt, AVR32_USBB_IRQ, UDD_USB_INT_LEVEL);
80002b8c:	30 0a       	mov	r10,0
80002b8e:	e0 6b 02 20 	mov	r11,544
80002b92:	4b 2c       	lddpc	r12,80002c58 <udd_enable+0xec>
80002b94:	f0 1f 00 32 	mcall	80002c5c <udd_enable+0xf0>
	otg_force_device_mode();
80002b98:	ee f8 08 00 	ld.w	r8,r7[2048]
80002b9c:	b9 b8       	sbr	r8,0x19
80002b9e:	ef 48 08 00 	st.w	r7[2048],r8
80002ba2:	ee f8 08 00 	ld.w	r8,r7[2048]
80002ba6:	b9 c8       	cbr	r8,0x18
80002ba8:	ef 48 08 00 	st.w	r7[2048],r8
#endif
	otg_disable_pad();
80002bac:	ee f8 08 00 	ld.w	r8,r7[2048]
80002bb0:	ad c8       	cbr	r8,0xc
80002bb2:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable_pad();
80002bb6:	ee f8 08 00 	ld.w	r8,r7[2048]
80002bba:	ad a8       	sbr	r8,0xc
80002bbc:	ef 48 08 00 	st.w	r7[2048],r8
	otg_enable();
80002bc0:	ee f8 08 00 	ld.w	r8,r7[2048]
80002bc4:	af b8       	sbr	r8,0xf
80002bc6:	ef 48 08 00 	st.w	r7[2048],r8
	otg_unfreeze_clock();
80002bca:	ee f8 08 00 	ld.w	r8,r7[2048]
80002bce:	af c8       	cbr	r8,0xe
80002bd0:	ef 48 08 00 	st.w	r7[2048],r8
	(void)Is_otg_clock_frozen();
80002bd4:	ee f8 08 00 	ld.w	r8,r7[2048]

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002bd8:	4a 28       	lddpc	r8,80002c60 <udd_enable+0xf4>
80002bda:	70 0a       	ld.w	r10,r8[0x0]
80002bdc:	30 09       	mov	r9,0
		udd_ep_job[i].stall_requested = false;
80002bde:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002be2:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002be6:	91 0a       	st.w	r8[0x0],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002be8:	70 4a       	ld.w	r10,r8[0x10]
		udd_ep_job[i].stall_requested = false;
80002bea:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002bee:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002bf2:	91 4a       	st.w	r8[0x10],r10

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
80002bf4:	70 8a       	ld.w	r10,r8[0x20]
		udd_ep_job[i].stall_requested = false;
80002bf6:	f5 da c0 1f 	bfextu	r10,r10,0x0,0x1f
80002bfa:	f5 d9 d3 81 	bfins	r10,r9,0x1c,0x1
80002bfe:	91 8a       	st.w	r8[0x20],r10

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
80002c00:	6e 08       	ld.w	r8,r7[0x0]
80002c02:	ad c8       	cbr	r8,0xc
80002c04:	8f 08       	st.w	r7[0x0],r8
#  ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
#  else
	udd_high_speed_disable();
80002c06:	6e 08       	ld.w	r8,r7[0x0]
80002c08:	e8 18 0c 00 	orl	r8,0xc00
80002c0c:	8f 08       	st.w	r7[0x0],r8
#  endif
#endif
	udd_enable_vbus_interrupt();
80002c0e:	ee f8 08 00 	ld.w	r8,r7[2048]
80002c12:	a1 b8       	sbr	r8,0x1
80002c14:	ef 48 08 00 	st.w	r7[2048],r8
	otg_freeze_clock();
80002c18:	ee f8 08 00 	ld.w	r8,r7[2048]
80002c1c:	af a8       	sbr	r8,0xe
80002c1e:	ef 48 08 00 	st.w	r7[2048],r8
	// Always authorize asynchrone USB interrupts to exit of sleep mode
	AVR32_PM.AWEN.usb_waken = 1;
80002c22:	fe 78 0c 00 	mov	r8,-62464
80002c26:	f0 fa 01 44 	ld.w	r10,r8[324]
80002c2a:	30 1b       	mov	r11,1
80002c2c:	f5 db d0 01 	bfins	r10,r11,0x0,0x1
80002c30:	f1 4a 01 44 	st.w	r8[324],r10

#ifndef UDD_NO_SLEEP_MGR
	// Initialize the sleep mode authorized for the USB suspend mode
	udd_b_idle = false;
80002c34:	48 c8       	lddpc	r8,80002c64 <udd_enable+0xf8>
80002c36:	b0 89       	st.b	r8[0x0],r9

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002c38:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002c3c:	d3 03       	ssrf	0x10
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
80002c3e:	48 b8       	lddpc	r8,80002c68 <udd_enable+0xfc>
80002c40:	11 ba       	ld.ub	r10,r8[0x3]
80002c42:	2f fa       	sub	r10,-1
80002c44:	b0 ba       	st.b	r8[0x3],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002c46:	e3 b9 00 00 	mtsr	0x0,r9
80002c4a:	e3 b6 00 00 	mtsr	0x0,r6
	sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_SUSPEND);
#endif

	cpu_irq_restore(flags);
}
80002c4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c52:	00 00       	add	r0,r0
80002c54:	80 00       	ld.sh	r0,r0[0x0]
80002c56:	33 14       	mov	r4,49
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	2c 6c       	sub	r12,-58
80002c5c:	80 00       	ld.sh	r0,r0[0x0]
80002c5e:	22 8c       	sub	r12,40
80002c60:	00 00       	add	r0,r0
80002c62:	07 28       	ld.uh	r8,r3++
80002c64:	00 00       	add	r0,r0
80002c66:	07 58       	ld.sh	r8,--r3
80002c68:	00 00       	add	r0,r0
80002c6a:	0a 28       	rsub	r8,r5

80002c6c <udd_interrupt>:
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
#endif
{
80002c6c:	eb cd 40 fc 	pushm	r2-r7,lr
	if (Is_udd_sof()) {
80002c70:	fe 68 00 00 	mov	r8,-131072
80002c74:	70 18       	ld.w	r8,r8[0x4]
80002c76:	e2 18 00 04 	andl	r8,0x4,COH
80002c7a:	c0 f0       	breq	80002c98 <udd_interrupt+0x2c>
		udd_ack_sof();
80002c7c:	fe 68 00 00 	mov	r8,-131072
80002c80:	30 49       	mov	r9,4
80002c82:	91 29       	st.w	r8[0x8],r9
		if (Is_udd_full_speed_mode()) {
80002c84:	f0 f8 08 04 	ld.w	r8,r8[2052]
80002c88:	f1 d8 c1 82 	bfextu	r8,r8,0xc,0x2
80002c8c:	e0 81 02 ce 	brne	80003228 <udd_interrupt+0x5bc>
		udc_sof_notify();
80002c90:	f0 1f 01 6f 	mcall	8000324c <udd_interrupt+0x5e0>
80002c94:	e0 8f 02 ca 	bral	80003228 <udd_interrupt+0x5bc>
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_end;
	}
	if (Is_udd_msof()) {
80002c98:	fe 68 00 00 	mov	r8,-131072
80002c9c:	70 18       	ld.w	r8,r8[0x4]
80002c9e:	e2 18 00 02 	andl	r8,0x2,COH
80002ca2:	c0 90       	breq	80002cb4 <udd_interrupt+0x48>
		udd_ack_msof();
80002ca4:	30 29       	mov	r9,2
80002ca6:	fe 68 00 00 	mov	r8,-131072
80002caa:	91 29       	st.w	r8[0x8],r9
		udc_sof_notify();
80002cac:	f0 1f 01 68 	mcall	8000324c <udd_interrupt+0x5e0>
		goto udd_interrupt_end;
80002cb0:	e0 8f 02 bc 	bral	80003228 <udd_interrupt+0x5bc>


static bool udd_ctrl_interrupt(void)
{

	if (!Is_udd_endpoint_interrupt(0))
80002cb4:	fe 68 00 00 	mov	r8,-131072
80002cb8:	70 18       	ld.w	r8,r8[0x4]
80002cba:	e2 18 10 00 	andl	r8,0x1000,COH
80002cbe:	e0 80 01 6f 	breq	80002f9c <udd_interrupt+0x330>
		return false;	// No interrupt events on control endpoint

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
80002cc2:	fe 68 02 20 	mov	r8,-130528
80002cc6:	31 09       	mov	r9,16
80002cc8:	91 09       	st.w	r8[0x0],r9
	udd_disable_nak_out_interrupt(0);
80002cca:	30 89       	mov	r9,8
80002ccc:	91 09       	st.w	r8[0x0],r9


	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
80002cce:	fe 68 01 30 	mov	r8,-130768
80002cd2:	70 08       	ld.w	r8,r8[0x0]
80002cd4:	e2 18 00 04 	andl	r8,0x4,COH
80002cd8:	e0 80 00 87 	breq	80002de6 <udd_interrupt+0x17a>
static void udd_ctrl_setup_received(void)
{
	irqflags_t flags;
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
80002cdc:	fe f8 05 74 	ld.w	r8,pc[1396]
80002ce0:	70 08       	ld.w	r8,r8[0x0]
80002ce2:	58 08       	cp.w	r8,0
80002ce4:	c0 50       	breq	80002cee <udd_interrupt+0x82>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
80002ce6:	f0 1f 01 5c 	mcall	80003254 <udd_interrupt+0x5e8>
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002cea:	f0 1f 01 5c 	mcall	80003258 <udd_interrupt+0x5ec>
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
80002cee:	fe 68 01 30 	mov	r8,-130768
80002cf2:	70 08       	ld.w	r8,r8[0x0]
80002cf4:	f1 d8 c2 8b 	bfextu	r8,r8,0x14,0xb
80002cf8:	58 88       	cp.w	r8,8
80002cfa:	c0 90       	breq	80002d0c <udd_interrupt+0xa0>
		udd_ctrl_stall_data();
80002cfc:	f0 1f 01 58 	mcall	8000325c <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002d00:	30 49       	mov	r9,4
80002d02:	fe 68 01 60 	mov	r8,-130720
80002d06:	91 09       	st.w	r8[0x0],r9
80002d08:	e0 8f 02 90 	bral	80003228 <udd_interrupt+0x5bc>
80002d0c:	fc 18 e0 00 	movh	r8,0xe000
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
80002d10:	fe fc 05 50 	ld.w	r12,pc[1360]
80002d14:	fc 1b 20 00 	movh	r11,0x2000
80002d18:	f0 0c 00 09 	add	r9,r8,r12
80002d1c:	11 3a       	ld.ub	r10,r8++
80002d1e:	f2 0b 0b 0a 	st.b	r9[r11],r10
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return;	// Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
80002d22:	30 8a       	mov	r10,8
80002d24:	ea 1a e0 00 	orh	r10,0xe000
80002d28:	14 38       	cp.w	r8,r10
80002d2a:	cf 71       	brne	80002d18 <udd_interrupt+0xac>
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
	}
	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
80002d2c:	fe f8 05 34 	ld.w	r8,pc[1332]
80002d30:	90 19       	ld.sh	r9,r8[0x2]
80002d32:	5c c9       	swap.bh	r9
80002d34:	b0 19       	st.h	r8[0x2],r9
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
80002d36:	90 29       	ld.sh	r9,r8[0x4]
80002d38:	5c c9       	swap.bh	r9
80002d3a:	b0 29       	st.h	r8[0x4],r9
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
80002d3c:	90 39       	ld.sh	r9,r8[0x6]
80002d3e:	5c c9       	swap.bh	r9
80002d40:	b0 39       	st.h	r8[0x6],r9

	// Decode setup request
	if (udc_process_setup() == false) {
80002d42:	f0 1f 01 49 	mcall	80003264 <udd_interrupt+0x5f8>
80002d46:	c0 91       	brne	80002d58 <udd_interrupt+0xec>
		// Setup request unknow then stall it
		udd_ctrl_stall_data();
80002d48:	f0 1f 01 45 	mcall	8000325c <udd_interrupt+0x5f0>
		udd_ack_setup_received(0);
80002d4c:	30 49       	mov	r9,4
80002d4e:	fe 68 01 60 	mov	r8,-130720
80002d52:	91 09       	st.w	r8[0x0],r9
80002d54:	e0 8f 02 6a 	bral	80003228 <udd_interrupt+0x5bc>
		return;
	}
	udd_ack_setup_received(0);
80002d58:	30 49       	mov	r9,4
80002d5a:	fe 68 01 60 	mov	r8,-130720
80002d5e:	91 09       	st.w	r8[0x0],r9

	if (Udd_setup_is_in()) {
80002d60:	fe f8 05 00 	ld.w	r8,pc[1280]
80002d64:	11 89       	ld.ub	r9,r8[0x0]
80002d66:	30 08       	mov	r8,0
80002d68:	f0 09 18 00 	cp.b	r9,r8
80002d6c:	c1 94       	brge	80002d9e <udd_interrupt+0x132>
		// Compute if an IN ZLP must be send after IN data
		udd_ctrl_payload_need_in_zlp =
80002d6e:	fe f8 04 f2 	ld.w	r8,pc[1266]
80002d72:	90 e8       	ld.uh	r8,r8[0xc]
80002d74:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80002d78:	5f 09       	sreq	r9
80002d7a:	fe f8 04 ee 	ld.w	r8,pc[1262]
80002d7e:	b0 89       	st.b	r8[0x0],r9
				((udd_g_ctrlreq.payload_size %
						USB_DEVICE_EP_CTRL_SIZE) == 0);
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002d80:	30 08       	mov	r8,0
80002d82:	fe f9 04 ea 	ld.w	r9,pc[1258]
80002d86:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002d88:	fe f9 04 e8 	ld.w	r9,pc[1256]
80002d8c:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
80002d8e:	30 29       	mov	r9,2
80002d90:	fe f8 04 c0 	ld.w	r8,pc[1216]
80002d94:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_in_sent();	// Send first data transfer
80002d96:	f0 1f 01 38 	mcall	80003274 <udd_interrupt+0x608>
80002d9a:	e0 8f 02 47 	bral	80003228 <udd_interrupt+0x5bc>
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
80002d9e:	fe f8 04 c2 	ld.w	r8,pc[1218]
80002da2:	90 39       	ld.sh	r9,r8[0x6]
80002da4:	30 08       	mov	r8,0
80002da6:	f0 09 19 00 	cp.h	r9,r8
80002daa:	c0 51       	brne	80002db4 <udd_interrupt+0x148>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
80002dac:	f0 1f 01 33 	mcall	80003278 <udd_interrupt+0x60c>
80002db0:	e0 8f 02 3c 	bral	80003228 <udd_interrupt+0x5bc>
			return;
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80002db4:	30 08       	mov	r8,0
80002db6:	fe f9 04 b6 	ld.w	r9,pc[1206]
80002dba:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80002dbc:	fe f9 04 b4 	ld.w	r9,pc[1204]
80002dc0:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
80002dc2:	30 19       	mov	r9,1
80002dc4:	fe f8 04 8c 	ld.w	r8,pc[1164]
80002dc8:	91 09       	st.w	r8[0x0],r9
		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
80002dca:	31 08       	mov	r8,16
80002dcc:	fe 69 01 60 	mov	r9,-130720
80002dd0:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002dd2:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002dd6:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();
		udd_enable_nak_in_interrupt(0);
80002dd8:	fe 6a 01 f0 	mov	r10,-130576
80002ddc:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002dde:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002de2:	e0 8f 02 23 	bral	80003228 <udd_interrupt+0x5bc>
	if (Is_udd_setup_received(0)) {
		// SETUP packet received
		udd_ctrl_setup_received();
		return true;
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
80002de6:	fe 68 01 30 	mov	r8,-130768
80002dea:	70 08       	ld.w	r8,r8[0x0]
80002dec:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002df0:	c0 b0       	breq	80002e06 <udd_interrupt+0x19a>
80002df2:	fe 68 01 c0 	mov	r8,-130624
80002df6:	70 08       	ld.w	r8,r8[0x0]
80002df8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002dfc:	c0 50       	breq	80002e06 <udd_interrupt+0x19a>
		// IN packet sent
		udd_ctrl_in_sent();
80002dfe:	f0 1f 01 1e 	mcall	80003274 <udd_interrupt+0x608>
80002e02:	e0 8f 02 13 	bral	80003228 <udd_interrupt+0x5bc>
		return true;
	}
	if (Is_udd_out_received(0)) {
80002e06:	fe 68 01 30 	mov	r8,-130768
80002e0a:	70 08       	ld.w	r8,r8[0x0]
80002e0c:	e2 18 00 02 	andl	r8,0x2,COH
80002e10:	e0 80 00 a3 	breq	80002f56 <udd_interrupt+0x2ea>
{
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
80002e14:	fe f8 04 3c 	ld.w	r8,pc[1084]
80002e18:	70 08       	ld.w	r8,r8[0x0]
80002e1a:	58 18       	cp.w	r8,1
80002e1c:	c1 10       	breq	80002e3e <udd_interrupt+0x1d2>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
80002e1e:	58 28       	cp.w	r8,2
80002e20:	5f 09       	sreq	r9
80002e22:	58 48       	cp.w	r8,4
80002e24:	5f 08       	sreq	r8
80002e26:	f3 e8 10 08 	or	r8,r9,r8
80002e2a:	c0 40       	breq	80002e32 <udd_interrupt+0x1c6>
						udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quiclky,
			// - or ZLP OUT received normaly.
			udd_ctrl_endofrequest();
80002e2c:	f0 1f 01 0a 	mcall	80003254 <udd_interrupt+0x5e8>
80002e30:	c0 38       	rjmp	80002e36 <udd_interrupt+0x1ca>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
80002e32:	f0 1f 01 0b 	mcall	8000325c <udd_interrupt+0x5f0>
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
80002e36:	f0 1f 01 09 	mcall	80003258 <udd_interrupt+0x5ec>
80002e3a:	e0 8f 01 f7 	bral	80003228 <udd_interrupt+0x5bc>
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
80002e3e:	fe 68 01 30 	mov	r8,-130768
80002e42:	70 0b       	ld.w	r11,r8[0x0]
80002e44:	f7 db c2 8b 	bfextu	r11,r11,0x14,0xb
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
80002e48:	fe f8 04 18 	ld.w	r8,pc[1048]
80002e4c:	90 69       	ld.sh	r9,r8[0xc]
80002e4e:	fe f8 04 22 	ld.w	r8,pc[1058]
80002e52:	90 08       	ld.sh	r8,r8[0x0]
80002e54:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
80002e58:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80002e5c:	f6 0a 00 0a 	add	r10,r11,r10
80002e60:	14 3c       	cp.w	r12,r10
80002e62:	c0 44       	brge	80002e6a <udd_interrupt+0x1fe>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
80002e64:	10 19       	sub	r9,r8
80002e66:	f7 d9 b0 10 	bfexts	r11,r9,0x0,0x10
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002e6a:	fe f9 03 f6 	ld.w	r9,pc[1014]
80002e6e:	72 29       	ld.w	r9,r9[0x8]
	for (i = 0; i < nb_data; i++) {
80002e70:	58 0b       	cp.w	r11,0
80002e72:	e0 80 01 e2 	breq	80003236 <udd_interrupt+0x5ca>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
80002e76:	5c 78       	castu.h	r8
80002e78:	10 09       	add	r9,r8
80002e7a:	fc 18 e0 00 	movh	r8,0xe000
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
80002e7e:	11 3a       	ld.ub	r10,r8++
80002e80:	12 ca       	st.b	r9++,r10
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
80002e82:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80002e86:	f6 0a 19 00 	cp.h	r10,r11
80002e8a:	cf a3       	brcs	80002e7e <udd_interrupt+0x212>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
80002e8c:	fe f9 03 e4 	ld.w	r9,pc[996]
80002e90:	92 08       	ld.sh	r8,r9[0x0]
80002e92:	16 08       	add	r8,r11
80002e94:	5c 88       	casts.h	r8
80002e96:	b2 08       	st.h	r9[0x0],r8

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
80002e98:	34 09       	mov	r9,64
80002e9a:	f2 0b 19 00 	cp.h	r11,r9
80002e9e:	c0 e1       	brne	80002eba <udd_interrupt+0x24e>
80002ea0:	fe f9 03 c0 	ld.w	r9,pc[960]
80002ea4:	92 ba       	ld.uh	r10,r9[0x6]
80002ea6:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80002eaa:	fe f9 03 c2 	ld.w	r9,pc[962]
80002eae:	92 89       	ld.uh	r9,r9[0x0]
80002eb0:	f6 09 00 09 	add	r9,r11,r9
80002eb4:	12 3a       	cp.w	r10,r9
80002eb6:	e0 89 00 1a 	brgt	80002eea <udd_interrupt+0x27e>
							udd_ctrl_payload_nb_trans)))
	{
		// End of reception because it is a short packet
		// Before send ZLP, call intermediat calback 
		// in case of data receiv generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
80002eba:	fe f9 03 a6 	ld.w	r9,pc[934]
80002ebe:	b2 68       	st.h	r9[0xc],r8
		if (NULL != udd_g_ctrlreq.over_under_run) {
80002ec0:	72 5c       	ld.w	r12,r9[0x14]
80002ec2:	58 0c       	cp.w	r12,0
80002ec4:	c0 b0       	breq	80002eda <udd_interrupt+0x26e>
			if (!udd_g_ctrlreq.over_under_run()) {
80002ec6:	5d 1c       	icall	r12
80002ec8:	c0 91       	brne	80002eda <udd_interrupt+0x26e>
				// Stall ZLP
				udd_ctrl_stall_data();
80002eca:	f0 1f 00 e5 	mcall	8000325c <udd_interrupt+0x5f0>
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
80002ece:	30 29       	mov	r9,2
80002ed0:	fe 68 01 60 	mov	r8,-130720
80002ed4:	91 09       	st.w	r8[0x0],r9
80002ed6:	e0 8f 01 a9 	bral	80003228 <udd_interrupt+0x5bc>
				return;
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
80002eda:	30 29       	mov	r9,2
80002edc:	fe 68 01 60 	mov	r8,-130720
80002ee0:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_send_zlp_in();
80002ee2:	f0 1f 00 e6 	mcall	80003278 <udd_interrupt+0x60c>
80002ee6:	e0 8f 01 a1 	bral	80003228 <udd_interrupt+0x5bc>
		return;
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
80002eea:	fe f9 03 76 	ld.w	r9,pc[886]
80002eee:	92 69       	ld.sh	r9,r9[0xc]
80002ef0:	f0 09 19 00 	cp.h	r9,r8
80002ef4:	c2 21       	brne	80002f38 <udd_interrupt+0x2cc>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
80002ef6:	fe f8 03 6a 	ld.w	r8,pc[874]
80002efa:	70 5c       	ld.w	r12,r8[0x14]
80002efc:	58 0c       	cp.w	r12,0
80002efe:	c0 91       	brne	80002f10 <udd_interrupt+0x2a4>
			// No callback availabled to request a new payload buffer
			udd_ctrl_stall_data();
80002f00:	f0 1f 00 d7 	mcall	8000325c <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002f04:	30 29       	mov	r9,2
80002f06:	fe 68 01 60 	mov	r8,-130720
80002f0a:	91 09       	st.w	r8[0x0],r9
80002f0c:	e0 8f 01 8e 	bral	80003228 <udd_interrupt+0x5bc>
			return;
		}
		if (!udd_g_ctrlreq.over_under_run()) {
80002f10:	5d 1c       	icall	r12
80002f12:	c0 81       	brne	80002f22 <udd_interrupt+0x2b6>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
80002f14:	f0 1f 00 d2 	mcall	8000325c <udd_interrupt+0x5f0>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80002f18:	30 29       	mov	r9,2
80002f1a:	fe 68 01 60 	mov	r8,-130720
80002f1e:	91 09       	st.w	r8[0x0],r9
80002f20:	c8 49       	rjmp	80003228 <udd_interrupt+0x5bc>
			return;
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
80002f22:	fe f9 03 4a 	ld.w	r9,pc[842]
80002f26:	fe f8 03 4a 	ld.w	r8,pc[842]
80002f2a:	90 0b       	ld.sh	r11,r8[0x0]
80002f2c:	92 0a       	ld.sh	r10,r9[0x0]
80002f2e:	f6 0a 00 0a 	add	r10,r11,r10
80002f32:	b2 0a       	st.h	r9[0x0],r10
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
80002f34:	30 09       	mov	r9,0
80002f36:	b0 09       	st.h	r8[0x0],r9
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
80002f38:	fe 69 01 60 	mov	r9,-130720
80002f3c:	30 28       	mov	r8,2
80002f3e:	93 08       	st.w	r9[0x0],r8
	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
80002f40:	31 08       	mov	r8,16
80002f42:	93 08       	st.w	r9[0x0],r8

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002f44:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80002f48:	d3 03       	ssrf	0x10
	flags = cpu_irq_save();
	udd_enable_nak_in_interrupt(0);
80002f4a:	fe 6a 01 f0 	mov	r10,-130576
80002f4e:	95 08       	st.w	r10[0x0],r8
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80002f50:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
80002f54:	c6 a9       	rjmp	80003228 <udd_interrupt+0x5bc>
	if (Is_udd_out_received(0)) {
		// OUT packet received
		udd_ctrl_out_received();
		return true;
	}
	if (Is_udd_nak_out(0)) {
80002f56:	fe 68 01 30 	mov	r8,-130768
80002f5a:	70 08       	ld.w	r8,r8[0x0]
80002f5c:	e2 18 00 08 	andl	r8,0x8,COH
80002f60:	c1 80       	breq	80002f90 <udd_interrupt+0x324>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
80002f62:	30 89       	mov	r9,8
80002f64:	fe 68 01 60 	mov	r8,-130720
80002f68:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0))
80002f6a:	fe 68 01 30 	mov	r8,-130768
80002f6e:	70 08       	ld.w	r8,r8[0x0]
80002f70:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002f74:	e0 81 01 5a 	brne	80003228 <udd_interrupt+0x5bc>
		return;	// overflow ignored if IN data is received

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
80002f78:	fe f8 02 d8 	ld.w	r8,pc[728]
80002f7c:	70 08       	ld.w	r8,r8[0x0]
80002f7e:	58 38       	cp.w	r8,3
80002f80:	e0 81 01 54 	brne	80003228 <udd_interrupt+0x5bc>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
80002f84:	e8 69 00 00 	mov	r9,524288
80002f88:	fe 68 01 f0 	mov	r8,-130576
80002f8c:	91 09       	st.w	r8[0x0],r9
80002f8e:	c4 d9       	rjmp	80003228 <udd_interrupt+0x5bc>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
80002f90:	fe 68 01 30 	mov	r8,-130768
80002f94:	70 08       	ld.w	r8,r8[0x0]
80002f96:	e2 18 00 10 	andl	r8,0x10,COH
80002f9a:	c0 e1       	brne	80002fb6 <udd_interrupt+0x34a>
80002f9c:	fe f7 02 e0 	ld.w	r7,pc[736]
80002fa0:	0e 9a       	mov	r10,r7
80002fa2:	fe 69 01 34 	mov	r9,-130764
80002fa6:	30 0b       	mov	r11,0
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002fa8:	fe 66 00 00 	mov	r6,-131072
80002fac:	fc 14 02 00 	movh	r4,0x200
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80002fb0:	e0 63 10 00 	mov	r3,4096
80002fb4:	c1 e8       	rjmp	80002ff0 <udd_interrupt+0x384>
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
		// Underflow on IN packet
		udd_ack_nak_in(0);
80002fb6:	31 09       	mov	r9,16
80002fb8:	fe 68 01 60 	mov	r8,-130720
80002fbc:	91 09       	st.w	r8[0x0],r9
}


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
80002fbe:	fe 68 01 30 	mov	r8,-130768
80002fc2:	70 08       	ld.w	r8,r8[0x0]
80002fc4:	e2 18 00 02 	andl	r8,0x2,COH
80002fc8:	e0 81 01 30 	brne	80003228 <udd_interrupt+0x5bc>
		return;	// underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
80002fcc:	fe f8 02 84 	ld.w	r8,pc[644]
80002fd0:	70 08       	ld.w	r8,r8[0x0]
80002fd2:	58 18       	cp.w	r8,1
80002fd4:	c0 41       	brne	80002fdc <udd_interrupt+0x370>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
80002fd6:	f0 1f 00 a9 	mcall	80003278 <udd_interrupt+0x60c>
80002fda:	c2 79       	rjmp	80003228 <udd_interrupt+0x5bc>
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
80002fdc:	58 48       	cp.w	r8,4
80002fde:	e0 81 01 25 	brne	80003228 <udd_interrupt+0x5bc>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
80002fe2:	e8 69 00 00 	mov	r9,524288
80002fe6:	fe 68 01 f0 	mov	r8,-130576
80002fea:	91 09       	st.w	r8[0x0],r9
80002fec:	c1 e9       	rjmp	80003228 <udd_interrupt+0x5bc>
80002fee:	10 9b       	mov	r11,r8
80002ff0:	f6 c8 ff ff 	sub	r8,r11,-1
80002ff4:	14 9c       	mov	r12,r10
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80002ff6:	6c 45       	ld.w	r5,r6[0x10]
80002ff8:	10 9e       	mov	lr,r8
80002ffa:	e8 0b 09 4b 	lsl	r11,r4,r11
80002ffe:	f7 e5 00 05 	and	r5,r11,r5
80003002:	c4 b0       	breq	80003098 <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
80003004:	6c 15       	ld.w	r5,r6[0x4]
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
		
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80003006:	f7 e5 00 05 	and	r5,r11,r5
8000300a:	c4 70       	breq	80003098 <udd_interrupt+0x42c>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
			uint32_t nb_remaining;
			udd_disable_endpoint_dma_interrupt(ep);
8000300c:	fe 69 00 00 	mov	r9,-131072
80003010:	93 5b       	st.w	r9[0x14],r11
			if (ptr_job->b_raise_dma) {
80003012:	74 09       	ld.w	r9,r10[0x0]
80003014:	e6 19 20 00 	andh	r9,0x2000,COH
80003018:	c0 50       	breq	80003022 <udd_interrupt+0x3b6>
				// In case of manual raise DMA interrupt
				// to process a ZLP packet
				udd_raise_endpoint_dma_interrupt(ep);
8000301a:	fe 69 00 00 	mov	r9,-131072
8000301e:	93 3b       	st.w	r9[0xc],r11
80003020:	c0 a8       	rjmp	80003034 <udd_interrupt+0x3c8>
			}else{
				// Save number of data no transfered
				nb_remaining = (udd_endpoint_dma_get_status(ep) &
80003022:	f0 09 15 04 	lsl	r9,r8,0x4
80003026:	e0 39 fd 00 	sub	r9,130304
8000302a:	72 39       	ld.w	r9,r9[0xc]
						AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_MASK)
						>> AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_OFFSET;
				// Update number of data transfered
				ptr_job->buf_size -= nb_remaining;
8000302c:	b1 89       	lsr	r9,0x10
8000302e:	74 2a       	ld.w	r10,r10[0x8]
80003030:	12 1a       	sub	r10,r9
80003032:	99 2a       	st.w	r12[0x8],r10
			}

			if (Is_udd_endpoint_in(ep)) {
80003034:	a3 68       	lsl	r8,0x2
80003036:	fe 6b 01 00 	mov	r11,-130816
8000303a:	f0 0b 00 09 	add	r9,r8,r11
8000303e:	72 09       	ld.w	r9,r9[0x0]
80003040:	e2 19 01 00 	andl	r9,0x100,COH
80003044:	c2 60       	breq	80003090 <udd_interrupt+0x424>
				// Transfer complet on IN
				if (ptr_job->b_send_zlp) {
80003046:	78 09       	ld.w	r9,r12[0x0]
80003048:	e6 19 40 00 	andh	r9,0x4000,COH
8000304c:	c2 20       	breq	80003090 <udd_interrupt+0x424>
					// Need to send a ZLP after data transfer
					// enable interrupt to wait a free bank to sent ZLP
					udd_ack_in_send(ep);
8000304e:	fe 6a 01 60 	mov	r10,-130720
80003052:	f0 0a 00 09 	add	r9,r8,r10
80003056:	30 1a       	mov	r10,1
80003058:	93 0a       	st.w	r9[0x0],r10
					if (Is_udd_write_enabled(ep)) {
8000305a:	fe 6b 01 30 	mov	r11,-130768
8000305e:	f0 0b 00 09 	add	r9,r8,r11
80003062:	72 0a       	ld.w	r10,r9[0x0]
						udd_raise_in_send(ep);
80003064:	fe 6b 01 90 	mov	r11,-130672
80003068:	f0 0b 00 09 	add	r9,r8,r11
				// Transfer complet on IN
				if (ptr_job->b_send_zlp) {
					// Need to send a ZLP after data transfer
					// enable interrupt to wait a free bank to sent ZLP
					udd_ack_in_send(ep);
					if (Is_udd_write_enabled(ep)) {
8000306c:	e6 1a 00 01 	andh	r10,0x1,COH
						udd_raise_in_send(ep);
80003070:	f9 ba 01 01 	movne	r10,1
80003074:	f3 fa 1a 00 	st.wne	r9[0x0],r10
					}
					udd_enable_in_send_interrupt(ep);
80003078:	e0 38 fe 10 	sub	r8,130576
8000307c:	30 19       	mov	r9,1
8000307e:	91 09       	st.w	r8[0x0],r9
					udd_enable_endpoint_interrupt(ep);
80003080:	e0 68 10 00 	mov	r8,4096
80003084:	f0 0e 09 4e 	lsl	lr,r8,lr
80003088:	fe 68 00 00 	mov	r8,-131072
8000308c:	91 6e       	st.w	r8[0x18],lr
8000308e:	cc d8       	rjmp	80003228 <udd_interrupt+0x5bc>
					return true;
				}
			}
			// Call callback to signal end of transfer
			udd_ep_finish_job(ptr_job, false);
80003090:	30 0b       	mov	r11,0
80003092:	f0 1f 00 7c 	mcall	80003280 <udd_interrupt+0x614>
80003096:	cc 98       	rjmp	80003228 <udd_interrupt+0x5bc>
			return true;
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80003098:	6c 4b       	ld.w	r11,r6[0x10]
8000309a:	e6 0e 09 4e 	lsl	lr,r3,lr
8000309e:	fd eb 00 0b 	and	r11,lr,r11
800030a2:	c4 60       	breq	8000312e <udd_interrupt+0x4c2>
800030a4:	e0 7b fe d0 	mov	r11,130768
800030a8:	f2 0b 00 02 	add	r2,r9,r11
800030ac:	f2 cb ff 70 	sub	r11,r9,-144
			if (Is_udd_in_send_interrupt_enabled(ep) && Is_udd_in_send(ep)) {
800030b0:	76 05       	ld.w	r5,r11[0x0]
800030b2:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
800030b6:	c1 50       	breq	800030e0 <udd_interrupt+0x474>
800030b8:	72 05       	ld.w	r5,r9[0x0]
800030ba:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
800030be:	c1 10       	breq	800030e0 <udd_interrupt+0x474>
				udd_disable_in_send_interrupt(ep);
800030c0:	fe 6a 02 20 	mov	r10,-130528
800030c4:	e4 0a 00 08 	add	r8,r2,r10
800030c8:	30 19       	mov	r9,1
800030ca:	91 09       	st.w	r8[0x0],r9
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
800030cc:	e0 32 fe a0 	sub	r2,130720
800030d0:	85 09       	st.w	r2[0x0],r9
				udd_ack_fifocon(ep);
800030d2:	e0 69 40 00 	mov	r9,16384
800030d6:	91 09       	st.w	r8[0x0],r9
				udd_ep_finish_job(ptr_job, false);
800030d8:	30 0b       	mov	r11,0
800030da:	f0 1f 00 6a 	mcall	80003280 <udd_interrupt+0x614>
800030de:	ca 58       	rjmp	80003228 <udd_interrupt+0x5bc>
				return true;
			}
			if (Is_udd_bank_interrupt_enabled(ep) && (0==udd_nb_busy_bank(ep))) {
800030e0:	76 0b       	ld.w	r11,r11[0x0]
800030e2:	e2 1b 10 00 	andl	r11,0x1000,COH
800030e6:	c2 40       	breq	8000312e <udd_interrupt+0x4c2>
800030e8:	72 0b       	ld.w	r11,r9[0x0]
800030ea:	f7 db c1 82 	bfextu	r11,r11,0xc,0x2
800030ee:	c2 01       	brne	8000312e <udd_interrupt+0x4c2>
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
800030f0:	fe 69 02 20 	mov	r9,-130528
800030f4:	e4 09 00 08 	add	r8,r2,r9
800030f8:	e0 69 10 00 	mov	r9,4096
800030fc:	91 09       	st.w	r8[0x0],r9
				udd_disable_endpoint_interrupt(ep);
800030fe:	fe 68 00 00 	mov	r8,-131072
80003102:	91 5e       	st.w	r8[0x14],lr

				Assert(ptr_job->stall_requested);
				// A stall has been requested during backgound transfer
				ptr_job->stall_requested = false;
80003104:	78 08       	ld.w	r8,r12[0x0]
80003106:	30 09       	mov	r9,0
80003108:	f1 d9 d3 81 	bfins	r8,r9,0x1c,0x1
8000310c:	99 08       	st.w	r12[0x0],r8
				udd_disable_endpoint_bank_autoswitch(ep);
8000310e:	fe 6b 01 00 	mov	r11,-130816
80003112:	e4 0b 00 08 	add	r8,r2,r11
80003116:	70 09       	ld.w	r9,r8[0x0]
80003118:	a9 d9       	cbr	r9,0x9
8000311a:	91 09       	st.w	r8[0x0],r9
				udd_enable_stall_handshake(ep);
8000311c:	e0 32 fe 10 	sub	r2,130576
80003120:	e8 68 00 00 	mov	r8,524288
80003124:	85 08       	st.w	r2[0x0],r8
				udd_reset_data_toggle(ep);
80003126:	e4 68 00 00 	mov	r8,262144
8000312a:	85 08       	st.w	r2[0x0],r8
8000312c:	c7 e8       	rjmp	80003228 <udd_interrupt+0x5bc>
8000312e:	2f 0a       	sub	r10,-16
80003130:	2f c9       	sub	r9,-4
{
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
80003132:	58 38       	cp.w	r8,3
80003134:	fe 91 ff 5d 	brne	80002fee <udd_interrupt+0x382>
80003138:	c8 38       	rjmp	8000323e <udd_interrupt+0x5d2>
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
		udd_ack_reset();
8000313a:	30 89       	mov	r9,8
8000313c:	fe 68 00 00 	mov	r8,-131072
80003140:	91 29       	st.w	r8[0x8],r9
#if __ICCAVR32__
#if !defined(AVR32_USBB_IRQ_GROUP)
#define AVR32_USBB_IRQ_GROUP AVR32_USB_IRQ_GROUP
#endif
#endif
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
80003142:	ee c6 ff d0 	sub	r6,r7,-48
static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_finish_job(&udd_ep_job[i], true);
80003146:	30 15       	mov	r5,1
80003148:	0a 9b       	mov	r11,r5
8000314a:	0e 9c       	mov	r12,r7
8000314c:	f0 1f 00 4d 	mcall	80003280 <udd_interrupt+0x614>
80003150:	2f 07       	sub	r7,-16

static void udd_ep_job_table_kill(void)
{
	uint8_t i;
	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
80003152:	0c 37       	cp.w	r7,r6
80003154:	cf a1       	brne	80003148 <udd_interrupt+0x4dc>
		// Abort all jobs on-going
#if (0!=USB_DEVICE_MAX_EP)
		udd_ep_job_table_kill();
#endif
		// Reset USB Device Stack Core
		udc_reset();
80003156:	f0 1f 00 4c 	mcall	80003284 <udd_interrupt+0x618>
		// Reset endpoint control
		udd_reset_ep_ctrl();
8000315a:	f0 1f 00 4c 	mcall	80003288 <udd_interrupt+0x61c>
		// Reset endpoint control management
		udd_ctrl_init();
8000315e:	f0 1f 00 3f 	mcall	80003258 <udd_interrupt+0x5ec>
		goto udd_interrupt_end;
80003162:	c6 38       	rjmp	80003228 <udd_interrupt+0x5bc>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
80003164:	fe 68 00 00 	mov	r8,-131072
80003168:	70 48       	ld.w	r8,r8[0x10]
8000316a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000316e:	c1 b0       	breq	800031a4 <udd_interrupt+0x538>
80003170:	fe 68 00 00 	mov	r8,-131072
80003174:	70 18       	ld.w	r8,r8[0x4]
80003176:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000317a:	c1 50       	breq	800031a4 <udd_interrupt+0x538>
		otg_unfreeze_clock();
8000317c:	fe 68 00 00 	mov	r8,-131072
80003180:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003184:	af c9       	cbr	r9,0xe
80003186:	f1 49 08 00 	st.w	r8[2048],r9
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
8000318a:	30 19       	mov	r9,1
8000318c:	91 59       	st.w	r8[0x14],r9
		udd_enable_wake_up_interrupt();
8000318e:	31 09       	mov	r9,16
80003190:	91 69       	st.w	r8[0x18],r9
		otg_freeze_clock();	// Mandatory to exit of sleep mode after a wakeup event
80003192:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003196:	af a9       	sbr	r9,0xe
80003198:	f1 49 08 00 	st.w	r8[2048],r9
		udd_sleep_mode(false);	// Enter in SUSPEND mode
8000319c:	30 0c       	mov	r12,0
8000319e:	f0 1f 00 3c 	mcall	8000328c <udd_interrupt+0x620>
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_end;
800031a2:	c4 38       	rjmp	80003228 <udd_interrupt+0x5bc>
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
800031a4:	fe 68 00 00 	mov	r8,-131072
800031a8:	70 48       	ld.w	r8,r8[0x10]
800031aa:	e2 18 00 10 	andl	r8,0x10,COH
800031ae:	c2 10       	breq	800031f0 <udd_interrupt+0x584>
800031b0:	fe 68 00 00 	mov	r8,-131072
800031b4:	70 18       	ld.w	r8,r8[0x4]
800031b6:	e2 18 00 10 	andl	r8,0x10,COH
800031ba:	c1 b0       	breq	800031f0 <udd_interrupt+0x584>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
800031bc:	fe 68 00 00 	mov	r8,-131072
800031c0:	f0 f9 08 00 	ld.w	r9,r8[2048]
800031c4:	af c9       	cbr	r9,0xe
800031c6:	f1 49 08 00 	st.w	r8[2048],r9
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
800031ca:	c0 58       	rjmp	800031d4 <udd_interrupt+0x568>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
800031cc:	70 19       	ld.w	r9,r8[0x4]
800031ce:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
800031d2:	c0 61       	brne	800031de <udd_interrupt+0x572>

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_clock_usable() ) {
800031d4:	f0 f9 08 04 	ld.w	r9,r8[2052]
800031d8:	e2 19 40 00 	andl	r9,0x4000,COH
800031dc:	cf 80       	breq	800031cc <udd_interrupt+0x560>
			if(Is_udd_suspend()) break;   // In case of USB state change in HS
		};
		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
800031de:	fe 68 00 00 	mov	r8,-131072
800031e2:	31 09       	mov	r9,16
800031e4:	91 59       	st.w	r8[0x14],r9
		udd_enable_suspend_interrupt();
800031e6:	30 1c       	mov	r12,1
800031e8:	91 6c       	st.w	r8[0x18],r12
		udd_sleep_mode(true);	// Enter in IDLE mode
800031ea:	f0 1f 00 29 	mcall	8000328c <udd_interrupt+0x620>
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		goto udd_interrupt_end;
800031ee:	c1 d8       	rjmp	80003228 <udd_interrupt+0x5bc>
	}

	if (Is_udd_vbus_transition()) {
800031f0:	fe 68 00 00 	mov	r8,-131072
800031f4:	f0 f8 08 04 	ld.w	r8,r8[2052]
800031f8:	e2 18 00 02 	andl	r8,0x2,COH
800031fc:	c1 60       	breq	80003228 <udd_interrupt+0x5bc>
		// Ack VBus transition and send status to high level
		otg_unfreeze_clock();
800031fe:	fe 68 00 00 	mov	r8,-131072
80003202:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003206:	af c9       	cbr	r9,0xe
80003208:	f1 49 08 00 	st.w	r8[2048],r9
		udd_ack_vbus_transition();
8000320c:	30 29       	mov	r9,2
8000320e:	f1 49 08 08 	st.w	r8[2056],r9
		otg_freeze_clock();
80003212:	f0 f9 08 00 	ld.w	r9,r8[2048]
80003216:	af a9       	sbr	r9,0xe
80003218:	f1 49 08 00 	st.w	r8[2048],r9
#ifdef UDC_VBUS_EVENT
		UDC_VBUS_EVENT(Is_udd_vbus_high());
8000321c:	f0 fc 08 04 	ld.w	r12,r8[2052]
80003220:	f9 dc c1 61 	bfextu	r12,r12,0xb,0x1
80003224:	f0 1f 00 1b 	mcall	80003290 <udd_interrupt+0x624>
#endif
		goto udd_interrupt_end;
	}
udd_interrupt_end:
	otg_data_memory_barrier();
80003228:	fe 68 00 00 	mov	r8,-131072
8000322c:	f0 f8 08 18 	ld.w	r8,r8[2072]
	return;
}
80003230:	e3 cd 40 fc 	ldm	sp++,r2-r7,lr
80003234:	d6 03       	rete
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
80003236:	48 f9       	lddpc	r9,80003270 <udd_interrupt+0x604>
80003238:	b2 08       	st.h	r9[0x0],r8
8000323a:	fe 9f fe 40 	bral	80002eba <udd_interrupt+0x24e>
	if (udd_ep_interrupt())
		goto udd_interrupt_end;	// Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
8000323e:	fe 68 00 00 	mov	r8,-131072
80003242:	70 18       	ld.w	r8,r8[0x4]
80003244:	e2 18 00 08 	andl	r8,0x8,COH
80003248:	c8 e0       	breq	80003164 <udd_interrupt+0x4f8>
8000324a:	c7 8b       	rjmp	8000313a <udd_interrupt+0x4ce>
8000324c:	80 00       	ld.sh	r0,r0[0x0]
8000324e:	38 10       	mov	r0,-127
80003250:	00 00       	add	r0,r0
80003252:	07 5c       	ld.sh	r12,--r3
80003254:	80 00       	ld.sh	r0,r0[0x0]
80003256:	25 90       	sub	r0,89
80003258:	80 00       	ld.sh	r0,r0[0x0]
8000325a:	27 d0       	sub	r0,125
8000325c:	80 00       	ld.sh	r0,r0[0x0]
8000325e:	25 78       	sub	r8,87
80003260:	00 00       	add	r0,r0
80003262:	0a 10       	sub	r0,r5
80003264:	80 00       	ld.sh	r0,r0[0x0]
80003266:	3a 90       	mov	r0,-87
80003268:	00 00       	add	r0,r0
8000326a:	07 60       	ld.uh	r0,--r3
8000326c:	00 00       	add	r0,r0
8000326e:	07 24       	ld.uh	r4,r3++
80003270:	00 00       	add	r0,r0
80003272:	07 5a       	ld.sh	r10,--r3
80003274:	80 00       	ld.sh	r0,r0[0x0]
80003276:	28 30       	sub	r0,-125
80003278:	80 00       	ld.sh	r0,r0[0x0]
8000327a:	28 04       	sub	r4,-128
8000327c:	00 00       	add	r0,r0
8000327e:	07 28       	ld.uh	r8,r3++
80003280:	80 00       	ld.sh	r0,r0[0x0]
80003282:	25 a4       	sub	r4,90
80003284:	80 00       	ld.sh	r0,r0[0x0]
80003286:	3a 30       	mov	r0,-93
80003288:	80 00       	ld.sh	r0,r0[0x0]
8000328a:	2a 8e       	sub	lr,-88
8000328c:	80 00       	ld.sh	r0,r0[0x0]
8000328e:	27 5c       	sub	r12,117
80003290:	80 00       	ld.sh	r0,r0[0x0]
80003292:	3f 90       	mov	r0,-7

80003294 <sysclk_priv_enable_module>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003294:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
80003298:	d3 03       	ssrf	0x10

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
8000329a:	fe 78 0c 00 	mov	r8,-62464
8000329e:	71 59       	ld.w	r9,r8[0x54]
800032a0:	e2 19 00 40 	andl	r9,0x40,COH
800032a4:	cf d0       	breq	8000329e <sysclk_priv_enable_module+0xa>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
800032a6:	a3 6c       	lsl	r12,0x2
800032a8:	e0 2c f3 f8 	sub	r12,62456
800032ac:	78 08       	ld.w	r8,r12[0x0]
	mask |= 1U << module_index;
800032ae:	30 19       	mov	r9,1
800032b0:	f2 0b 09 4b 	lsl	r11,r9,r11
800032b4:	10 4b       	or	r11,r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
800032b6:	99 0b       	st.w	r12[0x0],r11
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800032b8:	e3 ba 00 00 	mtsr	0x0,r10

	cpu_irq_restore(flags);
}
800032bc:	5e fc       	retal	r12
800032be:	d7 03       	nop

800032c0 <sysclk_enable_pbb_module>:
/**
 * \brief Enable a module clock derived from the PBB clock
 * \param index Index of the module clock in the PBBMASK register
 */
void sysclk_enable_pbb_module(unsigned int index)
{
800032c0:	eb cd 40 e0 	pushm	r5-r7,lr
800032c4:	18 96       	mov	r6,r12
800032c6:	58 9c       	cp.w	r12,9
800032c8:	5f 07       	sreq	r7

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800032ca:	e1 b5 00 00 	mfsr	r5,0x0
	cpu_irq_disable();
800032ce:	d3 03       	ssrf	0x10
		pbus_id = 1;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (!sysclk_bus_refcount[pbus_id])
800032d0:	48 f8       	lddpc	r8,8000330c <sysclk_enable_pbb_module+0x4c>
800032d2:	f0 07 07 09 	ld.ub	r9,r8[r7]
800032d6:	30 08       	mov	r8,0
800032d8:	f0 09 18 00 	cp.b	r9,r8
800032dc:	c0 a1       	brne	800032f0 <sysclk_enable_pbb_module+0x30>
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
800032de:	ee 0b 15 01 	lsl	r11,r7,0x1
800032e2:	f9 bb 01 06 	movne	r11,6
800032e6:	f9 bb 00 02 	moveq	r11,2
800032ea:	30 1c       	mov	r12,1
800032ec:	f0 1f 00 09 	mcall	80003310 <sysclk_enable_pbb_module+0x50>
		sysclk_enable_hsb_module(2 + (4 * pbus_id));
	sysclk_bus_refcount[pbus_id]++;
800032f0:	48 78       	lddpc	r8,8000330c <sysclk_enable_pbb_module+0x4c>
800032f2:	f0 07 07 09 	ld.ub	r9,r8[r7]
800032f6:	2f f9       	sub	r9,-1
800032f8:	f0 07 0b 09 	st.b	r8[r7],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800032fc:	e3 b5 00 00 	mtsr	0x0,r5

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
80003300:	0c 9b       	mov	r11,r6
80003302:	30 3c       	mov	r12,3
80003304:	f0 1f 00 03 	mcall	80003310 <sysclk_enable_pbb_module+0x50>
}
80003308:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000330c:	00 00       	add	r0,r0
8000330e:	07 64       	ld.uh	r4,--r3
80003310:	80 00       	ld.sh	r0,r0[0x0]
80003312:	32 94       	mov	r4,41

80003314 <sysclk_enable_usb>:
 * \pre The USB generick clock must be configurated to 12MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
80003314:	d4 01       	pushm	lr
	struct genclk_config gcfg;

	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
80003316:	30 1c       	mov	r12,1
80003318:	f0 1f 00 0f 	mcall	80003354 <sysclk_enable_usb+0x40>
8000331c:	30 3b       	mov	r11,3
8000331e:	30 1c       	mov	r12,1
80003320:	f0 1f 00 0e 	mcall	80003358 <sysclk_enable_usb+0x44>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80003324:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80003328:	d3 03       	ssrf	0x10
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
		AVR32_PM.oscctrl0 = oscctrl;
8000332a:	fe 78 0c 00 	mov	r8,-62464
8000332e:	e0 6a 03 07 	mov	r10,775
80003332:	91 aa       	st.w	r8[0x28],r10
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
80003334:	70 0a       	ld.w	r10,r8[0x0]
80003336:	a3 aa       	sbr	r10,0x2
80003338:	91 0a       	st.w	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000333a:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
}

static inline bool osc_is_ready(uint8_t id)
{
	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_OSC0RDY + id)));
8000333e:	71 59       	ld.w	r9,r8[0x54]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
80003340:	e2 19 00 80 	andl	r9,0x80,COH
80003344:	cf d0       	breq	8000333e <sysclk_enable_usb+0x2a>
}

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
80003346:	30 49       	mov	r9,4
80003348:	fe 78 0c 00 	mov	r8,-62464
8000334c:	f1 49 00 70 	st.w	r8[112],r9
		break;
	}

	genclk_config_set_divider(&gcfg, CONFIG_USBCLK_DIV);
	genclk_enable(&gcfg, AVR32_PM_GCLK_USBB);
}
80003350:	d8 02       	popm	pc
80003352:	00 00       	add	r0,r0
80003354:	80 00       	ld.sh	r0,r0[0x0]
80003356:	32 c0       	mov	r0,44
80003358:	80 00       	ld.sh	r0,r0[0x0]
8000335a:	32 94       	mov	r4,41

8000335c <udi_cdc_data_disable>:
	UDI_CDC_DISABLE_EXT();
}

void udi_cdc_data_disable(void)
{
}
8000335c:	5e fc       	retal	r12
8000335e:	d7 03       	nop

80003360 <udi_cdc_comm_setup>:


bool udi_cdc_comm_setup(void)
{
	if (Udd_setup_is_in()) {
80003360:	49 e8       	lddpc	r8,800033d8 <udi_cdc_comm_setup+0x78>
80003362:	11 88       	ld.ub	r8,r8[0x0]
80003364:	30 09       	mov	r9,0
80003366:	f2 08 18 00 	cp.b	r8,r9
8000336a:	c1 84       	brge	8000339a <udi_cdc_comm_setup+0x3a>
		// GET Interface Requests 
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
8000336c:	e2 18 00 60 	andl	r8,0x60,COH
80003370:	e0 48 00 20 	cp.w	r8,32
80003374:	c3 11       	brne	800033d6 <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
80003376:	49 98       	lddpc	r8,800033d8 <udi_cdc_comm_setup+0x78>
80003378:	11 99       	ld.ub	r9,r8[0x1]
8000337a:	32 18       	mov	r8,33
8000337c:	f0 09 18 00 	cp.b	r9,r8
80003380:	c2 b1       	brne	800033d6 <udi_cdc_comm_setup+0x76>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
80003382:	49 68       	lddpc	r8,800033d8 <udi_cdc_comm_setup+0x78>
80003384:	90 39       	ld.sh	r9,r8[0x6]
80003386:	30 78       	mov	r8,7
80003388:	f0 09 19 00 	cp.h	r9,r8
8000338c:	c2 51       	brne	800033d6 <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.payload =
8000338e:	49 38       	lddpc	r8,800033d8 <udi_cdc_comm_setup+0x78>
80003390:	49 39       	lddpc	r9,800033dc <udi_cdc_comm_setup+0x7c>
80003392:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
80003394:	30 79       	mov	r9,7
80003396:	b0 69       	st.h	r8[0xc],r9
80003398:	5e ff       	retal	1
			}
		}
	}
	if (Udd_setup_is_out()) {
		// SET Interface Requests  
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
8000339a:	e2 18 00 60 	andl	r8,0x60,COH
8000339e:	e0 48 00 20 	cp.w	r8,32
800033a2:	c1 a1       	brne	800033d6 <udi_cdc_comm_setup+0x76>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
800033a4:	48 d8       	lddpc	r8,800033d8 <udi_cdc_comm_setup+0x78>
800033a6:	11 98       	ld.ub	r8,r8[0x1]
800033a8:	32 09       	mov	r9,32
800033aa:	f2 08 18 00 	cp.b	r8,r9
800033ae:	c0 60       	breq	800033ba <udi_cdc_comm_setup+0x5a>
800033b0:	32 29       	mov	r9,34
800033b2:	f2 08 18 00 	cp.b	r8,r9
800033b6:	c1 01       	brne	800033d6 <udi_cdc_comm_setup+0x76>
800033b8:	5e ff       	retal	1
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
800033ba:	48 88       	lddpc	r8,800033d8 <udi_cdc_comm_setup+0x78>
800033bc:	90 39       	ld.sh	r9,r8[0x6]
800033be:	30 78       	mov	r8,7
800033c0:	f0 09 19 00 	cp.h	r9,r8
800033c4:	c0 91       	brne	800033d6 <udi_cdc_comm_setup+0x76>
						udd_g_ctrlreq.req.wLength)
					return false;	// Error for USB host
				udd_g_ctrlreq.callback =
800033c6:	48 58       	lddpc	r8,800033d8 <udi_cdc_comm_setup+0x78>
800033c8:	48 69       	lddpc	r9,800033e0 <udi_cdc_comm_setup+0x80>
800033ca:	91 49       	st.w	r8[0x10],r9
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
800033cc:	48 49       	lddpc	r9,800033dc <udi_cdc_comm_setup+0x7c>
800033ce:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding;
				udd_g_ctrlreq.payload_size =
800033d0:	30 79       	mov	r9,7
800033d2:	b0 69       	st.h	r8[0xc],r9
800033d4:	5e ff       	retal	1
						sizeof(udi_cdc_line_coding);
				return true;
800033d6:	5e fd       	retal	0
800033d8:	00 00       	add	r0,r0
800033da:	0a 10       	sub	r0,r5
800033dc:	00 00       	add	r0,r0
800033de:	07 68       	ld.uh	r8,--r3
800033e0:	80 00       	ld.sh	r0,r0[0x0]
800033e2:	33 e8       	mov	r8,62

800033e4 <udi_cdc_data_setup>:
}

bool udi_cdc_data_setup(void)
{
	return false;  // request Not supported
}
800033e4:	5e fd       	retal	0

800033e6 <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
	return 0;      // CDC don't have multiple alternate setting
}
800033e6:	5e fd       	retal	0

800033e8 <udi_cdc_line_coding_received>:

void udi_cdc_line_coding_received(void)
{
	// Send line coding to component associated to CDC
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));
}
800033e8:	5e fc       	retal	r12
800033ea:	d7 03       	nop

800033ec <udi_cdc_is_rx_ready>:
}


bool udi_cdc_is_rx_ready(void)
{
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
800033ec:	48 68       	lddpc	r8,80003404 <udi_cdc_is_rx_ready+0x18>
800033ee:	11 8a       	ld.ub	r10,r8[0x0]
800033f0:	48 68       	lddpc	r8,80003408 <udi_cdc_is_rx_ready+0x1c>
800033f2:	90 08       	ld.sh	r8,r8[0x0]
800033f4:	48 69       	lddpc	r9,8000340c <udi_cdc_is_rx_ready+0x20>
800033f6:	f2 0a 04 19 	ld.sh	r9,r9[r10<<0x1]
800033fa:	f0 09 19 00 	cp.h	r9,r8
}
800033fe:	5f bc       	srhi	r12
80003400:	5e fc       	retal	r12
80003402:	00 00       	add	r0,r0
80003404:	00 00       	add	r0,r0
80003406:	07 fc       	ld.ub	r12,r3[0x7]
80003408:	00 00       	add	r0,r0
8000340a:	07 f8       	ld.ub	r8,r3[0x7]
8000340c:	00 00       	add	r0,r0
8000340e:	07 f4       	ld.ub	r4,r3[0x7]

80003410 <udi_cdc_is_tx_ready>:


bool udi_cdc_is_tx_ready(void)
{
	irqflags_t flags;
	if (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS) {
80003410:	49 58       	lddpc	r8,80003464 <udi_cdc_is_tx_ready+0x54>
80003412:	11 89       	ld.ub	r9,r8[0x0]
80003414:	49 58       	lddpc	r8,80003468 <udi_cdc_is_tx_ready+0x58>
80003416:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
8000341a:	34 08       	mov	r8,64
8000341c:	f0 09 19 00 	cp.h	r9,r8
80003420:	c0 20       	breq	80003424 <udi_cdc_is_tx_ready+0x14>
80003422:	5e ff       	retal	1
		return true;
	}
	if (!udi_cdc_tx_both_buf_to_send) {
80003424:	49 28       	lddpc	r8,8000346c <udi_cdc_is_tx_ready+0x5c>
80003426:	11 88       	ld.ub	r8,r8[0x0]
80003428:	58 08       	cp.w	r8,0
8000342a:	c1 21       	brne	8000344e <udi_cdc_is_tx_ready+0x3e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000342c:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
80003430:	d3 03       	ssrf	0x10
		flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
		if (!udi_cdc_tx_trans_ongoing) {
80003432:	49 09       	lddpc	r9,80003470 <udi_cdc_is_tx_ready+0x60>
80003434:	13 89       	ld.ub	r9,r9[0x0]
80003436:	58 09       	cp.w	r9,0
80003438:	c0 91       	brne	8000344a <udi_cdc_is_tx_ready+0x3a>
			// No transfer on-going
			// then use the other buffer to store data
			udi_cdc_tx_both_buf_to_send = true;
8000343a:	30 1a       	mov	r10,1
8000343c:	48 c9       	lddpc	r9,8000346c <udi_cdc_is_tx_ready+0x5c>
8000343e:	b2 8a       	st.b	r9[0x0],r10
			udi_cdc_tx_buf_sel = (udi_cdc_tx_buf_sel==0)?1:0;
80003440:	48 99       	lddpc	r9,80003464 <udi_cdc_is_tx_ready+0x54>
80003442:	13 8a       	ld.ub	r10,r9[0x0]
80003444:	58 0a       	cp.w	r10,0
80003446:	5f 0a       	sreq	r10
80003448:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
8000344a:	e3 b8 00 00 	mtsr	0x0,r8
		}
	  	cpu_irq_restore(flags);
	}
	return (udi_cdc_tx_buf_nb[udi_cdc_tx_buf_sel]!=UDI_CDC_TX_BUFFERS);
8000344e:	48 68       	lddpc	r8,80003464 <udi_cdc_is_tx_ready+0x54>
80003450:	11 89       	ld.ub	r9,r8[0x0]
80003452:	48 68       	lddpc	r8,80003468 <udi_cdc_is_tx_ready+0x58>
80003454:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
80003458:	34 08       	mov	r8,64
8000345a:	f0 09 19 00 	cp.h	r9,r8
8000345e:	5f 1c       	srne	r12
}
80003460:	5e fc       	retal	r12
80003462:	00 00       	add	r0,r0
80003464:	00 00       	add	r0,r0
80003466:	07 6f       	ld.uh	pc,--r3
80003468:	00 00       	add	r0,r0
8000346a:	07 70       	ld.ub	r0,--r3
8000346c:	00 00       	add	r0,r0
8000346e:	08 81       	andn	r1,r4
80003470:	00 00       	add	r0,r0
80003472:	07 fe       	ld.ub	lr,r3[0x7]

80003474 <udi_cdc_putc>:


int udi_cdc_putc(int value)
{
80003474:	eb cd 40 fe 	pushm	r1-r7,lr
80003478:	18 97       	mov	r7,r12
	irqflags_t flags;
	bool b_databit_9;
	uint8_t buf_sel;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
8000347a:	49 88       	lddpc	r8,800034d8 <udi_cdc_putc+0x64>
8000347c:	11 e9       	ld.ub	r9,r8[0x6]
8000347e:	30 98       	mov	r8,9
80003480:	f0 09 18 00 	cp.b	r9,r8
80003484:	5f 04       	sreq	r4

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
		if (!udi_cdc_running) {
80003486:	49 66       	lddpc	r6,800034dc <udi_cdc_putc+0x68>
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
80003488:	49 63       	lddpc	r3,800034e0 <udi_cdc_putc+0x6c>
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
8000348a:	49 75       	lddpc	r5,800034e4 <udi_cdc_putc+0x70>
8000348c:	49 72       	lddpc	r2,800034e8 <udi_cdc_putc+0x74>
	cpu_irq_restore(flags);

	if (b_databit_9) {
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
8000348e:	30 01       	mov	r1,0

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_putc_process_one_byte:
	// Check avaliable space
	if (!udi_cdc_is_tx_ready()) {
80003490:	f0 1f 00 17 	mcall	800034ec <udi_cdc_putc+0x78>
80003494:	c0 51       	brne	8000349e <udi_cdc_putc+0x2a>
		if (!udi_cdc_running) {
80003496:	0d 88       	ld.ub	r8,r6[0x0]
80003498:	58 08       	cp.w	r8,0
8000349a:	cf b1       	brne	80003490 <udi_cdc_putc+0x1c>
8000349c:	c1 b8       	rjmp	800034d2 <udi_cdc_putc+0x5e>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000349e:	e1 ba 00 00 	mfsr	r10,0x0
	cpu_irq_disable();
800034a2:	d3 03       	ssrf	0x10
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel;
800034a4:	07 88       	ld.ub	r8,r3[0x0]
	udi_cdc_tx_buf[buf_sel][udi_cdc_tx_buf_nb[buf_sel]++] = value;
800034a6:	ea 08 04 19 	ld.sh	r9,r5[r8<<0x1]
800034aa:	f7 d9 c0 10 	bfextu	r11,r9,0x0,0x10
800034ae:	f0 0c 15 06 	lsl	r12,r8,0x6
800034b2:	f8 0b 00 0b 	add	r11,r12,r11
800034b6:	e4 0b 0b 07 	st.b	r2[r11],r7
800034ba:	2f f9       	sub	r9,-1
800034bc:	ea 08 0a 19 	st.h	r5[r8<<0x1],r9
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
800034c0:	e3 ba 00 00 	mtsr	0x0,r10
	cpu_irq_restore(flags);

	if (b_databit_9) {
800034c4:	58 04       	cp.w	r4,0
800034c6:	c0 31       	brne	800034cc <udi_cdc_putc+0x58>
800034c8:	e3 cf 90 fe 	ldm	sp++,r1-r7,pc,r12=1
		// Send MSB
		b_databit_9 = false;
		value = value >> 8;
800034cc:	a9 47       	asr	r7,0x8
800034ce:	02 94       	mov	r4,r1
800034d0:	ce 0b       	rjmp	80003490 <udi_cdc_putc+0x1c>
		goto udi_cdc_putc_process_one_byte;
800034d2:	e3 cf 80 fe 	ldm	sp++,r1-r7,pc,r12=0
800034d6:	00 00       	add	r0,r0
800034d8:	00 00       	add	r0,r0
800034da:	07 68       	ld.uh	r8,--r3
800034dc:	00 00       	add	r0,r0
800034de:	07 fd       	ld.ub	sp,r3[0x7]
800034e0:	00 00       	add	r0,r0
800034e2:	07 6f       	ld.uh	pc,--r3
800034e4:	00 00       	add	r0,r0
800034e6:	07 70       	ld.ub	r0,--r3
800034e8:	00 00       	add	r0,r0
800034ea:	07 74       	ld.ub	r4,--r3
800034ec:	80 00       	ld.sh	r0,r0[0x0]
800034ee:	34 10       	mov	r0,65

800034f0 <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(void)
{
800034f0:	eb cd 40 80 	pushm	r7,lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800034f4:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800034f8:	d3 03       	ssrf	0x10
	irqflags_t flags;
	uint8_t buf_sel_trans;

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel;
800034fa:	49 78       	lddpc	r8,80003554 <udi_cdc_rx_start+0x64>
800034fc:	11 87       	ld.ub	r7,r8[0x0]
	if (udi_cdc_rx_trans_ongoing ||
800034fe:	49 78       	lddpc	r8,80003558 <udi_cdc_rx_start+0x68>
80003500:	11 88       	ld.ub	r8,r8[0x0]
80003502:	58 08       	cp.w	r8,0
80003504:	c0 a1       	brne	80003518 <udi_cdc_rx_start+0x28>
		(udi_cdc_rx_pos < udi_cdc_rx_buf_nb[buf_sel_trans])) {
80003506:	49 68       	lddpc	r8,8000355c <udi_cdc_rx_start+0x6c>
80003508:	90 08       	ld.sh	r8,r8[0x0]
8000350a:	49 6a       	lddpc	r10,80003560 <udi_cdc_rx_start+0x70>
8000350c:	f4 07 04 1a 	ld.sh	r10,r10[r7<<0x1]
80003510:	f0 0a 19 00 	cp.h	r10,r8
80003514:	e0 88 00 06 	brls	80003520 <udi_cdc_rx_start+0x30>
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003518:	e3 b9 00 00 	mtsr	0x0,r9
#endif
	barrier();
8000351c:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		cpu_irq_restore(flags);
		return false;
	}

	// Change current buffer
	udi_cdc_rx_pos = 0;
80003520:	30 0a       	mov	r10,0
80003522:	48 f8       	lddpc	r8,8000355c <udi_cdc_rx_start+0x6c>
80003524:	b0 0a       	st.h	r8[0x0],r10
	udi_cdc_rx_buf_sel = (buf_sel_trans==0)?1:0;
80003526:	58 07       	cp.w	r7,0
80003528:	5f 0a       	sreq	r10
8000352a:	48 b8       	lddpc	r8,80003554 <udi_cdc_rx_start+0x64>
8000352c:	b0 8a       	st.b	r8[0x0],r10

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing = true;
8000352e:	30 1a       	mov	r10,1
80003530:	48 a8       	lddpc	r8,80003558 <udi_cdc_rx_start+0x68>
80003532:	b0 8a       	st.b	r8[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003534:	e3 b9 00 00 	mtsr	0x0,r9
	cpu_irq_restore(flags);
	
	if (udi_cdc_is_rx_ready()) {
80003538:	f0 1f 00 0b 	mcall	80003564 <udi_cdc_rx_start+0x74>
		UDI_CDC_RX_NOTIFY();
	}

	return udd_ep_run( UDI_CDC_DATA_EP_OUT,
8000353c:	a7 67       	lsl	r7,0x6
8000353e:	48 b8       	lddpc	r8,80003568 <udi_cdc_rx_start+0x78>
80003540:	34 09       	mov	r9,64
80003542:	48 ba       	lddpc	r10,8000356c <udi_cdc_rx_start+0x7c>
80003544:	0e 0a       	add	r10,r7
80003546:	30 1b       	mov	r11,1
80003548:	30 2c       	mov	r12,2
8000354a:	f0 1f 00 0a 	mcall	80003570 <udi_cdc_rx_start+0x80>
					true,
					udi_cdc_rx_buf[buf_sel_trans],
					UDI_CDC_RX_BUFFERS,
					udi_cdc_data_recevied);
}
8000354e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003552:	00 00       	add	r0,r0
80003554:	00 00       	add	r0,r0
80003556:	07 fc       	ld.ub	r12,r3[0x7]
80003558:	00 00       	add	r0,r0
8000355a:	08 80       	andn	r0,r4
8000355c:	00 00       	add	r0,r0
8000355e:	07 f8       	ld.ub	r8,r3[0x7]
80003560:	00 00       	add	r0,r0
80003562:	07 f4       	ld.ub	r4,r3[0x7]
80003564:	80 00       	ld.sh	r0,r0[0x0]
80003566:	33 ec       	mov	r12,62
80003568:	80 00       	ld.sh	r0,r0[0x0]
8000356a:	35 f0       	mov	r0,95
8000356c:	00 00       	add	r0,r0
8000356e:	08 00       	add	r0,r4
80003570:	80 00       	ld.sh	r0,r0[0x0]
80003572:	26 14       	sub	r4,97

80003574 <udi_cdc_getc>:
	return (udi_cdc_rx_pos < udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]);
}


int udi_cdc_getc(void)
{
80003574:	d4 31       	pushm	r0-r7,lr
	int rx_data = 0;
	bool b_databit_9;

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);
80003576:	49 88       	lddpc	r8,800035d4 <udi_cdc_getc+0x60>
80003578:	11 e9       	ld.ub	r9,r8[0x6]
8000357a:	30 98       	mov	r8,9
8000357c:	f0 09 18 00 	cp.b	r9,r8
80003580:	5f 02       	sreq	r2
80003582:	30 03       	mov	r3,0

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
80003584:	49 56       	lddpc	r6,800035d8 <udi_cdc_getc+0x64>
80003586:	49 67       	lddpc	r7,800035dc <udi_cdc_getc+0x68>
80003588:	49 65       	lddpc	r5,800035e0 <udi_cdc_getc+0x6c>
		if (!udi_cdc_running) {
8000358a:	49 74       	lddpc	r4,800035e4 <udi_cdc_getc+0x70>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
8000358c:	49 71       	lddpc	r1,800035e8 <udi_cdc_getc+0x74>
	udi_cdc_rx_start();

	if (b_databit_9) {
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
8000358e:	06 90       	mov	r0,r3
80003590:	c0 48       	rjmp	80003598 <udi_cdc_getc+0x24>
	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
		if (!udi_cdc_running) {
80003592:	09 88       	ld.ub	r8,r4[0x0]
80003594:	58 08       	cp.w	r8,0
80003596:	c1 b0       	breq	800035cc <udi_cdc_getc+0x58>

	b_databit_9 = (9 == udi_cdc_line_coding.bDataBits);

udi_cdc_getc_process_one_byte:
	// Check avaliable data
	while (udi_cdc_rx_pos >= udi_cdc_rx_buf_nb[udi_cdc_rx_buf_sel]) {
80003598:	0d 89       	ld.ub	r9,r6[0x0]
8000359a:	8e 08       	ld.sh	r8,r7[0x0]
8000359c:	ea 09 04 19 	ld.sh	r9,r5[r9<<0x1]
800035a0:	f0 09 19 00 	cp.h	r9,r8
800035a4:	fe 98 ff f7 	brls	80003592 <udi_cdc_getc+0x1e>
		}
		goto udi_cdc_getc_process_one_byte;
	}

	// Read data
	rx_data |= udi_cdc_rx_buf[udi_cdc_rx_buf_sel][udi_cdc_rx_pos];
800035a8:	0d 88       	ld.ub	r8,r6[0x0]
800035aa:	8e 09       	ld.sh	r9,r7[0x0]
800035ac:	5c 79       	castu.h	r9
800035ae:	a7 68       	lsl	r8,0x6
800035b0:	12 08       	add	r8,r9
800035b2:	e2 08 07 08 	ld.ub	r8,r1[r8]
800035b6:	10 43       	or	r3,r8
	udi_cdc_rx_pos++;
800035b8:	8e 08       	ld.sh	r8,r7[0x0]
800035ba:	2f f8       	sub	r8,-1
800035bc:	ae 08       	st.h	r7[0x0],r8

	udi_cdc_rx_start();
800035be:	f0 1f 00 0c 	mcall	800035ec <udi_cdc_getc+0x78>

	if (b_databit_9) {
800035c2:	58 02       	cp.w	r2,0
800035c4:	c0 50       	breq	800035ce <udi_cdc_getc+0x5a>
		// Receive MSB
		b_databit_9 = false;
		rx_data = rx_data << 8;
800035c6:	a9 63       	lsl	r3,0x8
800035c8:	00 92       	mov	r2,r0
800035ca:	ce 7b       	rjmp	80003598 <udi_cdc_getc+0x24>
		goto udi_cdc_getc_process_one_byte;
800035cc:	30 03       	mov	r3,0
	}
	return rx_data;
}
800035ce:	06 9c       	mov	r12,r3
800035d0:	d8 32       	popm	r0-r7,pc
800035d2:	00 00       	add	r0,r0
800035d4:	00 00       	add	r0,r0
800035d6:	07 68       	ld.uh	r8,--r3
800035d8:	00 00       	add	r0,r0
800035da:	07 fc       	ld.ub	r12,r3[0x7]
800035dc:	00 00       	add	r0,r0
800035de:	07 f8       	ld.ub	r8,r3[0x7]
800035e0:	00 00       	add	r0,r0
800035e2:	07 f4       	ld.ub	r4,r3[0x7]
800035e4:	00 00       	add	r0,r0
800035e6:	07 fd       	ld.ub	sp,r3[0x7]
800035e8:	00 00       	add	r0,r0
800035ea:	08 00       	add	r0,r4
800035ec:	80 00       	ld.sh	r0,r0[0x0]
800035ee:	34 f0       	mov	r0,79

800035f0 <udi_cdc_data_recevied>:
					udi_cdc_data_recevied);
}


void udi_cdc_data_recevied(udd_ep_status_t status, iram_size_t n)
{
800035f0:	d4 01       	pushm	lr
	uint8_t buf_sel_trans;

	if (UDD_EP_TRANSFER_OK != status) {
800035f2:	58 0c       	cp.w	r12,0
800035f4:	c1 01       	brne	80003614 <udi_cdc_data_recevied+0x24>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel==0)?1:0;
800035f6:	48 98       	lddpc	r8,80003618 <udi_cdc_data_recevied+0x28>
800035f8:	11 88       	ld.ub	r8,r8[0x0]
	udi_cdc_rx_buf_nb[buf_sel_trans] = n;
800035fa:	58 08       	cp.w	r8,0
800035fc:	f9 b8 01 00 	movne	r8,0
80003600:	f9 b8 00 02 	moveq	r8,2
80003604:	48 69       	lddpc	r9,8000361c <udi_cdc_data_recevied+0x2c>
80003606:	f2 08 0a 0b 	st.h	r9[r8],r11
	udi_cdc_rx_trans_ongoing = false;
8000360a:	30 09       	mov	r9,0
8000360c:	48 58       	lddpc	r8,80003620 <udi_cdc_data_recevied+0x30>
8000360e:	b0 89       	st.b	r8[0x0],r9
	udi_cdc_rx_start();
80003610:	f0 1f 00 05 	mcall	80003624 <udi_cdc_data_recevied+0x34>
80003614:	d8 02       	popm	pc
80003616:	00 00       	add	r0,r0
80003618:	00 00       	add	r0,r0
8000361a:	07 fc       	ld.ub	r12,r3[0x7]
8000361c:	00 00       	add	r0,r0
8000361e:	07 f4       	ld.ub	r4,r3[0x7]
80003620:	00 00       	add	r0,r0
80003622:	08 80       	andn	r0,r4
80003624:	80 00       	ld.sh	r0,r0[0x0]
80003626:	34 f0       	mov	r0,79

80003628 <udi_cdc_tx_send>:
	udi_cdc_tx_send();
}


static void udi_cdc_tx_send(void)
{
80003628:	eb cd 40 e0 	pushm	r5-r7,lr
	irqflags_t flags;
	uint8_t buf_sel_trans;
	bool b_short_packet;

	if (udi_cdc_tx_trans_ongoing) {
8000362c:	4a a8       	lddpc	r8,800036d4 <udi_cdc_tx_send+0xac>
8000362e:	11 88       	ld.ub	r8,r8[0x0]
80003630:	58 08       	cp.w	r8,0
80003632:	c4 f1       	brne	800036d0 <udi_cdc_tx_send+0xa8>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
80003634:	f0 1f 00 29 	mcall	800036d8 <udi_cdc_tx_send+0xb0>
80003638:	c0 a0       	breq	8000364c <udi_cdc_tx_send+0x24>
		if (udi_cdc_tx_sof_num == udd_get_micro_frame_number()) {
8000363a:	f0 1f 00 29 	mcall	800036dc <udi_cdc_tx_send+0xb4>
8000363e:	4a 98       	lddpc	r8,800036e0 <udi_cdc_tx_send+0xb8>
80003640:	90 08       	ld.sh	r8,r8[0x0]
80003642:	f8 08 19 00 	cp.h	r8,r12
80003646:	c0 a1       	brne	8000365a <udi_cdc_tx_send+0x32>
80003648:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num == udd_get_frame_number()) {
8000364c:	f0 1f 00 26 	mcall	800036e4 <udi_cdc_tx_send+0xbc>
80003650:	4a 48       	lddpc	r8,800036e0 <udi_cdc_tx_send+0xb8>
80003652:	90 08       	ld.sh	r8,r8[0x0]
80003654:	f8 08 19 00 	cp.h	r8,r12
80003658:	c3 c0       	breq	800036d0 <udi_cdc_tx_send+0xa8>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000365a:	e1 b8 00 00 	mfsr	r8,0x0
	cpu_irq_disable();
8000365e:	d3 03       	ssrf	0x10
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save();	// to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel;
80003660:	4a 29       	lddpc	r9,800036e8 <udi_cdc_tx_send+0xc0>
80003662:	13 87       	ld.ub	r7,r9[0x0]
	if (!udi_cdc_tx_both_buf_to_send) {
80003664:	4a 29       	lddpc	r9,800036ec <udi_cdc_tx_send+0xc4>
80003666:	13 89       	ld.ub	r9,r9[0x0]
80003668:	58 09       	cp.w	r9,0
8000366a:	c0 61       	brne	80003676 <udi_cdc_tx_send+0x4e>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel = (buf_sel_trans==0)?1:0;
8000366c:	58 07       	cp.w	r7,0
8000366e:	5f 0a       	sreq	r10
80003670:	49 e9       	lddpc	r9,800036e8 <udi_cdc_tx_send+0xc0>
80003672:	b2 8a       	st.b	r9[0x0],r10
80003674:	c0 38       	rjmp	8000367a <udi_cdc_tx_send+0x52>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
80003676:	58 07       	cp.w	r7,0
80003678:	5f 07       	sreq	r7
	}
	udi_cdc_tx_trans_ongoing = true;
8000367a:	30 1a       	mov	r10,1
8000367c:	49 69       	lddpc	r9,800036d4 <udi_cdc_tx_send+0xac>
8000367e:	b2 8a       	st.b	r9[0x0],r10
   // Don't work with sysreg_write(AVR32_SR, flags)
   if( cpu_irq_is_enabled_flags(flags) ) {
      cpu_irq_enable();
   }
#else
	sysreg_write(AVR32_SR, flags);
80003680:	e3 b8 00 00 	mtsr	0x0,r8
	cpu_irq_restore(flags);

	b_short_packet = (udi_cdc_tx_buf_nb[buf_sel_trans] != UDI_CDC_TX_BUFFERS);
80003684:	0e 95       	mov	r5,r7
80003686:	49 b8       	lddpc	r8,800036f0 <udi_cdc_tx_send+0xc8>
80003688:	f0 07 04 19 	ld.sh	r9,r8[r7<<0x1]
8000368c:	34 08       	mov	r8,64
8000368e:	f0 09 19 00 	cp.h	r9,r8
80003692:	5f 16       	srne	r6
	if (b_short_packet) {
80003694:	58 06       	cp.w	r6,0
80003696:	c0 e0       	breq	800036b2 <udi_cdc_tx_send+0x8a>
		if (udd_is_high_speed()) {
80003698:	f0 1f 00 10 	mcall	800036d8 <udi_cdc_tx_send+0xb0>
8000369c:	c0 60       	breq	800036a8 <udi_cdc_tx_send+0x80>
			udi_cdc_tx_sof_num = udd_get_micro_frame_number();
8000369e:	f0 1f 00 10 	mcall	800036dc <udi_cdc_tx_send+0xb4>
800036a2:	49 08       	lddpc	r8,800036e0 <udi_cdc_tx_send+0xb8>
800036a4:	b0 0c       	st.h	r8[0x0],r12
800036a6:	c0 98       	rjmp	800036b8 <udi_cdc_tx_send+0x90>
		}else{
			udi_cdc_tx_sof_num = udd_get_frame_number();
800036a8:	f0 1f 00 0f 	mcall	800036e4 <udi_cdc_tx_send+0xbc>
800036ac:	48 d8       	lddpc	r8,800036e0 <udi_cdc_tx_send+0xb8>
800036ae:	b0 0c       	st.h	r8[0x0],r12
800036b0:	c0 48       	rjmp	800036b8 <udi_cdc_tx_send+0x90>
		}
	}else{
		udi_cdc_tx_sof_num = 0; // Force next transfer without wait SOF
800036b2:	30 09       	mov	r9,0
800036b4:	48 b8       	lddpc	r8,800036e0 <udi_cdc_tx_send+0xb8>
800036b6:	b0 09       	st.h	r8[0x0],r9
	}

	// Send the buffer with enable of short packet
	udd_ep_run( UDI_CDC_DATA_EP_IN,
800036b8:	a7 67       	lsl	r7,0x6
800036ba:	48 f8       	lddpc	r8,800036f4 <udi_cdc_tx_send+0xcc>
800036bc:	48 d9       	lddpc	r9,800036f0 <udi_cdc_tx_send+0xc8>
800036be:	f2 05 05 19 	ld.uh	r9,r9[r5<<0x1]
800036c2:	48 ea       	lddpc	r10,800036f8 <udi_cdc_tx_send+0xd0>
800036c4:	0e 0a       	add	r10,r7
800036c6:	0c 9b       	mov	r11,r6
800036c8:	e0 6c 00 81 	mov	r12,129
800036cc:	f0 1f 00 0c 	mcall	800036fc <udi_cdc_tx_send+0xd4>
800036d0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800036d4:	00 00       	add	r0,r0
800036d6:	07 fe       	ld.ub	lr,r3[0x7]
800036d8:	80 00       	ld.sh	r0,r0[0x0]
800036da:	24 1e       	sub	lr,65
800036dc:	80 00       	ld.sh	r0,r0[0x0]
800036de:	24 5a       	sub	r10,69
800036e0:	00 00       	add	r0,r0
800036e2:	07 fa       	ld.ub	r10,r3[0x7]
800036e4:	80 00       	ld.sh	r0,r0[0x0]
800036e6:	24 4e       	sub	lr,68
800036e8:	00 00       	add	r0,r0
800036ea:	07 6f       	ld.uh	pc,--r3
800036ec:	00 00       	add	r0,r0
800036ee:	08 81       	andn	r1,r4
800036f0:	00 00       	add	r0,r0
800036f2:	07 70       	ld.ub	r0,--r3
800036f4:	80 00       	ld.sh	r0,r0[0x0]
800036f6:	37 00       	mov	r0,112
800036f8:	00 00       	add	r0,r0
800036fa:	07 74       	ld.ub	r4,--r3
800036fc:	80 00       	ld.sh	r0,r0[0x0]
800036fe:	26 14       	sub	r4,97

80003700 <udi_cdc_data_sent>:
	udi_cdc_rx_start();
}


void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n)
{
80003700:	d4 01       	pushm	lr
	if (UDD_EP_TRANSFER_OK != status) {
80003702:	58 0c       	cp.w	r12,0
80003704:	c1 21       	brne	80003728 <udi_cdc_data_sent+0x28>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[(udi_cdc_tx_buf_sel==0)?1:0] = 0;
80003706:	48 a8       	lddpc	r8,8000372c <udi_cdc_data_sent+0x2c>
80003708:	11 88       	ld.ub	r8,r8[0x0]
8000370a:	58 08       	cp.w	r8,0
8000370c:	f9 b9 01 00 	movne	r9,0
80003710:	f9 b9 00 02 	moveq	r9,2
80003714:	30 08       	mov	r8,0
80003716:	48 7a       	lddpc	r10,80003730 <udi_cdc_data_sent+0x30>
80003718:	f4 09 0a 08 	st.h	r10[r9],r8
	udi_cdc_tx_both_buf_to_send = false;
8000371c:	48 69       	lddpc	r9,80003734 <udi_cdc_data_sent+0x34>
8000371e:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_trans_ongoing = false;
80003720:	48 69       	lddpc	r9,80003738 <udi_cdc_data_sent+0x38>
80003722:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_tx_send();
80003724:	f0 1f 00 06 	mcall	8000373c <udi_cdc_data_sent+0x3c>
80003728:	d8 02       	popm	pc
8000372a:	00 00       	add	r0,r0
8000372c:	00 00       	add	r0,r0
8000372e:	07 6f       	ld.uh	pc,--r3
80003730:	00 00       	add	r0,r0
80003732:	07 70       	ld.ub	r0,--r3
80003734:	00 00       	add	r0,r0
80003736:	08 81       	andn	r1,r4
80003738:	00 00       	add	r0,r0
8000373a:	07 fe       	ld.ub	lr,r3[0x7]
8000373c:	80 00       	ld.sh	r0,r0[0x0]
8000373e:	36 28       	mov	r8,98

80003740 <udi_cdc_data_sof_notify>:
{
	return 0;      // CDC don't have multiple alternate setting
}

void udi_cdc_data_sof_notify(void)
{
80003740:	d4 01       	pushm	lr
	udi_cdc_tx_send();
80003742:	f0 1f 00 02 	mcall	80003748 <udi_cdc_data_sof_notify+0x8>
}
80003746:	d8 02       	popm	pc
80003748:	80 00       	ld.sh	r0,r0[0x0]
8000374a:	36 28       	mov	r8,98

8000374c <udi_cdc_data_enable>:
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
}

bool udi_cdc_data_enable(void)
{
8000374c:	eb cd 40 c0 	pushm	r6-r7,lr
	// Initialize TX management
	udi_cdc_tx_trans_ongoing = false;
80003750:	30 06       	mov	r6,0
80003752:	48 f8       	lddpc	r8,8000378c <udi_cdc_data_enable+0x40>
80003754:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_both_buf_to_send = false;
80003756:	48 f8       	lddpc	r8,80003790 <udi_cdc_data_enable+0x44>
80003758:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_sel = 0;
8000375a:	48 f8       	lddpc	r8,80003794 <udi_cdc_data_enable+0x48>
8000375c:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_tx_buf_nb[0] = 0;
8000375e:	48 f8       	lddpc	r8,80003798 <udi_cdc_data_enable+0x4c>
80003760:	30 07       	mov	r7,0
80003762:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_buf_nb[1] = 0;
80003764:	b0 17       	st.h	r8[0x2],r7
	udi_cdc_tx_sof_num = 0;
80003766:	48 e8       	lddpc	r8,8000379c <udi_cdc_data_enable+0x50>
80003768:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_tx_send();
8000376a:	f0 1f 00 0e 	mcall	800037a0 <udi_cdc_data_enable+0x54>

	// Initialize RX management
	udi_cdc_rx_trans_ongoing = false;
8000376e:	48 e8       	lddpc	r8,800037a4 <udi_cdc_data_enable+0x58>
80003770:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_sel = 0;
80003772:	48 e8       	lddpc	r8,800037a8 <udi_cdc_data_enable+0x5c>
80003774:	b0 86       	st.b	r8[0x0],r6
	udi_cdc_rx_buf_nb[0] = 0;
80003776:	48 e8       	lddpc	r8,800037ac <udi_cdc_data_enable+0x60>
80003778:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_rx_pos = 0;
8000377a:	48 e8       	lddpc	r8,800037b0 <udi_cdc_data_enable+0x64>
8000377c:	b0 07       	st.h	r8[0x0],r7
	udi_cdc_running = udi_cdc_rx_start();
8000377e:	f0 1f 00 0e 	mcall	800037b4 <udi_cdc_data_enable+0x68>
80003782:	48 e8       	lddpc	r8,800037b8 <udi_cdc_data_enable+0x6c>
80003784:	b0 8c       	st.b	r8[0x0],r12
	return udi_cdc_running;
80003786:	11 8c       	ld.ub	r12,r8[0x0]
}
80003788:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000378c:	00 00       	add	r0,r0
8000378e:	07 fe       	ld.ub	lr,r3[0x7]
80003790:	00 00       	add	r0,r0
80003792:	08 81       	andn	r1,r4
80003794:	00 00       	add	r0,r0
80003796:	07 6f       	ld.uh	pc,--r3
80003798:	00 00       	add	r0,r0
8000379a:	07 70       	ld.ub	r0,--r3
8000379c:	00 00       	add	r0,r0
8000379e:	07 fa       	ld.ub	r10,r3[0x7]
800037a0:	80 00       	ld.sh	r0,r0[0x0]
800037a2:	36 28       	mov	r8,98
800037a4:	00 00       	add	r0,r0
800037a6:	08 80       	andn	r0,r4
800037a8:	00 00       	add	r0,r0
800037aa:	07 fc       	ld.ub	r12,r3[0x7]
800037ac:	00 00       	add	r0,r0
800037ae:	07 f4       	ld.ub	r4,r3[0x7]
800037b0:	00 00       	add	r0,r0
800037b2:	07 f8       	ld.ub	r8,r3[0x7]
800037b4:	80 00       	ld.sh	r0,r0[0x0]
800037b6:	34 f0       	mov	r0,79
800037b8:	00 00       	add	r0,r0
800037ba:	07 fd       	ld.ub	sp,r3[0x7]

800037bc <udi_cdc_comm_disable>:


void udi_cdc_comm_disable(void)
{
800037bc:	d4 01       	pushm	lr
	udi_cdc_running = false;
800037be:	30 09       	mov	r9,0
800037c0:	48 38       	lddpc	r8,800037cc <udi_cdc_comm_disable+0x10>
800037c2:	b0 89       	st.b	r8[0x0],r9
	UDI_CDC_DISABLE_EXT();
800037c4:	f0 1f 00 03 	mcall	800037d0 <udi_cdc_comm_disable+0x14>
}
800037c8:	d8 02       	popm	pc
800037ca:	00 00       	add	r0,r0
800037cc:	00 00       	add	r0,r0
800037ce:	07 fd       	ld.ub	sp,r3[0x7]
800037d0:	80 00       	ld.sh	r0,r0[0x0]
800037d2:	3f 84       	mov	r4,-8

800037d4 <udi_cdc_comm_enable>:

//@}


bool udi_cdc_comm_enable(void)
{
800037d4:	d4 01       	pushm	lr
	// Initialize control signal management
	udi_cdc_state = CPU_TO_LE16(0);
800037d6:	30 0a       	mov	r10,0
800037d8:	48 a8       	lddpc	r8,80003800 <udi_cdc_comm_enable+0x2c>
800037da:	b0 0a       	st.h	r8[0x0],r10
	uid_cdc_state_msg.value = CPU_TO_LE16(0);
800037dc:	48 a8       	lddpc	r8,80003804 <udi_cdc_comm_enable+0x30>
800037de:	b0 4a       	st.h	r8[0x8],r10

	udi_cdc_line_coding.dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
800037e0:	48 a8       	lddpc	r8,80003808 <udi_cdc_comm_enable+0x34>
800037e2:	30 09       	mov	r9,0
800037e4:	b0 8a       	st.b	r8[0x0],r10
800037e6:	3c 2a       	mov	r10,-62
800037e8:	b0 9a       	st.b	r8[0x1],r10
800037ea:	30 1a       	mov	r10,1
800037ec:	b0 aa       	st.b	r8[0x2],r10
800037ee:	b0 b9       	st.b	r8[0x3],r9
	udi_cdc_line_coding.bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
800037f0:	b0 c9       	st.b	r8[0x4],r9
	udi_cdc_line_coding.bParityType = UDI_CDC_DEFAULT_PARITY;
800037f2:	b0 d9       	st.b	r8[0x5],r9
	udi_cdc_line_coding.bDataBits = UDI_CDC_DEFAULT_DATABITS;
800037f4:	30 89       	mov	r9,8
800037f6:	b0 e9       	st.b	r8[0x6],r9
	UDI_CDC_SET_CODING_EXT((&udi_cdc_line_coding));

	// Call application callback
	// to initialize memories or indicate that interface is enabled
	return UDI_CDC_ENABLE_EXT();
800037f8:	f0 1f 00 05 	mcall	8000380c <udi_cdc_comm_enable+0x38>
}
800037fc:	d8 02       	popm	pc
800037fe:	00 00       	add	r0,r0
80003800:	00 00       	add	r0,r0
80003802:	08 82       	andn	r2,r4
80003804:	00 00       	add	r0,r0
80003806:	00 44       	or	r4,r0
80003808:	00 00       	add	r0,r0
8000380a:	07 68       	ld.uh	r8,--r3
8000380c:	80 00       	ld.sh	r0,r0[0x0]
8000380e:	3f 78       	mov	r8,-9

80003810 <udc_sof_notify>:
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}

void udc_sof_notify(void)
{
80003810:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
80003814:	49 18       	lddpc	r8,80003858 <udc_sof_notify+0x48>
80003816:	11 89       	ld.ub	r9,r8[0x0]
80003818:	30 08       	mov	r8,0
8000381a:	f0 09 18 00 	cp.b	r9,r8
8000381e:	c1 b0       	breq	80003854 <udc_sof_notify+0x44>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003820:	48 f8       	lddpc	r8,8000385c <udc_sof_notify+0x4c>
80003822:	70 08       	ld.w	r8,r8[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
80003824:	70 09       	ld.w	r9,r8[0x0]
80003826:	13 ca       	ld.ub	r10,r9[0x4]
80003828:	30 09       	mov	r9,0
8000382a:	f2 0a 18 00 	cp.b	r10,r9
8000382e:	c1 30       	breq	80003854 <udc_sof_notify+0x44>
80003830:	30 07       	mov	r7,0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003832:	48 b6       	lddpc	r6,8000385c <udc_sof_notify+0x4c>
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
80003834:	70 18       	ld.w	r8,r8[0x4]
80003836:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
8000383a:	70 48       	ld.w	r8,r8[0x10]
8000383c:	58 08       	cp.w	r8,0
8000383e:	c0 20       	breq	80003842 <udc_sof_notify+0x32>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
80003840:	5d 18       	icall	r8
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
80003842:	2f f7       	sub	r7,-1
80003844:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003846:	6c 08       	ld.w	r8,r6[0x0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
80003848:	70 09       	ld.w	r9,r8[0x0]
8000384a:	13 c9       	ld.ub	r9,r9[0x4]
8000384c:	ee 09 18 00 	cp.b	r9,r7
80003850:	fe 9b ff f2 	brhi	80003834 <udc_sof_notify+0x24>
80003854:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003858:	00 00       	add	r0,r0
8000385a:	08 8e       	andn	lr,r4
8000385c:	00 00       	add	r0,r0
8000385e:	08 88       	andn	r8,r4

80003860 <udc_get_eof_conf>:
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
80003860:	48 78       	lddpc	r8,8000387c <udc_get_eof_conf+0x1c>
80003862:	70 08       	ld.w	r8,r8[0x0]
80003864:	70 08       	ld.w	r8,r8[0x0]
80003866:	11 aa       	ld.ub	r10,r8[0x2]
80003868:	11 b9       	ld.ub	r9,r8[0x3]
8000386a:	f3 ea 10 89 	or	r9,r9,r10<<0x8
8000386e:	5c c9       	swap.bh	r9
80003870:	f9 d9 c0 10 	bfextu	r12,r9,0x0,0x10
}
80003874:	f0 0c 00 0c 	add	r12,r8,r12
80003878:	5e fc       	retal	r12
8000387a:	00 00       	add	r0,r0
8000387c:	00 00       	add	r0,r0
8000387e:	08 88       	andn	r8,r4

80003880 <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
80003880:	eb cd 40 e0 	pushm	r5-r7,lr
80003884:	18 97       	mov	r7,r12
80003886:	16 96       	mov	r6,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration)
80003888:	49 b8       	lddpc	r8,800038f4 <udc_update_iface_desc+0x74>
8000388a:	11 89       	ld.ub	r9,r8[0x0]
8000388c:	30 08       	mov	r8,0
8000388e:	f0 09 18 00 	cp.b	r9,r8
80003892:	c2 f0       	breq	800038f0 <udc_update_iface_desc+0x70>
		return false;

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003894:	49 98       	lddpc	r8,800038f8 <udc_update_iface_desc+0x78>
80003896:	70 08       	ld.w	r8,r8[0x0]
80003898:	70 08       	ld.w	r8,r8[0x0]
8000389a:	11 c9       	ld.ub	r9,r8[0x4]
8000389c:	18 9e       	mov	lr,r12
8000389e:	f8 09 18 00 	cp.b	r9,r12
800038a2:	e0 88 00 27 	brls	800038f0 <udc_update_iface_desc+0x70>
		return false;

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
800038a6:	49 65       	lddpc	r5,800038fc <udc_update_iface_desc+0x7c>
800038a8:	8b 08       	st.w	r5[0x0],r8
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
800038aa:	f0 1f 00 16 	mcall	80003900 <udc_update_iface_desc+0x80>
	while (ptr_end_desc >
800038ae:	6a 08       	ld.w	r8,r5[0x0]
800038b0:	10 3c       	cp.w	r12,r8
800038b2:	e0 88 00 1f 	brls	800038f0 <udc_update_iface_desc+0x70>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
800038b6:	30 4b       	mov	r11,4
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
800038b8:	10 99       	mov	r9,r8
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
800038ba:	11 9a       	ld.ub	r10,r8[0x1]
800038bc:	f6 0a 18 00 	cp.b	r10,r11
800038c0:	c0 a1       	brne	800038d4 <udc_update_iface_desc+0x54>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber)
800038c2:	11 aa       	ld.ub	r10,r8[0x2]
800038c4:	0e 9e       	mov	lr,r7
800038c6:	ee 0a 18 00 	cp.b	r10,r7
800038ca:	c0 51       	brne	800038d4 <udc_update_iface_desc+0x54>
					&& (setting_num ==
							udc_ptr_iface->
800038cc:	11 ba       	ld.ub	r10,r8[0x3]
800038ce:	ec 0a 18 00 	cp.b	r10,r6
800038d2:	c0 b0       	breq	800038e8 <udc_update_iface_desc+0x68>
							bAlternateSetting))
				return true;	// Interface found
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) ((uint8_t
800038d4:	13 88       	ld.ub	r8,r9[0x0]
800038d6:	f2 08 00 08 	add	r8,r9,r8
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
800038da:	10 3c       	cp.w	r12,r8
800038dc:	fe 9b ff ee 	brhi	800038b8 <udc_update_iface_desc+0x38>
800038e0:	48 79       	lddpc	r9,800038fc <udc_update_iface_desc+0x7c>
800038e2:	93 08       	st.w	r9[0x0],r8
800038e4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800038e8:	48 59       	lddpc	r9,800038fc <udc_update_iface_desc+0x7c>
800038ea:	93 08       	st.w	r9[0x0],r8
800038ec:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
800038f0:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800038f4:	00 00       	add	r0,r0
800038f6:	08 8e       	andn	lr,r4
800038f8:	00 00       	add	r0,r0
800038fa:	08 88       	andn	r8,r4
800038fc:	00 00       	add	r0,r0
800038fe:	08 94       	mov	r4,r4
80003900:	80 00       	ld.sh	r0,r0[0x0]
80003902:	38 60       	mov	r0,-122

80003904 <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
80003904:	eb cd 40 c0 	pushm	r6-r7,lr
80003908:	18 96       	mov	r6,r12
8000390a:	16 97       	mov	r7,r11
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
8000390c:	f0 1f 00 11 	mcall	80003950 <udc_next_desc_in_iface+0x4c>
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
80003910:	0d 88       	ld.ub	r8,r6[0x0]
80003912:	10 06       	add	r6,r8
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
80003914:	0c 3c       	cp.w	r12,r6
80003916:	e0 88 00 19 	brls	80003948 <udc_next_desc_in_iface+0x44>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
8000391a:	0d 98       	ld.ub	r8,r6[0x1]
8000391c:	30 49       	mov	r9,4
8000391e:	f2 08 18 00 	cp.b	r8,r9
80003922:	c1 30       	breq	80003948 <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
80003924:	ee 08 18 00 	cp.b	r8,r7
80003928:	c0 a1       	brne	8000393c <udc_next_desc_in_iface+0x38>
8000392a:	c1 08       	rjmp	8000394a <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
8000392c:	0d 98       	ld.ub	r8,r6[0x1]
8000392e:	f2 08 18 00 	cp.b	r8,r9
80003932:	c0 b0       	breq	80003948 <udc_next_desc_in_iface+0x44>
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
80003934:	ee 08 18 00 	cp.b	r8,r7
80003938:	c0 31       	brne	8000393e <udc_next_desc_in_iface+0x3a>
8000393a:	c0 88       	rjmp	8000394a <udc_next_desc_in_iface+0x46>
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType)
8000393c:	30 49       	mov	r9,4
			break;	// End of global interface descriptor
		if (desc_id == desc->bDescriptorType)
			return desc;	// Specific descriptor found
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
8000393e:	0d 88       	ld.ub	r8,r6[0x0]
80003940:	10 06       	add	r6,r8
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
80003942:	0c 3c       	cp.w	r12,r6
80003944:	fe 9b ff f4 	brhi	8000392c <udc_next_desc_in_iface+0x28>
80003948:	30 06       	mov	r6,0
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL;	// No specific descriptor found
}
8000394a:	0c 9c       	mov	r12,r6
8000394c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003950:	80 00       	ld.sh	r0,r0[0x0]
80003952:	38 60       	mov	r0,-122

80003954 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
80003954:	d4 01       	pushm	lr
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
80003956:	48 48       	lddpc	r8,80003964 <udc_valid_address+0x10>
80003958:	11 bc       	ld.ub	r12,r8[0x3]
8000395a:	f9 dc c0 07 	bfextu	r12,r12,0x0,0x7
8000395e:	f0 1f 00 03 	mcall	80003968 <udc_valid_address+0x14>
}
80003962:	d8 02       	popm	pc
80003964:	00 00       	add	r0,r0
80003966:	0a 10       	sub	r0,r5
80003968:	80 00       	ld.sh	r0,r0[0x0]
8000396a:	24 20       	sub	r0,66

8000396c <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
8000396c:	eb cd 40 e0 	pushm	r5-r7,lr
80003970:	18 95       	mov	r5,r12
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num))
80003972:	f0 1f 00 12 	mcall	800039b8 <udc_iface_enable+0x4c>
80003976:	c1 f0       	breq	800039b4 <udc_iface_enable+0x48>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
80003978:	49 18       	lddpc	r8,800039bc <udc_iface_enable+0x50>
8000397a:	70 07       	ld.w	r7,r8[0x0]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
8000397c:	30 56       	mov	r6,5
8000397e:	0c 9b       	mov	r11,r6
80003980:	0e 9c       	mov	r12,r7
80003982:	f0 1f 00 10 	mcall	800039c0 <udc_iface_enable+0x54>
80003986:	18 97       	mov	r7,r12
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
80003988:	c0 d0       	breq	800039a2 <udc_iface_enable+0x36>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
						ep_desc->bmAttributes,
						le16_to_cpu
8000398a:	19 ca       	ld.ub	r10,r12[0x4]
8000398c:	19 d8       	ld.ub	r8,r12[0x5]
8000398e:	f1 ea 10 8a 	or	r10,r8,r10<<0x8
80003992:	5c ca       	swap.bh	r10
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
80003994:	5c 7a       	castu.h	r10
80003996:	19 bb       	ld.ub	r11,r12[0x3]
80003998:	19 ac       	ld.ub	r12,r12[0x2]
8000399a:	f0 1f 00 0b 	mcall	800039c4 <udc_iface_enable+0x58>
8000399e:	cf 01       	brne	8000397e <udc_iface_enable+0x12>
800039a0:	c0 a8       	rjmp	800039b4 <udc_iface_enable+0x48>
						(ep_desc->wMaxPacketSize)))
			return false;
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
800039a2:	48 a8       	lddpc	r8,800039c8 <udc_iface_enable+0x5c>
800039a4:	70 08       	ld.w	r8,r8[0x0]
800039a6:	70 18       	ld.w	r8,r8[0x4]
800039a8:	f0 05 03 28 	ld.w	r8,r8[r5<<0x2]
800039ac:	70 0c       	ld.w	r12,r8[0x0]
800039ae:	5d 1c       	icall	r12
800039b0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800039b4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
800039b8:	80 00       	ld.sh	r0,r0[0x0]
800039ba:	38 80       	mov	r0,-120
800039bc:	00 00       	add	r0,r0
800039be:	08 94       	mov	r4,r4
800039c0:	80 00       	ld.sh	r0,r0[0x0]
800039c2:	39 04       	mov	r4,-112
800039c4:	80 00       	ld.sh	r0,r0[0x0]
800039c6:	29 6c       	sub	r12,-106
800039c8:	00 00       	add	r0,r0
800039ca:	08 88       	andn	r8,r4

800039cc <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
800039cc:	eb cd 40 e0 	pushm	r5-r7,lr
800039d0:	18 96       	mov	r6,r12
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
800039d2:	18 97       	mov	r7,r12
800039d4:	30 0b       	mov	r11,0
800039d6:	f0 1f 00 12 	mcall	80003a1c <udc_iface_disable+0x50>
800039da:	c1 e0       	breq	80003a16 <udc_iface_disable+0x4a>
		return false;

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
800039dc:	49 18       	lddpc	r8,80003a20 <udc_iface_disable+0x54>
800039de:	70 08       	ld.w	r8,r8[0x0]
800039e0:	70 18       	ld.w	r8,r8[0x4]
800039e2:	f0 06 03 25 	ld.w	r5,r8[r6<<0x2]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
800039e6:	6a 3c       	ld.w	r12,r5[0xc]
800039e8:	5d 1c       	icall	r12
800039ea:	18 9b       	mov	r11,r12
800039ec:	0c 9c       	mov	r12,r6
800039ee:	f0 1f 00 0c 	mcall	80003a1c <udc_iface_disable+0x50>
800039f2:	c1 20       	breq	80003a16 <udc_iface_disable+0x4a>
		return false;

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
800039f4:	48 c8       	lddpc	r8,80003a24 <udc_iface_disable+0x58>
800039f6:	70 07       	ld.w	r7,r8[0x0]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
800039f8:	30 56       	mov	r6,5
800039fa:	0c 9b       	mov	r11,r6
800039fc:	0e 9c       	mov	r12,r7
800039fe:	f0 1f 00 0b 	mcall	80003a28 <udc_iface_disable+0x5c>
80003a02:	18 97       	mov	r7,r12
					udc_next_desc_in_iface((UDC_DESC_STORAGE
							usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc)
80003a04:	c0 50       	breq	80003a0e <udc_iface_disable+0x42>
				break;
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
80003a06:	19 ac       	ld.ub	r12,r12[0x2]
80003a08:	f0 1f 00 09 	mcall	80003a2c <udc_iface_disable+0x60>
		}
80003a0c:	cf 7b       	rjmp	800039fa <udc_iface_disable+0x2e>
	}
#endif

	// Disable interface
	udi_api->disable();
80003a0e:	6a 18       	ld.w	r8,r5[0x4]
80003a10:	5d 18       	icall	r8
80003a12:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
	return true;
80003a16:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003a1a:	00 00       	add	r0,r0
80003a1c:	80 00       	ld.sh	r0,r0[0x0]
80003a1e:	38 80       	mov	r0,-120
80003a20:	00 00       	add	r0,r0
80003a22:	08 88       	andn	r8,r4
80003a24:	00 00       	add	r0,r0
80003a26:	08 94       	mov	r4,r4
80003a28:	80 00       	ld.sh	r0,r0[0x0]
80003a2a:	39 04       	mov	r4,-112
80003a2c:	80 00       	ld.sh	r0,r0[0x0]
80003a2e:	25 e4       	sub	r4,94

80003a30 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device, 
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
80003a30:	eb cd 40 c0 	pushm	r6-r7,lr
	uint8_t iface_num;

	if (udc_num_configuration) {
80003a34:	49 38       	lddpc	r8,80003a80 <udc_reset+0x50>
80003a36:	11 89       	ld.ub	r9,r8[0x0]
80003a38:	30 08       	mov	r8,0
80003a3a:	f0 09 18 00 	cp.b	r9,r8
80003a3e:	c1 70       	breq	80003a6c <udc_reset+0x3c>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003a40:	49 18       	lddpc	r8,80003a84 <udc_reset+0x54>
80003a42:	70 08       	ld.w	r8,r8[0x0]
80003a44:	70 08       	ld.w	r8,r8[0x0]
80003a46:	11 c9       	ld.ub	r9,r8[0x4]
80003a48:	30 08       	mov	r8,0
80003a4a:	f0 09 18 00 	cp.b	r9,r8
80003a4e:	c0 f0       	breq	80003a6c <udc_reset+0x3c>
80003a50:	30 07       	mov	r7,0
80003a52:	48 d6       	lddpc	r6,80003a84 <udc_reset+0x54>
				iface_num++) {
			udc_iface_disable(iface_num);
80003a54:	0e 9c       	mov	r12,r7
80003a56:	f0 1f 00 0d 	mcall	80003a88 <udc_reset+0x58>
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
80003a5a:	2f f7       	sub	r7,-1
80003a5c:	5c 57       	castu.b	r7
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003a5e:	6c 08       	ld.w	r8,r6[0x0]
80003a60:	70 08       	ld.w	r8,r8[0x0]
80003a62:	11 c8       	ld.ub	r8,r8[0x4]
80003a64:	ee 08 18 00 	cp.b	r8,r7
80003a68:	fe 9b ff f6 	brhi	80003a54 <udc_reset+0x24>
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
80003a6c:	30 09       	mov	r9,0
80003a6e:	48 58       	lddpc	r8,80003a80 <udc_reset+0x50>
80003a70:	b0 89       	st.b	r8[0x0],r9
	if (0 != (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status)) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
80003a72:	e0 69 01 00 	mov	r9,256
80003a76:	48 68       	lddpc	r8,80003a8c <udc_reset+0x5c>
80003a78:	b0 09       	st.h	r8[0x0],r9
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
80003a7a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003a7e:	00 00       	add	r0,r0
80003a80:	00 00       	add	r0,r0
80003a82:	08 8e       	andn	lr,r4
80003a84:	00 00       	add	r0,r0
80003a86:	08 88       	andn	r8,r4
80003a88:	80 00       	ld.sh	r0,r0[0x0]
80003a8a:	39 cc       	mov	r12,-100
80003a8c:	00 00       	add	r0,r0
80003a8e:	08 8c       	andn	r12,r4

80003a90 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
80003a90:	eb cd 40 e0 	pushm	r5-r7,lr
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
80003a94:	fe f8 04 3c 	ld.w	r8,pc[1084]
80003a98:	30 09       	mov	r9,0
80003a9a:	b0 69       	st.h	r8[0xc],r9
	udd_g_ctrlreq.callback = NULL;
80003a9c:	30 0a       	mov	r10,0
80003a9e:	91 4a       	st.w	r8[0x10],r10
	udd_g_ctrlreq.over_under_run = NULL;
80003aa0:	91 5a       	st.w	r8[0x14],r10

	if (Udd_setup_is_in()) {
80003aa2:	11 88       	ld.ub	r8,r8[0x0]
80003aa4:	10 9a       	mov	r10,r8
80003aa6:	f2 08 18 00 	cp.b	r8,r9
80003aaa:	c0 94       	brge	80003abc <udc_process_setup+0x2c>
		if (udd_g_ctrlreq.req.wLength == 0)
80003aac:	fe f9 04 24 	ld.w	r9,pc[1060]
80003ab0:	92 3b       	ld.sh	r11,r9[0x6]
80003ab2:	30 09       	mov	r9,0
80003ab4:	f2 0b 19 00 	cp.h	r11,r9
80003ab8:	e0 80 02 0a 	breq	80003ecc <udc_process_setup+0x43c>
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
80003abc:	10 99       	mov	r9,r8
80003abe:	e2 19 00 60 	andl	r9,0x60,COH
80003ac2:	e0 81 01 d9 	brne	80003e74 <udc_process_setup+0x3e4>
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
	if (Udd_setup_is_in()) {
80003ac6:	f2 0a 18 00 	cp.b	r10,r9
80003aca:	e0 84 01 01 	brge	80003ccc <udc_process_setup+0x23c>
		// GET Standard Requests 
		if (udd_g_ctrlreq.req.wLength == 0)
80003ace:	fe f9 04 02 	ld.w	r9,pc[1026]
80003ad2:	92 39       	ld.sh	r9,r9[0x6]
80003ad4:	58 09       	cp.w	r9,0
80003ad6:	e0 80 01 cf 	breq	80003e74 <udc_process_setup+0x3e4>
			return false;	// Error for USB host

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003ada:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003ade:	e0 81 00 9e 	brne	80003c1a <udc_process_setup+0x18a>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003ae2:	fe fa 03 ee 	ld.w	r10,pc[1006]
80003ae6:	15 9a       	ld.ub	r10,r10[0x1]
80003ae8:	30 6b       	mov	r11,6
80003aea:	f6 0a 18 00 	cp.b	r10,r11
80003aee:	c1 a0       	breq	80003b22 <udc_process_setup+0x92>
80003af0:	30 8b       	mov	r11,8
80003af2:	f6 0a 18 00 	cp.b	r10,r11
80003af6:	e0 80 00 85 	breq	80003c00 <udc_process_setup+0x170>
80003afa:	30 0b       	mov	r11,0
80003afc:	f6 0a 18 00 	cp.b	r10,r11
80003b00:	e0 81 00 8d 	brne	80003c1a <udc_process_setup+0x18a>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status))
80003b04:	30 28       	mov	r8,2
80003b06:	f0 09 19 00 	cp.h	r9,r8
80003b0a:	c0 40       	breq	80003b12 <udc_process_setup+0x82>
80003b0c:	30 0c       	mov	r12,0
80003b0e:	e0 8f 01 af 	bral	80003e6c <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(
80003b12:	30 2b       	mov	r11,2
80003b14:	fe fc 03 c0 	ld.w	r12,pc[960]
80003b18:	f0 1f 00 f0 	mcall	80003ed8 <udc_process_setup+0x448>
80003b1c:	30 1c       	mov	r12,1
80003b1e:	e0 8f 01 a7 	bral	80003e6c <udc_process_setup+0x3dc>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003b22:	fe f8 03 ae 	ld.w	r8,pc[942]
80003b26:	90 19       	ld.sh	r9,r8[0x2]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
80003b28:	f2 08 16 08 	lsr	r8,r9,0x8
80003b2c:	30 2a       	mov	r10,2
80003b2e:	f4 08 18 00 	cp.b	r8,r10
80003b32:	c1 00       	breq	80003b52 <udc_process_setup+0xc2>
80003b34:	30 3a       	mov	r10,3
80003b36:	f4 08 18 00 	cp.b	r8,r10
80003b3a:	c2 a0       	breq	80003b8e <udc_process_setup+0xfe>
80003b3c:	30 19       	mov	r9,1
80003b3e:	f2 08 18 00 	cp.b	r8,r9
80003b42:	c5 d1       	brne	80003bfc <udc_process_setup+0x16c>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
80003b44:	fe f8 03 98 	ld.w	r8,pc[920]
80003b48:	70 0c       	ld.w	r12,r8[0x0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
80003b4a:	19 8b       	ld.ub	r11,r12[0x0]
80003b4c:	f0 1f 00 e3 	mcall	80003ed8 <udc_process_setup+0x448>
80003b50:	c4 78       	rjmp	80003bde <udc_process_setup+0x14e>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80003b52:	5c 59       	castu.b	r9
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
80003b54:	fe f8 03 88 	ld.w	r8,pc[904]
80003b58:	70 08       	ld.w	r8,r8[0x0]
80003b5a:	f1 38 00 11 	ld.ub	r8,r8[17]
80003b5e:	f2 08 18 00 	cp.b	r8,r9
80003b62:	e0 88 00 4d 	brls	80003bfc <udc_process_setup+0x16c>
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
80003b66:	fe f8 03 76 	ld.w	r8,pc[886]
80003b6a:	70 18       	ld.w	r8,r8[0x4]
80003b6c:	f0 09 03 3c 	ld.w	r12,r8[r9<<0x3]
80003b70:	19 a9       	ld.ub	r9,r12[0x2]
80003b72:	19 b8       	ld.ub	r8,r12[0x3]
80003b74:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80003b78:	5c c8       	swap.bh	r8
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations)
				return false;
			udd_set_setup_payload(
80003b7a:	f7 d8 c0 10 	bfextu	r11,r8,0x0,0x10
80003b7e:	f0 1f 00 d7 	mcall	80003ed8 <udc_process_setup+0x448>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
80003b82:	fe f8 03 4e 	ld.w	r8,pc[846]
80003b86:	70 28       	ld.w	r8,r8[0x8]
80003b88:	30 29       	mov	r9,2
80003b8a:	b0 99       	st.b	r8[0x1],r9
80003b8c:	c2 98       	rjmp	80003bde <udc_process_setup+0x14e>
	uint8_t i;
	uint8_t *str;
	uint8_t str_lgt=0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
80003b8e:	5c 59       	castu.b	r9
80003b90:	58 19       	cp.w	r9,1
80003b92:	c1 00       	breq	80003bb2 <udc_process_setup+0x122>
80003b94:	58 29       	cp.w	r9,2
80003b96:	c0 40       	breq	80003b9e <udc_process_setup+0x10e>
80003b98:	58 09       	cp.w	r9,0
80003b9a:	c0 60       	breq	80003ba6 <udc_process_setup+0x116>
80003b9c:	c3 08       	rjmp	80003bfc <udc_process_setup+0x16c>
80003b9e:	fe fc 03 42 	ld.w	r12,pc[834]
80003ba2:	30 3b       	mov	r11,3
80003ba4:	c0 a8       	rjmp	80003bb8 <udc_process_setup+0x128>
	case 0:
		udd_set_setup_payload(
80003ba6:	30 4b       	mov	r11,4
80003ba8:	fe fc 03 3c 	ld.w	r12,pc[828]
80003bac:	f0 1f 00 cb 	mcall	80003ed8 <udc_process_setup+0x448>
80003bb0:	c1 78       	rjmp	80003bde <udc_process_setup+0x14e>
80003bb2:	fe fc 03 36 	ld.w	r12,pc[822]
80003bb6:	30 9b       	mov	r11,9
80003bb8:	fe fa 03 34 	ld.w	r10,pc[820]
80003bbc:	2f ea       	sub	r10,-2
80003bbe:	18 98       	mov	r8,r12
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
80003bc0:	11 39       	ld.ub	r9,r8++
80003bc2:	5c c9       	swap.bh	r9
80003bc4:	14 b9       	st.h	r10++,r9
#endif
		return false;
	}

	if (str_lgt != 0) {
		for(i = 0; i < str_lgt; i++) {
80003bc6:	f0 0c 01 09 	sub	r9,r8,r12
80003bca:	f6 09 18 00 	cp.b	r9,r11
80003bce:	cf 93       	brcs	80003bc0 <udc_process_setup+0x130>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}
		
		udc_string_desc.header.bLength = 2 + (str_lgt) * 2;
80003bd0:	a1 7b       	lsl	r11,0x1
80003bd2:	2f eb       	sub	r11,-2
80003bd4:	fe fc 03 18 	ld.w	r12,pc[792]
80003bd8:	b8 8b       	st.b	r12[0x0],r11
		udd_set_setup_payload(
80003bda:	f0 1f 00 c0 	mcall	80003ed8 <udc_process_setup+0x448>
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size)
80003bde:	fe f8 02 f2 	ld.w	r8,pc[754]
80003be2:	90 39       	ld.sh	r9,r8[0x6]
80003be4:	90 68       	ld.sh	r8,r8[0xc]
80003be6:	f2 08 19 00 	cp.h	r8,r9
80003bea:	e0 8b 00 04 	brhi	80003bf2 <udc_process_setup+0x162>
80003bee:	30 1c       	mov	r12,1
80003bf0:	c3 e9       	rjmp	80003e6c <udc_process_setup+0x3dc>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
80003bf2:	fe f8 02 de 	ld.w	r8,pc[734]
80003bf6:	b0 69       	st.h	r8[0xc],r9
80003bf8:	30 1c       	mov	r12,1
80003bfa:	c3 99       	rjmp	80003e6c <udc_process_setup+0x3dc>
80003bfc:	30 0c       	mov	r12,0
80003bfe:	c3 79       	rjmp	80003e6c <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1)
80003c00:	30 18       	mov	r8,1
80003c02:	f0 09 19 00 	cp.h	r9,r8
80003c06:	c0 30       	breq	80003c0c <udc_process_setup+0x17c>
80003c08:	30 0c       	mov	r12,0
80003c0a:	c3 19       	rjmp	80003e6c <udc_process_setup+0x3dc>
		return false;

	udd_set_setup_payload(&udc_num_configuration,1);
80003c0c:	30 1b       	mov	r11,1
80003c0e:	fe fc 02 e2 	ld.w	r12,pc[738]
80003c12:	f0 1f 00 b2 	mcall	80003ed8 <udc_process_setup+0x448>
80003c16:	30 1c       	mov	r12,1
80003c18:	c2 a9       	rjmp	80003e6c <udc_process_setup+0x3dc>
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003c1a:	58 18       	cp.w	r8,1
80003c1c:	c3 61       	brne	80003c88 <udc_process_setup+0x1f8>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c1e:	fe fa 02 b2 	ld.w	r10,pc[690]
80003c22:	15 9b       	ld.ub	r11,r10[0x1]
80003c24:	30 aa       	mov	r10,10
80003c26:	f4 0b 18 00 	cp.b	r11,r10
80003c2a:	c2 f1       	brne	80003c88 <udc_process_setup+0x1f8>
{
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1)
80003c2c:	f0 09 19 00 	cp.h	r9,r8
80003c30:	c2 a1       	brne	80003c84 <udc_process_setup+0x1f4>
		return false;	// Error in request
	if (!udc_num_configuration)
80003c32:	fe f8 02 be 	ld.w	r8,pc[702]
80003c36:	11 89       	ld.ub	r9,r8[0x0]
80003c38:	30 08       	mov	r8,0
80003c3a:	f0 09 18 00 	cp.b	r9,r8
80003c3e:	c2 30       	breq	80003c84 <udc_process_setup+0x1f4>
		return false;	// The device is not is configured state yet

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003c40:	fe f8 02 90 	ld.w	r8,pc[656]
80003c44:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003c46:	fe f8 02 ae 	ld.w	r8,pc[686]
80003c4a:	70 08       	ld.w	r8,r8[0x0]
80003c4c:	70 08       	ld.w	r8,r8[0x0]
80003c4e:	11 c8       	ld.ub	r8,r8[0x4]
80003c50:	ee 08 18 00 	cp.b	r8,r7
80003c54:	e0 88 00 18 	brls	80003c84 <udc_process_setup+0x1f4>
		return false;

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003c58:	30 0b       	mov	r11,0
80003c5a:	0e 9c       	mov	r12,r7
80003c5c:	f0 1f 00 a7 	mcall	80003ef8 <udc_process_setup+0x468>
80003c60:	c1 20       	breq	80003c84 <udc_process_setup+0x1f4>
		return false;
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
	udc_iface_setting = udi_api->getsetting();
80003c62:	fe f8 02 92 	ld.w	r8,pc[658]
80003c66:	70 08       	ld.w	r8,r8[0x0]
80003c68:	70 18       	ld.w	r8,r8[0x4]
80003c6a:	f0 07 03 28 	ld.w	r8,r8[r7<<0x2]
80003c6e:	70 3c       	ld.w	r12,r8[0xc]
80003c70:	5d 1c       	icall	r12
80003c72:	fe f8 02 8a 	ld.w	r8,pc[650]
80003c76:	b0 8c       	st.b	r8[0x0],r12
	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
80003c78:	30 1b       	mov	r11,1
80003c7a:	10 9c       	mov	r12,r8
80003c7c:	f0 1f 00 97 	mcall	80003ed8 <udc_process_setup+0x448>
80003c80:	30 1c       	mov	r12,1
80003c82:	cf 58       	rjmp	80003e6c <udc_process_setup+0x3dc>
80003c84:	30 0c       	mov	r12,0
80003c86:	cf 38       	rjmp	80003e6c <udc_process_setup+0x3dc>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003c88:	58 28       	cp.w	r8,2
80003c8a:	e0 81 00 f5 	brne	80003e74 <udc_process_setup+0x3e4>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003c8e:	fe f8 02 42 	ld.w	r8,pc[578]
80003c92:	11 9a       	ld.ub	r10,r8[0x1]
80003c94:	30 08       	mov	r8,0
80003c96:	f0 0a 18 00 	cp.b	r10,r8
80003c9a:	e0 81 00 e8 	brne	80003e6a <udc_process_setup+0x3da>
 */
static bool udc_req_std_ep_get_status(void)
{
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status))
80003c9e:	30 28       	mov	r8,2
80003ca0:	f0 09 19 00 	cp.h	r9,r8
80003ca4:	c0 30       	breq	80003caa <udc_process_setup+0x21a>
80003ca6:	30 0c       	mov	r12,0
80003ca8:	ce 28       	rjmp	80003e6c <udc_process_setup+0x3dc>
		return false;

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
80003caa:	fe f8 02 26 	ld.w	r8,pc[550]
80003cae:	11 dc       	ld.ub	r12,r8[0x5]
80003cb0:	f0 1f 00 94 	mcall	80003f00 <udc_process_setup+0x470>
80003cb4:	e0 68 01 00 	mov	r8,256
80003cb8:	f9 b8 00 00 	moveq	r8,0
80003cbc:	fe fc 02 48 	ld.w	r12,pc[584]
80003cc0:	b8 08       	st.h	r12[0x0],r8
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload(
80003cc2:	30 2b       	mov	r11,2
80003cc4:	f0 1f 00 85 	mcall	80003ed8 <udc_process_setup+0x448>
80003cc8:	30 1c       	mov	r12,1
80003cca:	cd 18       	rjmp	80003e6c <udc_process_setup+0x3dc>
			}
		}
#endif
	} else {
		// SET Standard Requests  
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80003ccc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003cd0:	c7 71       	brne	80003dbe <udc_process_setup+0x32e>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80003cd2:	fe f9 01 fe 	ld.w	r9,pc[510]
80003cd6:	13 99       	ld.ub	r9,r9[0x1]
80003cd8:	30 3a       	mov	r10,3
80003cda:	f4 09 18 00 	cp.b	r9,r10
80003cde:	e0 80 00 c6 	breq	80003e6a <udc_process_setup+0x3da>
80003ce2:	e0 8b 00 07 	brhi	80003cf0 <udc_process_setup+0x260>
80003ce6:	30 1a       	mov	r10,1
80003ce8:	f4 09 18 00 	cp.b	r9,r10
80003cec:	c6 91       	brne	80003dbe <udc_process_setup+0x32e>
80003cee:	c1 78       	rjmp	80003d1c <udc_process_setup+0x28c>
80003cf0:	30 5a       	mov	r10,5
80003cf2:	f4 09 18 00 	cp.b	r9,r10
80003cf6:	c0 60       	breq	80003d02 <udc_process_setup+0x272>
80003cf8:	30 9a       	mov	r10,9
80003cfa:	f4 09 18 00 	cp.b	r9,r10
80003cfe:	c6 01       	brne	80003dbe <udc_process_setup+0x32e>
80003d00:	c2 28       	rjmp	80003d44 <udc_process_setup+0x2b4>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003d02:	4f 48       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003d04:	90 39       	ld.sh	r9,r8[0x6]
80003d06:	30 08       	mov	r8,0
80003d08:	f0 09 19 00 	cp.h	r9,r8
80003d0c:	c0 30       	breq	80003d12 <udc_process_setup+0x282>
80003d0e:	30 0c       	mov	r12,0
80003d10:	ca e8       	rjmp	80003e6c <udc_process_setup+0x3dc>
		return false;

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
80003d12:	4f e9       	lddpc	r9,80003f08 <udc_process_setup+0x478>
80003d14:	4e f8       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003d16:	91 49       	st.w	r8[0x10],r9
80003d18:	30 1c       	mov	r12,1
80003d1a:	ca 98       	rjmp	80003e6c <udc_process_setup+0x3dc>
 *
 * \return true if success 
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003d1c:	4e d8       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003d1e:	90 39       	ld.sh	r9,r8[0x6]
80003d20:	30 08       	mov	r8,0
80003d22:	f0 09 19 00 	cp.h	r9,r8
80003d26:	c0 d1       	brne	80003d40 <udc_process_setup+0x2b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
80003d28:	4e a8       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003d2a:	90 19       	ld.sh	r9,r8[0x2]
80003d2c:	30 18       	mov	r8,1
80003d2e:	f0 09 19 00 	cp.h	r9,r8
80003d32:	c0 71       	brne	80003d40 <udc_process_setup+0x2b0>
		udc_device_status &= CPU_TO_LE16(~USB_DEV_STATUS_REMOTEWAKEUP);
80003d34:	4e 88       	lddpc	r8,80003ed4 <udc_process_setup+0x444>
80003d36:	90 09       	ld.sh	r9,r8[0x0]
80003d38:	a9 d9       	cbr	r9,0x9
80003d3a:	b0 09       	st.h	r8[0x0],r9
80003d3c:	30 1c       	mov	r12,1
80003d3e:	c9 78       	rjmp	80003e6c <udc_process_setup+0x3dc>
80003d40:	30 0c       	mov	r12,0
80003d42:	c9 58       	rjmp	80003e6c <udc_process_setup+0x3dc>
static bool udc_req_std_dev_set_configuration(void)
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength != 0)
80003d44:	4e 38       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003d46:	90 39       	ld.sh	r9,r8[0x6]
80003d48:	30 08       	mov	r8,0
80003d4a:	f0 09 19 00 	cp.h	r9,r8
80003d4e:	c3 41       	brne	80003db6 <udc_process_setup+0x326>
		return false;
	// Authorize configuration only if the address is valid
	if (!udd_getaddress())
80003d50:	f0 1f 00 6f 	mcall	80003f0c <udc_process_setup+0x47c>
80003d54:	c3 10       	breq	80003db6 <udc_process_setup+0x326>
			return false;
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80003d56:	4d f8       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003d58:	11 b9       	ld.ub	r9,r8[0x3]
80003d5a:	4e 18       	lddpc	r8,80003edc <udc_process_setup+0x44c>
80003d5c:	70 08       	ld.w	r8,r8[0x0]
80003d5e:	f1 38 00 11 	ld.ub	r8,r8[17]
80003d62:	10 39       	cp.w	r9,r8
80003d64:	e0 89 00 29 	brgt	80003db6 <udc_process_setup+0x326>
				udc_config.confdev_lsfs->bNumConfigurations)
			return false;
	}

	// Reset current configuration
	udc_reset();
80003d68:	f0 1f 00 6a 	mcall	80003f10 <udc_process_setup+0x480>

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
80003d6c:	4d 98       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003d6e:	11 b8       	ld.ub	r8,r8[0x3]
80003d70:	4e 09       	lddpc	r9,80003ef0 <udc_process_setup+0x460>
80003d72:	b2 88       	st.b	r9[0x0],r8
	if (udc_num_configuration == 0) {
80003d74:	58 08       	cp.w	r8,0
80003d76:	c2 20       	breq	80003dba <udc_process_setup+0x32a>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
80003d78:	20 18       	sub	r8,1
80003d7a:	4d 99       	lddpc	r9,80003edc <udc_process_setup+0x44c>
80003d7c:	72 19       	ld.w	r9,r9[0x4]
80003d7e:	f2 08 00 38 	add	r8,r9,r8<<0x3
80003d82:	4d d9       	lddpc	r9,80003ef4 <udc_process_setup+0x464>
80003d84:	93 08       	st.w	r9[0x0],r8
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d86:	70 08       	ld.w	r8,r8[0x0]
80003d88:	11 c9       	ld.ub	r9,r8[0x4]
80003d8a:	30 08       	mov	r8,0
80003d8c:	f0 09 18 00 	cp.b	r9,r8
80003d90:	c1 50       	breq	80003dba <udc_process_setup+0x32a>
80003d92:	30 07       	mov	r7,0
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003d94:	0e 95       	mov	r5,r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003d96:	4d 86       	lddpc	r6,80003ef4 <udc_process_setup+0x464>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0))
80003d98:	0a 9b       	mov	r11,r5
80003d9a:	0e 9c       	mov	r12,r7
80003d9c:	f0 1f 00 5e 	mcall	80003f14 <udc_process_setup+0x484>
80003da0:	c0 b0       	breq	80003db6 <udc_process_setup+0x326>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
80003da2:	2f f7       	sub	r7,-1
80003da4:	5c 57       	castu.b	r7
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80003da6:	6c 08       	ld.w	r8,r6[0x0]
80003da8:	70 08       	ld.w	r8,r8[0x0]
80003daa:	11 c8       	ld.ub	r8,r8[0x4]
80003dac:	ee 08 18 00 	cp.b	r8,r7
80003db0:	fe 9b ff f4 	brhi	80003d98 <udc_process_setup+0x308>
80003db4:	c0 38       	rjmp	80003dba <udc_process_setup+0x32a>
80003db6:	30 0c       	mov	r12,0
80003db8:	c5 a8       	rjmp	80003e6c <udc_process_setup+0x3dc>
80003dba:	30 1c       	mov	r12,1
80003dbc:	c5 88       	rjmp	80003e6c <udc_process_setup+0x3dc>
				/* Not supported (defined as optional by the USB 2.0 spec) */
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
80003dbe:	58 18       	cp.w	r8,1
80003dc0:	c2 21       	brne	80003e04 <udc_process_setup+0x374>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80003dc2:	4c 49       	lddpc	r9,80003ed0 <udc_process_setup+0x440>
80003dc4:	13 9a       	ld.ub	r10,r9[0x1]
80003dc6:	30 b9       	mov	r9,11
80003dc8:	f2 0a 18 00 	cp.b	r10,r9
80003dcc:	c1 c1       	brne	80003e04 <udc_process_setup+0x374>
 */
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength != 0)
80003dce:	4c 18       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003dd0:	90 39       	ld.sh	r9,r8[0x6]
80003dd2:	30 08       	mov	r8,0
80003dd4:	f0 09 19 00 	cp.h	r9,r8
80003dd8:	c1 41       	brne	80003e00 <udc_process_setup+0x370>
		return false;	// Error in request
	if (!udc_num_configuration)
80003dda:	4c 68       	lddpc	r8,80003ef0 <udc_process_setup+0x460>
80003ddc:	11 89       	ld.ub	r9,r8[0x0]
80003dde:	30 08       	mov	r8,0
80003de0:	f0 09 18 00 	cp.b	r9,r8
80003de4:	c0 e0       	breq	80003e00 <udc_process_setup+0x370>
		return false;	// The device is not is configured state yet


	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
80003de6:	4b b8       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003de8:	90 16       	ld.sh	r6,r8[0x2]

	// Disable current setting
	if (!udc_iface_disable(iface_num))
80003dea:	11 d7       	ld.ub	r7,r8[0x5]
80003dec:	0e 9c       	mov	r12,r7
80003dee:	f0 1f 00 4b 	mcall	80003f18 <udc_process_setup+0x488>
80003df2:	c0 70       	breq	80003e00 <udc_process_setup+0x370>
		return false;

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
80003df4:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80003df8:	0e 9c       	mov	r12,r7
80003dfa:	f0 1f 00 47 	mcall	80003f14 <udc_process_setup+0x484>
80003dfe:	c3 78       	rjmp	80003e6c <udc_process_setup+0x3dc>
80003e00:	30 0c       	mov	r12,0
80003e02:	c3 58       	rjmp	80003e6c <udc_process_setup+0x3dc>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80003e04:	58 28       	cp.w	r8,2
80003e06:	c3 71       	brne	80003e74 <udc_process_setup+0x3e4>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80003e08:	4b 28       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003e0a:	11 98       	ld.ub	r8,r8[0x1]
80003e0c:	30 19       	mov	r9,1
80003e0e:	f2 08 18 00 	cp.b	r8,r9
80003e12:	c0 60       	breq	80003e1e <udc_process_setup+0x38e>
80003e14:	30 39       	mov	r9,3
80003e16:	f2 08 18 00 	cp.b	r8,r9
80003e1a:	c2 81       	brne	80003e6a <udc_process_setup+0x3da>
80003e1c:	c1 48       	rjmp	80003e44 <udc_process_setup+0x3b4>
 *
 * \return true if success 
 */
static bool udc_req_std_ep_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003e1e:	4a d8       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003e20:	90 39       	ld.sh	r9,r8[0x6]
80003e22:	30 08       	mov	r8,0
80003e24:	f0 09 19 00 	cp.h	r9,r8
80003e28:	c0 c1       	brne	80003e40 <udc_process_setup+0x3b0>
		return false;

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003e2a:	4a a8       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003e2c:	90 19       	ld.sh	r9,r8[0x2]
80003e2e:	30 08       	mov	r8,0
80003e30:	f0 09 19 00 	cp.h	r9,r8
80003e34:	c0 61       	brne	80003e40 <udc_process_setup+0x3b0>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003e36:	4a 78       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003e38:	11 dc       	ld.ub	r12,r8[0x5]
80003e3a:	f0 1f 00 39 	mcall	80003f1c <udc_process_setup+0x48c>
80003e3e:	c1 78       	rjmp	80003e6c <udc_process_setup+0x3dc>
80003e40:	30 0c       	mov	r12,0
80003e42:	c1 58       	rjmp	80003e6c <udc_process_setup+0x3dc>
 * \return true if success 
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_epset_feature(void)
{
	if (udd_g_ctrlreq.req.wLength != 0)
80003e44:	4a 38       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003e46:	90 39       	ld.sh	r9,r8[0x6]
80003e48:	30 08       	mov	r8,0
80003e4a:	f0 09 19 00 	cp.h	r9,r8
80003e4e:	c0 c1       	brne	80003e66 <udc_process_setup+0x3d6>
		return false;
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80003e50:	4a 08       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003e52:	90 19       	ld.sh	r9,r8[0x2]
80003e54:	30 08       	mov	r8,0
80003e56:	f0 09 19 00 	cp.h	r9,r8
80003e5a:	c0 61       	brne	80003e66 <udc_process_setup+0x3d6>
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80003e5c:	49 d8       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003e5e:	11 dc       	ld.ub	r12,r8[0x5]
80003e60:	f0 1f 00 30 	mcall	80003f20 <udc_process_setup+0x490>
80003e64:	c0 48       	rjmp	80003e6c <udc_process_setup+0x3dc>
80003e66:	30 0c       	mov	r12,0
80003e68:	c0 28       	rjmp	80003e6c <udc_process_setup+0x3dc>
80003e6a:	30 0c       	mov	r12,0
			return false;	// Error from USB host
	}
	
	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd())
80003e6c:	58 0c       	cp.w	r12,0
80003e6e:	c0 30       	breq	80003e74 <udc_process_setup+0x3e4>
80003e70:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
			return true;
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
80003e74:	49 78       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003e76:	11 88       	ld.ub	r8,r8[0x0]
80003e78:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80003e7c:	58 18       	cp.w	r8,1
80003e7e:	c2 71       	brne	80003ecc <udc_process_setup+0x43c>
static bool udc_req_iface(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration)
80003e80:	49 c8       	lddpc	r8,80003ef0 <udc_process_setup+0x460>
80003e82:	11 89       	ld.ub	r9,r8[0x0]
80003e84:	30 08       	mov	r8,0
80003e86:	f0 09 18 00 	cp.b	r9,r8
80003e8a:	c2 10       	breq	80003ecc <udc_process_setup+0x43c>
		return false;	// The device is not is configured state yet
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80003e8c:	49 18       	lddpc	r8,80003ed0 <udc_process_setup+0x440>
80003e8e:	11 d7       	ld.ub	r7,r8[0x5]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces)
80003e90:	49 98       	lddpc	r8,80003ef4 <udc_process_setup+0x464>
80003e92:	70 08       	ld.w	r8,r8[0x0]
80003e94:	70 08       	ld.w	r8,r8[0x0]
80003e96:	11 c8       	ld.ub	r8,r8[0x4]
80003e98:	ee 08 18 00 	cp.b	r8,r7
80003e9c:	e0 88 00 18 	brls	80003ecc <udc_process_setup+0x43c>
		return false;

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0))
80003ea0:	0e 96       	mov	r6,r7
80003ea2:	30 0b       	mov	r11,0
80003ea4:	0e 9c       	mov	r12,r7
80003ea6:	f0 1f 00 15 	mcall	80003ef8 <udc_process_setup+0x468>
80003eaa:	c1 10       	breq	80003ecc <udc_process_setup+0x43c>
		return false;
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80003eac:	49 28       	lddpc	r8,80003ef4 <udc_process_setup+0x464>
80003eae:	70 08       	ld.w	r8,r8[0x0]
80003eb0:	70 18       	ld.w	r8,r8[0x4]
80003eb2:	f0 07 03 27 	ld.w	r7,r8[r7<<0x2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting()))
80003eb6:	6e 3c       	ld.w	r12,r7[0xc]
80003eb8:	5d 1c       	icall	r12
80003eba:	18 9b       	mov	r11,r12
80003ebc:	0c 9c       	mov	r12,r6
80003ebe:	f0 1f 00 0f 	mcall	80003ef8 <udc_process_setup+0x468>
80003ec2:	c0 50       	breq	80003ecc <udc_process_setup+0x43c>
		return false;

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
80003ec4:	6e 2c       	ld.w	r12,r7[0x8]
80003ec6:	5d 1c       	icall	r12
80003ec8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003ecc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003ed0:	00 00       	add	r0,r0
80003ed2:	0a 10       	sub	r0,r5
80003ed4:	00 00       	add	r0,r0
80003ed6:	08 8c       	andn	r12,r4
80003ed8:	80 00       	ld.sh	r0,r0[0x0]
80003eda:	24 68       	sub	r8,70
80003edc:	00 00       	add	r0,r0
80003ede:	00 a4       	st.w	r0++,r4
80003ee0:	00 00       	add	r0,r0
80003ee2:	00 c0       	st.b	r0++,r0
80003ee4:	00 00       	add	r0,r0
80003ee6:	00 e4       	st.h	--r0,r4
80003ee8:	00 00       	add	r0,r0
80003eea:	00 c4       	st.b	r0++,r4
80003eec:	00 00       	add	r0,r0
80003eee:	00 d0       	st.w	--r0,r0
80003ef0:	00 00       	add	r0,r0
80003ef2:	08 8e       	andn	lr,r4
80003ef4:	00 00       	add	r0,r0
80003ef6:	08 88       	andn	r8,r4
80003ef8:	80 00       	ld.sh	r0,r0[0x0]
80003efa:	38 80       	mov	r0,-120
80003efc:	00 00       	add	r0,r0
80003efe:	08 84       	andn	r4,r4
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	24 74       	sub	r4,71
80003f04:	00 00       	add	r0,r0
80003f06:	08 90       	mov	r0,r4
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	39 54       	mov	r4,-107
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	24 42       	sub	r2,68
80003f10:	80 00       	ld.sh	r0,r0[0x0]
80003f12:	3a 30       	mov	r0,-93
80003f14:	80 00       	ld.sh	r0,r0[0x0]
80003f16:	39 6c       	mov	r12,-106
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	39 cc       	mov	r12,-100
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	25 04       	sub	r4,80
80003f20:	80 00       	ld.sh	r0,r0[0x0]
80003f22:	24 88       	sub	r8,72

80003f24 <_read>:
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80003f24:	eb cd 40 fc 	pushm	r2-r7,lr
80003f28:	20 1d       	sub	sp,4
80003f2a:	16 94       	mov	r4,r11
80003f2c:	14 95       	mov	r5,r10
	int nChars = 0;

	if (file != 0)
80003f2e:	58 0c       	cp.w	r12,0
80003f30:	c0 30       	breq	80003f36 <_read+0x12>
80003f32:	3f f7       	mov	r7,-1
80003f34:	c1 98       	rjmp	80003f66 <_read+0x42>
		return -1;

	for (; len > 0; --len) {
80003f36:	58 0a       	cp.w	r10,0
80003f38:	e0 89 00 04 	brgt	80003f40 <_read+0x1c>
80003f3c:	30 07       	mov	r7,0
80003f3e:	c1 48       	rjmp	80003f66 <_read+0x42>
80003f40:	30 07       	mov	r7,0
		int c;
		ptr_get(stdio_base,&c);
80003f42:	48 c3       	lddpc	r3,80003f70 <_read+0x4c>
80003f44:	48 c6       	lddpc	r6,80003f74 <_read+0x50>
80003f46:	1a 92       	mov	r2,sp
80003f48:	66 0c       	ld.w	r12,r3[0x0]
80003f4a:	6c 08       	ld.w	r8,r6[0x0]
80003f4c:	1a 9b       	mov	r11,sp
80003f4e:	5d 18       	icall	r8
		if (c < 0)
80003f50:	40 08       	lddsp	r8,sp[0x0]
80003f52:	58 08       	cp.w	r8,0
80003f54:	c0 95       	brlt	80003f66 <_read+0x42>
		break;
		*ptr++ = c;
80003f56:	e8 07 0b 08 	st.b	r4[r7],r8
		++nChars;
80003f5a:	2f f7       	sub	r7,-1
// GCC AVR32 implementation
#elif (defined(__GNUC__) && !defined(XMEGA))


int __attribute__((weak))
_read (int file, char * ptr, int len)
80003f5c:	ea 07 01 08 	sub	r8,r5,r7
	int nChars = 0;

	if (file != 0)
		return -1;

	for (; len > 0; --len) {
80003f60:	58 08       	cp.w	r8,0
80003f62:	fe 99 ff f3 	brgt	80003f48 <_read+0x24>
		break;
		*ptr++ = c;
		++nChars;
	}
	return nChars;
}
80003f66:	0e 9c       	mov	r12,r7
80003f68:	2f fd       	sub	sp,-4
80003f6a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80003f6e:	00 00       	add	r0,r0
80003f70:	00 00       	add	r0,r0
80003f72:	0a 38       	cp.w	r8,r5
80003f74:	00 00       	add	r0,r0
80003f76:	0a 30       	cp.w	r0,r5

80003f78 <stdio_usb_enable>:
	}
}

bool stdio_usb_enable(void)
{
	stdio_usb_interface_enable = true;
80003f78:	30 19       	mov	r9,1
80003f7a:	48 28       	lddpc	r8,80003f80 <stdio_usb_enable+0x8>
80003f7c:	b0 89       	st.b	r8[0x0],r9
	return true;
}
80003f7e:	5e ff       	retal	1
80003f80:	00 00       	add	r0,r0
80003f82:	08 98       	mov	r8,r4

80003f84 <stdio_usb_disable>:

void stdio_usb_disable(void)
{
	stdio_usb_interface_enable = false;
80003f84:	30 09       	mov	r9,0
80003f86:	48 28       	lddpc	r8,80003f8c <stdio_usb_disable+0x8>
80003f88:	b0 89       	st.b	r8[0x0],r9
}
80003f8a:	5e fc       	retal	r12
80003f8c:	00 00       	add	r0,r0
80003f8e:	08 98       	mov	r8,r4

80003f90 <stdio_usb_vbus_event>:
	
	*data = udi_cdc_getc ();
}

void stdio_usb_vbus_event(bool b_high)
{
80003f90:	d4 01       	pushm	lr
	if (b_high) {
80003f92:	58 0c       	cp.w	r12,0
80003f94:	c0 40       	breq	80003f9c <stdio_usb_vbus_event+0xc>
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
	udd_attach();
80003f96:	f0 1f 00 04 	mcall	80003fa4 <stdio_usb_vbus_event+0x14>
80003f9a:	d8 02       	popm	pc
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
	udd_detach();
80003f9c:	f0 1f 00 03 	mcall	80003fa8 <stdio_usb_vbus_event+0x18>
80003fa0:	d8 02       	popm	pc
80003fa2:	00 00       	add	r0,r0
80003fa4:	80 00       	ld.sh	r0,r0[0x0]
80003fa6:	2a fc       	sub	r12,-81
80003fa8:	80 00       	ld.sh	r0,r0[0x0]
80003faa:	27 ac       	sub	r12,122

80003fac <stdio_usb_init>:
{
	stdio_usb_interface_enable = false;
}

void stdio_usb_init (volatile void * usart)
{
80003fac:	d4 01       	pushm	lr
	stdio_base = usart;
80003fae:	48 98       	lddpc	r8,80003fd0 <stdio_usb_init+0x24>
80003fb0:	91 0c       	st.w	r8[0x0],r12
	ptr_put = stdio_usb_putchar;
80003fb2:	48 99       	lddpc	r9,80003fd4 <stdio_usb_init+0x28>
80003fb4:	48 98       	lddpc	r8,80003fd8 <stdio_usb_init+0x2c>
80003fb6:	91 09       	st.w	r8[0x0],r9
	ptr_get = stdio_usb_getchar;
80003fb8:	48 99       	lddpc	r9,80003fdc <stdio_usb_init+0x30>
80003fba:	48 a8       	lddpc	r8,80003fe0 <stdio_usb_init+0x34>
80003fbc:	91 09       	st.w	r8[0x0],r9

/*! \brief Start the USB Device stack
 */
static inline void udc_start(void)
{
	udd_enable();
80003fbe:	f0 1f 00 0a 	mcall	80003fe4 <stdio_usb_init+0x38>
 *        udc_attach(); \n
 *     }  \n
 */
static inline bool udc_include_vbus_monitoring(void)
{
	return udd_include_vbus_monitoring();
80003fc2:	f0 1f 00 0a 	mcall	80003fe8 <stdio_usb_init+0x3c>
	 * integrated USB interfaces.  Assume the VBUS is present if
	 * VBUS monitoring is not available.
	 */
	udc_start ();

	if (! udc_include_vbus_monitoring ()) {
80003fc6:	c0 41       	brne	80003fce <stdio_usb_init+0x22>
		stdio_usb_vbus_event (true);
80003fc8:	30 1c       	mov	r12,1
80003fca:	f0 1f 00 09 	mcall	80003fec <stdio_usb_init+0x40>
80003fce:	d8 02       	popm	pc
80003fd0:	00 00       	add	r0,r0
80003fd2:	0a 38       	cp.w	r8,r5
80003fd4:	80 00       	ld.sh	r0,r0[0x0]
80003fd6:	40 1c       	lddsp	r12,sp[0x4]
80003fd8:	00 00       	add	r0,r0
80003fda:	0a 34       	cp.w	r4,r5
80003fdc:	80 00       	ld.sh	r0,r0[0x0]
80003fde:	3f f0       	mov	r0,-1
80003fe0:	00 00       	add	r0,r0
80003fe2:	0a 30       	cp.w	r0,r5
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	2b 6c       	sub	r12,-74
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	24 1c       	sub	r12,65
80003fec:	80 00       	ld.sh	r0,r0[0x0]
80003fee:	3f 90       	mov	r0,-7

80003ff0 <stdio_usb_getchar>:

	return udi_cdc_putc (data) ? 0 : -1;
}

void stdio_usb_getchar (void volatile * usart, int * data)
{
80003ff0:	eb cd 40 80 	pushm	r7,lr
80003ff4:	16 97       	mov	r7,r11
	/* A negative return value should be used to indicate that data
	 * was not read, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
80003ff6:	48 88       	lddpc	r8,80004014 <stdio_usb_getchar+0x24>
80003ff8:	11 89       	ld.ub	r9,r8[0x0]
80003ffa:	30 08       	mov	r8,0
80003ffc:	f0 09 18 00 	cp.b	r9,r8
80004000:	c0 51       	brne	8000400a <stdio_usb_getchar+0x1a>
		*data = 0;  // -1
80004002:	30 08       	mov	r8,0
80004004:	97 08       	st.w	r11[0x0],r8
		return;
80004006:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	
	*data = udi_cdc_getc ();
8000400a:	f0 1f 00 04 	mcall	80004018 <stdio_usb_getchar+0x28>
8000400e:	8f 0c       	st.w	r7[0x0],r12
80004010:	e3 cd 80 80 	ldm	sp++,r7,pc
80004014:	00 00       	add	r0,r0
80004016:	08 98       	mov	r8,r4
80004018:	80 00       	ld.sh	r0,r0[0x0]
8000401a:	35 74       	mov	r4,87

8000401c <stdio_usb_putchar>:
#include "stdio_usb.h"

static bool stdio_usb_interface_enable = false;

int stdio_usb_putchar (volatile void * usart, int data)
{
8000401c:	d4 01       	pushm	lr
	/* A negative return value should be used to indicate that data
	 * was not written, but this doesn't seem to work with GCC libc.
	 */
	if (!stdio_usb_interface_enable) {
8000401e:	48 78       	lddpc	r8,80004038 <stdio_usb_putchar+0x1c>
80004020:	11 89       	ld.ub	r9,r8[0x0]
80004022:	30 08       	mov	r8,0
80004024:	f0 09 18 00 	cp.b	r9,r8
80004028:	c0 60       	breq	80004034 <stdio_usb_putchar+0x18>
		return 0;  // -1
	}

	return udi_cdc_putc (data) ? 0 : -1;
8000402a:	16 9c       	mov	r12,r11
8000402c:	f0 1f 00 04 	mcall	8000403c <stdio_usb_putchar+0x20>
80004030:	c0 21       	brne	80004034 <stdio_usb_putchar+0x18>
80004032:	dc 0a       	popm	pc,r12=-1
80004034:	d8 0a       	popm	pc,r12=0
80004036:	00 00       	add	r0,r0
80004038:	00 00       	add	r0,r0
8000403a:	08 98       	mov	r8,r4
8000403c:	80 00       	ld.sh	r0,r0[0x0]
8000403e:	34 74       	mov	r4,71

80004040 <_write>:

#elif (defined(__GNUC__) && !defined(XMEGA))

	int __attribute__((weak))
	_write (int file, char * ptr, int len)
	{
80004040:	eb cd 40 f8 	pushm	r3-r7,lr
80004044:	16 94       	mov	r4,r11
80004046:	14 95       	mov	r5,r10
		int nChars = 0;
	
		if ( (file != 1)
80004048:	20 1c       	sub	r12,1
8000404a:	58 2c       	cp.w	r12,2
8000404c:	e0 8b 00 13 	brhi	80004072 <_write+0x32>
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
80004050:	58 0a       	cp.w	r10,0
80004052:	c0 31       	brne	80004058 <_write+0x18>
80004054:	30 07       	mov	r7,0
80004056:	c0 f8       	rjmp	80004074 <_write+0x34>
80004058:	30 07       	mov	r7,0
			if (ptr_put(stdio_base, *ptr++) < 0) {
8000405a:	48 93       	lddpc	r3,8000407c <_write+0x3c>
8000405c:	48 96       	lddpc	r6,80004080 <_write+0x40>
8000405e:	66 0c       	ld.w	r12,r3[0x0]
80004060:	6c 08       	ld.w	r8,r6[0x0]
80004062:	e8 07 07 0b 	ld.ub	r11,r4[r7]
80004066:	5d 18       	icall	r8
80004068:	c0 55       	brlt	80004072 <_write+0x32>
				return -1;
			}
			++nChars;
8000406a:	2f f7       	sub	r7,-1
	
		if ( (file != 1)
			&& (file != 2) && (file!=3))
		return -1;
	
		for (; len != 0; --len) {
8000406c:	0e 35       	cp.w	r5,r7
8000406e:	cf 81       	brne	8000405e <_write+0x1e>
80004070:	c0 28       	rjmp	80004074 <_write+0x34>
80004072:	3f f7       	mov	r7,-1
				return -1;
			}
			++nChars;
		}
		return nChars;
	}
80004074:	0e 9c       	mov	r12,r7
80004076:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000407a:	00 00       	add	r0,r0
8000407c:	00 00       	add	r0,r0
8000407e:	0a 38       	cp.w	r8,r5
80004080:	00 00       	add	r0,r0
80004082:	0a 34       	cp.w	r4,r5

80004084 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004084:	f8 c8 ff f8 	sub	r8,r12,-8
80004088:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000408a:	3f f9       	mov	r9,-1
8000408c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000408e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004090:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004092:	30 08       	mov	r8,0
80004094:	99 08       	st.w	r12[0x0],r8
}
80004096:	5e fc       	retal	r12

80004098 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004098:	30 08       	mov	r8,0
8000409a:	99 48       	st.w	r12[0x10],r8
}
8000409c:	5e fc       	retal	r12

8000409e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000409e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800040a0:	70 19       	ld.w	r9,r8[0x4]
800040a2:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800040a4:	78 19       	ld.w	r9,r12[0x4]
800040a6:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800040a8:	70 19       	ld.w	r9,r8[0x4]
800040aa:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800040ac:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800040ae:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800040b0:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800040b2:	78 08       	ld.w	r8,r12[0x0]
800040b4:	2f f8       	sub	r8,-1
800040b6:	99 08       	st.w	r12[0x0],r8
}
800040b8:	5e fc       	retal	r12

800040ba <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800040ba:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800040bc:	5b fa       	cp.w	r10,-1
800040be:	c0 31       	brne	800040c4 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800040c0:	78 48       	ld.w	r8,r12[0x10]
800040c2:	c0 c8       	rjmp	800040da <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800040c4:	f8 c8 ff f8 	sub	r8,r12,-8
800040c8:	70 19       	ld.w	r9,r8[0x4]
800040ca:	72 09       	ld.w	r9,r9[0x0]
800040cc:	12 3a       	cp.w	r10,r9
800040ce:	c0 63       	brcs	800040da <vListInsert+0x20>
800040d0:	70 18       	ld.w	r8,r8[0x4]
800040d2:	70 19       	ld.w	r9,r8[0x4]
800040d4:	72 09       	ld.w	r9,r9[0x0]
800040d6:	12 3a       	cp.w	r10,r9
800040d8:	cf c2       	brcc	800040d0 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800040da:	70 19       	ld.w	r9,r8[0x4]
800040dc:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800040de:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
800040e0:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
800040e2:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800040e4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800040e6:	78 08       	ld.w	r8,r12[0x0]
800040e8:	2f f8       	sub	r8,-1
800040ea:	99 08       	st.w	r12[0x0],r8
}
800040ec:	5e fc       	retal	r12

800040ee <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
800040ee:	78 18       	ld.w	r8,r12[0x4]
800040f0:	78 29       	ld.w	r9,r12[0x8]
800040f2:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
800040f4:	78 28       	ld.w	r8,r12[0x8]
800040f6:	78 19       	ld.w	r9,r12[0x4]
800040f8:	91 19       	st.w	r8[0x4],r9
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
800040fa:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
800040fc:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
800040fe:	18 39       	cp.w	r9,r12
80004100:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004104:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004108:	30 09       	mov	r9,0
8000410a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
8000410c:	70 09       	ld.w	r9,r8[0x0]
8000410e:	20 19       	sub	r9,1
80004110:	91 09       	st.w	r8[0x0],r9
}
80004112:	5e fc       	retal	r12

80004114 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004114:	e0 68 08 08 	mov	r8,2056
80004118:	ea 18 08 08 	orh	r8,0x808
8000411c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
8000411e:	e0 68 09 09 	mov	r8,2313
80004122:	ea 18 09 09 	orh	r8,0x909
80004126:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004128:	e0 68 0a 0a 	mov	r8,2570
8000412c:	ea 18 0a 0a 	orh	r8,0xa0a
80004130:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004132:	e0 68 0b 0b 	mov	r8,2827
80004136:	ea 18 0b 0b 	orh	r8,0xb0b
8000413a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
8000413c:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
8000413e:	e0 68 be ef 	mov	r8,48879
80004142:	ea 18 de ad 	orh	r8,0xdead
80004146:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004148:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000414a:	fc 18 00 40 	movh	r8,0x40
8000414e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004150:	e0 68 00 ff 	mov	r8,255
80004154:	ea 18 ff 00 	orh	r8,0xff00
80004158:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000415a:	e0 68 01 01 	mov	r8,257
8000415e:	ea 18 01 01 	orh	r8,0x101
80004162:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004164:	e0 68 02 02 	mov	r8,514
80004168:	ea 18 02 02 	orh	r8,0x202
8000416c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000416e:	e0 68 03 03 	mov	r8,771
80004172:	ea 18 03 03 	orh	r8,0x303
80004176:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004178:	e0 68 04 04 	mov	r8,1028
8000417c:	ea 18 04 04 	orh	r8,0x404
80004180:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004182:	e0 68 05 05 	mov	r8,1285
80004186:	ea 18 05 05 	orh	r8,0x505
8000418a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000418c:	e0 68 06 06 	mov	r8,1542
80004190:	ea 18 06 06 	orh	r8,0x606
80004194:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004196:	e0 68 07 07 	mov	r8,1799
8000419a:	ea 18 07 07 	orh	r8,0x707
8000419e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800041a0:	30 08       	mov	r8,0
800041a2:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800041a4:	5e fc       	retal	r12
800041a6:	d7 03       	nop

800041a8 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800041a8:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800041aa:	48 38       	lddpc	r8,800041b4 <vPortEnterCritical+0xc>
800041ac:	70 09       	ld.w	r9,r8[0x0]
800041ae:	2f f9       	sub	r9,-1
800041b0:	91 09       	st.w	r8[0x0],r9
}
800041b2:	5e fc       	retal	r12
800041b4:	00 00       	add	r0,r0
800041b6:	00 e8       	st.h	--r0,r8

800041b8 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800041b8:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800041ba:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800041bc:	30 0a       	mov	r10,0
800041be:	14 9b       	mov	r11,r10
800041c0:	49 2c       	lddpc	r12,80004208 <xPortStartScheduler+0x50>
800041c2:	f0 1f 00 13 	mcall	8000420c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
800041c6:	e0 68 2e e0 	mov	r8,12000
800041ca:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800041ce:	30 08       	mov	r8,0
800041d0:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800041d4:	e0 68 09 6c 	mov	r8,2412
800041d8:	ea 18 00 00 	orh	r8,0x0
800041dc:	70 00       	ld.w	r0,r8[0x0]
800041de:	60 0d       	ld.w	sp,r0[0x0]
800041e0:	1b 00       	ld.w	r0,sp++
800041e2:	e0 68 00 e8 	mov	r8,232
800041e6:	ea 18 00 00 	orh	r8,0x0
800041ea:	91 00       	st.w	r8[0x0],r0
800041ec:	e3 cd 00 ff 	ldm	sp++,r0-r7
800041f0:	2f ed       	sub	sp,-8
800041f2:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
800041f6:	fa f0 ff e0 	ld.w	r0,sp[-32]
800041fa:	e3 b0 00 00 	mtsr	0x0,r0
800041fe:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004202:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004206:	d8 0a       	popm	pc,r12=0
80004208:	80 00       	ld.sh	r0,r0[0x0]
8000420a:	42 d4       	lddsp	r4,sp[0xb4]
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	22 8c       	sub	r12,40

80004210 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004210:	20 6d       	sub	sp,24
80004212:	eb cd 00 ff 	pushm	r0-r7
80004216:	fa c7 ff c0 	sub	r7,sp,-64
8000421a:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000421e:	ef 40 ff e0 	st.w	r7[-32],r0
80004222:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004226:	ef 40 ff e4 	st.w	r7[-28],r0
8000422a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
8000422e:	e0 68 00 e8 	mov	r8,232
80004232:	ea 18 00 00 	orh	r8,0x0
80004236:	70 00       	ld.w	r0,r8[0x0]
80004238:	1a d0       	st.w	--sp,r0
8000423a:	f0 1f 00 1a 	mcall	800042a0 <LABEL_RET_SCALL_266+0x14>
8000423e:	e0 68 09 6c 	mov	r8,2412
80004242:	ea 18 00 00 	orh	r8,0x0
80004246:	70 00       	ld.w	r0,r8[0x0]
80004248:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000424a:	f0 1f 00 17 	mcall	800042a4 <LABEL_RET_SCALL_266+0x18>
	portRESTORE_CONTEXT_SCALL();
8000424e:	e0 68 09 6c 	mov	r8,2412
80004252:	ea 18 00 00 	orh	r8,0x0
80004256:	70 00       	ld.w	r0,r8[0x0]
80004258:	60 0d       	ld.w	sp,r0[0x0]
8000425a:	1b 00       	ld.w	r0,sp++
8000425c:	e0 68 00 e8 	mov	r8,232
80004260:	ea 18 00 00 	orh	r8,0x0
80004264:	91 00       	st.w	r8[0x0],r0
80004266:	fa c7 ff d8 	sub	r7,sp,-40
8000426a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000426e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004272:	e0 61 00 e8 	mov	r1,232
80004276:	ea 11 00 00 	orh	r1,0x0
8000427a:	62 02       	ld.w	r2,r1[0x0]
8000427c:	58 02       	cp.w	r2,0
8000427e:	c0 70       	breq	8000428c <LABEL_RET_SCALL_266>
80004280:	e4 c2 00 01 	sub	r2,r2,1
80004284:	83 02       	st.w	r1[0x0],r2
80004286:	58 02       	cp.w	r2,0
80004288:	c0 21       	brne	8000428c <LABEL_RET_SCALL_266>
8000428a:	b1 c0       	cbr	r0,0x10

8000428c <LABEL_RET_SCALL_266>:
8000428c:	ef 40 ff f8 	st.w	r7[-8],r0
80004290:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004294:	ef 40 ff fc 	st.w	r7[-4],r0
80004298:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000429c:	2f ad       	sub	sp,-24
8000429e:	d6 13       	rets
800042a0:	80 00       	ld.sh	r0,r0[0x0]
800042a2:	41 a8       	lddsp	r8,sp[0x68]
800042a4:	80 00       	ld.sh	r0,r0[0x0]
800042a6:	43 e8       	lddsp	r8,sp[0xf8]

800042a8 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800042a8:	e1 b8 00 43 	mfsr	r8,0x10c
800042ac:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800042b0:	5e fc       	retal	r12
800042b2:	d7 03       	nop

800042b4 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800042b4:	48 78       	lddpc	r8,800042d0 <vPortExitCritical+0x1c>
800042b6:	70 08       	ld.w	r8,r8[0x0]
800042b8:	58 08       	cp.w	r8,0
800042ba:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800042bc:	48 58       	lddpc	r8,800042d0 <vPortExitCritical+0x1c>
800042be:	70 09       	ld.w	r9,r8[0x0]
800042c0:	20 19       	sub	r9,1
800042c2:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800042c4:	70 08       	ld.w	r8,r8[0x0]
800042c6:	58 08       	cp.w	r8,0
800042c8:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800042ca:	d5 03       	csrf	0x10
800042cc:	5e fc       	retal	r12
800042ce:	00 00       	add	r0,r0
800042d0:	00 00       	add	r0,r0
800042d2:	00 e8       	st.h	--r0,r8

800042d4 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800042d4:	eb cd 00 ff 	pushm	r0-r7
800042d8:	e0 68 00 e8 	mov	r8,232
800042dc:	ea 18 00 00 	orh	r8,0x0
800042e0:	70 00       	ld.w	r0,r8[0x0]
800042e2:	1a d0       	st.w	--sp,r0
800042e4:	7a 90       	ld.w	r0,sp[0x24]
800042e6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800042ea:	58 10       	cp.w	r0,1
800042ec:	e0 8b 00 08 	brhi	800042fc <LABEL_INT_SKIP_SAVE_CONTEXT_240>
800042f0:	e0 68 09 6c 	mov	r8,2412
800042f4:	ea 18 00 00 	orh	r8,0x0
800042f8:	70 00       	ld.w	r0,r8[0x0]
800042fa:	81 0d       	st.w	r0[0x0],sp

800042fc <LABEL_INT_SKIP_SAVE_CONTEXT_240>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800042fc:	f0 1f 00 12 	mcall	80004344 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004300:	f0 1f 00 12 	mcall	80004348 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
		vTaskIncrementTick();
80004304:	f0 1f 00 12 	mcall	8000434c <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x1c>
	portEXIT_CRITICAL();
80004308:	f0 1f 00 12 	mcall	80004350 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000430c:	7a 90       	ld.w	r0,sp[0x24]
8000430e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004312:	58 10       	cp.w	r0,1
80004314:	e0 8b 00 0e 	brhi	80004330 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>
80004318:	f0 1f 00 0c 	mcall	80004348 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x18>
8000431c:	f0 1f 00 0e 	mcall	80004354 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x24>
80004320:	f0 1f 00 0c 	mcall	80004350 <LABEL_INT_SKIP_RESTORE_CONTEXT_257+0x20>
80004324:	e0 68 09 6c 	mov	r8,2412
80004328:	ea 18 00 00 	orh	r8,0x0
8000432c:	70 00       	ld.w	r0,r8[0x0]
8000432e:	60 0d       	ld.w	sp,r0[0x0]

80004330 <LABEL_INT_SKIP_RESTORE_CONTEXT_257>:
80004330:	1b 00       	ld.w	r0,sp++
80004332:	e0 68 00 e8 	mov	r8,232
80004336:	ea 18 00 00 	orh	r8,0x0
8000433a:	91 00       	st.w	r8[0x0],r0
8000433c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004340:	d6 03       	rete
80004342:	00 00       	add	r0,r0
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	42 a8       	lddsp	r8,sp[0xa8]
80004348:	80 00       	ld.sh	r0,r0[0x0]
8000434a:	41 a8       	lddsp	r8,sp[0x68]
8000434c:	80 00       	ld.sh	r0,r0[0x0]
8000434e:	44 88       	lddsp	r8,sp[0x120]
80004350:	80 00       	ld.sh	r0,r0[0x0]
80004352:	42 b4       	lddsp	r4,sp[0xac]
80004354:	80 00       	ld.sh	r0,r0[0x0]
80004356:	43 e8       	lddsp	r8,sp[0xf8]

80004358 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004358:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000435a:	f0 1f 00 02 	mcall	80004360 <__malloc_lock+0x8>
}
8000435e:	d8 02       	popm	pc
80004360:	80 00       	ld.sh	r0,r0[0x0]
80004362:	43 d8       	lddsp	r8,sp[0xf4]

80004364 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004364:	d4 01       	pushm	lr
	xTaskResumeAll();
80004366:	f0 1f 00 02 	mcall	8000436c <__malloc_unlock+0x8>
}
8000436a:	d8 02       	popm	pc
8000436c:	80 00       	ld.sh	r0,r0[0x0]
8000436e:	45 a0       	lddsp	r0,sp[0x168]

80004370 <_init_startup>:
 * exception vectors are not compatible with the SCALL management in the current
 * FreeRTOS port. More low-level initializations are besides added here.
 */
int _init_startup(void);
int _init_startup(void)
{
80004370:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
80004372:	48 48       	lddpc	r8,80004380 <_init_startup+0x10>
80004374:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
80004378:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
8000437a:	f0 1f 00 03 	mcall	80004384 <_init_startup+0x14>
	}
	#endif

  // Don't-care value for GCC.
  return 1;
}
8000437e:	da 0a       	popm	pc,r12=1
80004380:	80 00       	ld.sh	r0,r0[0x0]
80004382:	5c 00       	acr	r0
80004384:	80 00       	ld.sh	r0,r0[0x0]
80004386:	22 bc       	sub	r12,43

80004388 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004388:	eb cd 40 80 	pushm	r7,lr
8000438c:	18 97       	mov	r7,r12
	if( pv )
8000438e:	58 0c       	cp.w	r12,0
80004390:	c0 80       	breq	800043a0 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004392:	f0 1f 00 05 	mcall	800043a4 <vPortFree+0x1c>
		{
			free( pv );
80004396:	0e 9c       	mov	r12,r7
80004398:	f0 1f 00 04 	mcall	800043a8 <vPortFree+0x20>
		}
		xTaskResumeAll();
8000439c:	f0 1f 00 04 	mcall	800043ac <vPortFree+0x24>
800043a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800043a4:	80 00       	ld.sh	r0,r0[0x0]
800043a6:	43 d8       	lddsp	r8,sp[0xf4]
800043a8:	80 00       	ld.sh	r0,r0[0x0]
800043aa:	4c a8       	lddpc	r8,800044d0 <vTaskIncrementTick+0x48>
800043ac:	80 00       	ld.sh	r0,r0[0x0]
800043ae:	45 a0       	lddsp	r0,sp[0x168]

800043b0 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800043b0:	eb cd 40 80 	pushm	r7,lr
800043b4:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800043b6:	f0 1f 00 06 	mcall	800043cc <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800043ba:	0e 9c       	mov	r12,r7
800043bc:	f0 1f 00 05 	mcall	800043d0 <pvPortMalloc+0x20>
800043c0:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800043c2:	f0 1f 00 05 	mcall	800043d4 <pvPortMalloc+0x24>
		}
	}
	#endif
	
	return pvReturn;
}
800043c6:	0e 9c       	mov	r12,r7
800043c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800043cc:	80 00       	ld.sh	r0,r0[0x0]
800043ce:	43 d8       	lddsp	r8,sp[0xf4]
800043d0:	80 00       	ld.sh	r0,r0[0x0]
800043d2:	4c bc       	lddpc	r12,800044fc <vTaskIncrementTick+0x74>
800043d4:	80 00       	ld.sh	r0,r0[0x0]
800043d6:	45 a0       	lddsp	r0,sp[0x168]

800043d8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800043d8:	48 38       	lddpc	r8,800043e4 <vTaskSuspendAll+0xc>
800043da:	70 09       	ld.w	r9,r8[0x0]
800043dc:	2f f9       	sub	r9,-1
800043de:	91 09       	st.w	r8[0x0],r9
}
800043e0:	5e fc       	retal	r12
800043e2:	00 00       	add	r0,r0
800043e4:	00 00       	add	r0,r0
800043e6:	09 9c       	ld.ub	r12,r4[0x1]

800043e8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800043e8:	49 a8       	lddpc	r8,80004450 <vTaskSwitchContext+0x68>
800043ea:	70 08       	ld.w	r8,r8[0x0]
800043ec:	58 08       	cp.w	r8,0
800043ee:	c0 b1       	brne	80004404 <vTaskSwitchContext+0x1c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800043f0:	49 98       	lddpc	r8,80004454 <vTaskSwitchContext+0x6c>
800043f2:	70 08       	ld.w	r8,r8[0x0]
800043f4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800043f8:	49 89       	lddpc	r9,80004458 <vTaskSwitchContext+0x70>
800043fa:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800043fe:	58 08       	cp.w	r8,0
80004400:	c0 60       	breq	8000440c <vTaskSwitchContext+0x24>
80004402:	c1 18       	rjmp	80004424 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80004404:	30 19       	mov	r9,1
80004406:	49 68       	lddpc	r8,8000445c <vTaskSwitchContext+0x74>
80004408:	91 09       	st.w	r8[0x0],r9
8000440a:	5e fc       	retal	r12
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
8000440c:	49 28       	lddpc	r8,80004454 <vTaskSwitchContext+0x6c>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000440e:	49 3a       	lddpc	r10,80004458 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80004410:	70 09       	ld.w	r9,r8[0x0]
80004412:	20 19       	sub	r9,1
80004414:	91 09       	st.w	r8[0x0],r9
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80004416:	70 09       	ld.w	r9,r8[0x0]
80004418:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000441c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80004420:	58 09       	cp.w	r9,0
80004422:	cf 70       	breq	80004410 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80004424:	48 c8       	lddpc	r8,80004454 <vTaskSwitchContext+0x6c>
80004426:	70 08       	ld.w	r8,r8[0x0]
80004428:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000442c:	48 b9       	lddpc	r9,80004458 <vTaskSwitchContext+0x70>
8000442e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80004432:	70 19       	ld.w	r9,r8[0x4]
80004434:	72 19       	ld.w	r9,r9[0x4]
80004436:	91 19       	st.w	r8[0x4],r9
80004438:	f0 ca ff f8 	sub	r10,r8,-8
8000443c:	14 39       	cp.w	r9,r10
8000443e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80004442:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80004446:	70 18       	ld.w	r8,r8[0x4]
80004448:	70 39       	ld.w	r9,r8[0xc]
8000444a:	48 68       	lddpc	r8,80004460 <vTaskSwitchContext+0x78>
8000444c:	91 09       	st.w	r8[0x0],r9
8000444e:	5e fc       	retal	r12
80004450:	00 00       	add	r0,r0
80004452:	09 9c       	ld.ub	r12,r4[0x1]
80004454:	00 00       	add	r0,r0
80004456:	09 d4       	ld.ub	r4,r4[0x5]
80004458:	00 00       	add	r0,r0
8000445a:	08 b8       	st.h	r4++,r8
8000445c:	00 00       	add	r0,r0
8000445e:	09 bc       	ld.ub	r12,r4[0x3]
80004460:	00 00       	add	r0,r0
80004462:	09 6c       	ld.uh	r12,--r4

80004464 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80004464:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80004468:	f0 1f 00 05 	mcall	8000447c <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000446c:	48 58       	lddpc	r8,80004480 <xTaskGetTickCount+0x1c>
8000446e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80004470:	f0 1f 00 05 	mcall	80004484 <xTaskGetTickCount+0x20>

	return xTicks;
}
80004474:	0e 9c       	mov	r12,r7
80004476:	e3 cd 80 80 	ldm	sp++,r7,pc
8000447a:	00 00       	add	r0,r0
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	41 a8       	lddsp	r8,sp[0x68]
80004480:	00 00       	add	r0,r0
80004482:	09 98       	ld.ub	r8,r4[0x1]
80004484:	80 00       	ld.sh	r0,r0[0x0]
80004486:	42 b4       	lddsp	r4,sp[0xac]

80004488 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80004488:	eb cd 40 fe 	pushm	r1-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000448c:	4b a8       	lddpc	r8,80004574 <vTaskIncrementTick+0xec>
8000448e:	70 08       	ld.w	r8,r8[0x0]
80004490:	58 08       	cp.w	r8,0
80004492:	c6 a1       	brne	80004566 <vTaskIncrementTick+0xde>
	{
		++xTickCount;
80004494:	4b 98       	lddpc	r8,80004578 <vTaskIncrementTick+0xf0>
80004496:	70 09       	ld.w	r9,r8[0x0]
80004498:	2f f9       	sub	r9,-1
8000449a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
8000449c:	70 08       	ld.w	r8,r8[0x0]
8000449e:	58 08       	cp.w	r8,0
800044a0:	c1 a1       	brne	800044d4 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
800044a2:	4b 78       	lddpc	r8,8000457c <vTaskIncrementTick+0xf4>
800044a4:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800044a6:	4b 79       	lddpc	r9,80004580 <vTaskIncrementTick+0xf8>
800044a8:	72 0b       	ld.w	r11,r9[0x0]
800044aa:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800044ac:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800044ae:	4b 69       	lddpc	r9,80004584 <vTaskIncrementTick+0xfc>
800044b0:	72 0a       	ld.w	r10,r9[0x0]
800044b2:	2f fa       	sub	r10,-1
800044b4:	93 0a       	st.w	r9[0x0],r10
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800044b6:	70 08       	ld.w	r8,r8[0x0]
800044b8:	70 08       	ld.w	r8,r8[0x0]
800044ba:	58 08       	cp.w	r8,0
800044bc:	c0 51       	brne	800044c6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set 
				xNextTaskUnblockTime to the maximum possible value so it is 
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until 
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800044be:	3f f9       	mov	r9,-1
800044c0:	4b 28       	lddpc	r8,80004588 <vTaskIncrementTick+0x100>
800044c2:	91 09       	st.w	r8[0x0],r9
800044c4:	c0 88       	rjmp	800044d4 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of 
				the item at the head of the delayed list.  This is the time at 
				which the task at the head of the delayed list should be removed 
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800044c6:	4a e8       	lddpc	r8,8000457c <vTaskIncrementTick+0xf4>
800044c8:	70 08       	ld.w	r8,r8[0x0]
800044ca:	70 38       	ld.w	r8,r8[0xc]
800044cc:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800044ce:	70 19       	ld.w	r9,r8[0x4]
800044d0:	4a e8       	lddpc	r8,80004588 <vTaskIncrementTick+0x100>
800044d2:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800044d4:	4a 98       	lddpc	r8,80004578 <vTaskIncrementTick+0xf0>
800044d6:	70 09       	ld.w	r9,r8[0x0]
800044d8:	4a c8       	lddpc	r8,80004588 <vTaskIncrementTick+0x100>
800044da:	70 08       	ld.w	r8,r8[0x0]
800044dc:	10 39       	cp.w	r9,r8
800044de:	c4 83       	brcs	8000456e <vTaskIncrementTick+0xe6>
800044e0:	4a 78       	lddpc	r8,8000457c <vTaskIncrementTick+0xf4>
800044e2:	70 08       	ld.w	r8,r8[0x0]
800044e4:	70 08       	ld.w	r8,r8[0x0]
800044e6:	58 08       	cp.w	r8,0
800044e8:	c0 c0       	breq	80004500 <vTaskIncrementTick+0x78>
800044ea:	4a 58       	lddpc	r8,8000457c <vTaskIncrementTick+0xf4>
800044ec:	70 08       	ld.w	r8,r8[0x0]
800044ee:	70 38       	ld.w	r8,r8[0xc]
800044f0:	70 37       	ld.w	r7,r8[0xc]
800044f2:	6e 18       	ld.w	r8,r7[0x4]
800044f4:	4a 19       	lddpc	r9,80004578 <vTaskIncrementTick+0xf0>
800044f6:	72 09       	ld.w	r9,r9[0x0]
800044f8:	12 38       	cp.w	r8,r9
800044fa:	e0 88 00 14 	brls	80004522 <vTaskIncrementTick+0x9a>
800044fe:	c0 e8       	rjmp	8000451a <vTaskIncrementTick+0x92>
80004500:	3f f9       	mov	r9,-1
80004502:	4a 28       	lddpc	r8,80004588 <vTaskIncrementTick+0x100>
80004504:	91 09       	st.w	r8[0x0],r9
80004506:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000450a:	6a 08       	ld.w	r8,r5[0x0]
8000450c:	70 38       	ld.w	r8,r8[0xc]
8000450e:	70 37       	ld.w	r7,r8[0xc]
80004510:	6e 18       	ld.w	r8,r7[0x4]
80004512:	64 09       	ld.w	r9,r2[0x0]
80004514:	12 38       	cp.w	r8,r9
80004516:	e0 88 00 0b 	brls	8000452c <vTaskIncrementTick+0xa4>
8000451a:	49 c9       	lddpc	r9,80004588 <vTaskIncrementTick+0x100>
8000451c:	93 08       	st.w	r9[0x0],r8
8000451e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80004522:	49 b4       	lddpc	r4,8000458c <vTaskIncrementTick+0x104>
80004524:	08 91       	mov	r1,r4
80004526:	49 b3       	lddpc	r3,80004590 <vTaskIncrementTick+0x108>
80004528:	49 55       	lddpc	r5,8000457c <vTaskIncrementTick+0xf4>
8000452a:	49 42       	lddpc	r2,80004578 <vTaskIncrementTick+0xf0>
8000452c:	ee c6 ff fc 	sub	r6,r7,-4
80004530:	0c 9c       	mov	r12,r6
80004532:	f0 1f 00 19 	mcall	80004594 <vTaskIncrementTick+0x10c>
80004536:	6e a8       	ld.w	r8,r7[0x28]
80004538:	58 08       	cp.w	r8,0
8000453a:	c0 50       	breq	80004544 <vTaskIncrementTick+0xbc>
8000453c:	ee cc ff e8 	sub	r12,r7,-24
80004540:	f0 1f 00 15 	mcall	80004594 <vTaskIncrementTick+0x10c>
80004544:	6e bc       	ld.w	r12,r7[0x2c]
80004546:	68 08       	ld.w	r8,r4[0x0]
80004548:	10 3c       	cp.w	r12,r8
8000454a:	e3 fc ba 00 	st.whi	r1[0x0],r12
8000454e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004552:	0c 9b       	mov	r11,r6
80004554:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80004558:	f0 1f 00 10 	mcall	80004598 <vTaskIncrementTick+0x110>
8000455c:	6a 08       	ld.w	r8,r5[0x0]
8000455e:	70 08       	ld.w	r8,r8[0x0]
80004560:	58 08       	cp.w	r8,0
80004562:	cd 41       	brne	8000450a <vTaskIncrementTick+0x82>
80004564:	cc eb       	rjmp	80004500 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80004566:	48 e8       	lddpc	r8,8000459c <vTaskIncrementTick+0x114>
80004568:	70 09       	ld.w	r9,r8[0x0]
8000456a:	2f f9       	sub	r9,-1
8000456c:	91 09       	st.w	r8[0x0],r9
8000456e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80004572:	00 00       	add	r0,r0
80004574:	00 00       	add	r0,r0
80004576:	09 9c       	ld.ub	r12,r4[0x1]
80004578:	00 00       	add	r0,r0
8000457a:	09 98       	ld.ub	r8,r4[0x1]
8000457c:	00 00       	add	r0,r0
8000457e:	08 a4       	st.w	r4++,r4
80004580:	00 00       	add	r0,r0
80004582:	08 b4       	st.h	r4++,r4
80004584:	00 00       	add	r0,r0
80004586:	08 b0       	st.h	r4++,r0
80004588:	00 00       	add	r0,r0
8000458a:	00 ec       	st.h	--r0,r12
8000458c:	00 00       	add	r0,r0
8000458e:	09 d4       	ld.ub	r4,r4[0x5]
80004590:	00 00       	add	r0,r0
80004592:	08 b8       	st.h	r4++,r8
80004594:	80 00       	ld.sh	r0,r0[0x0]
80004596:	40 ee       	lddsp	lr,sp[0x38]
80004598:	80 00       	ld.sh	r0,r0[0x0]
8000459a:	40 9e       	lddsp	lr,sp[0x24]
8000459c:	00 00       	add	r0,r0
8000459e:	08 9c       	mov	r12,r4

800045a0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800045a0:	d4 31       	pushm	r0-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800045a2:	f0 1f 00 2c 	mcall	80004650 <xTaskResumeAll+0xb0>
	{
		--uxSchedulerSuspended;
800045a6:	4a c8       	lddpc	r8,80004654 <xTaskResumeAll+0xb4>
800045a8:	70 09       	ld.w	r9,r8[0x0]
800045aa:	20 19       	sub	r9,1
800045ac:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800045ae:	70 08       	ld.w	r8,r8[0x0]
800045b0:	58 08       	cp.w	r8,0
800045b2:	c4 a1       	brne	80004646 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800045b4:	4a 98       	lddpc	r8,80004658 <xTaskResumeAll+0xb8>
800045b6:	70 08       	ld.w	r8,r8[0x0]
800045b8:	58 08       	cp.w	r8,0
800045ba:	c4 60       	breq	80004646 <xTaskResumeAll+0xa6>
800045bc:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800045be:	4a 85       	lddpc	r5,8000465c <xTaskResumeAll+0xbc>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800045c0:	4a 83       	lddpc	r3,80004660 <xTaskResumeAll+0xc0>
800045c2:	06 90       	mov	r0,r3
800045c4:	4a 82       	lddpc	r2,80004664 <xTaskResumeAll+0xc4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800045c6:	4a 91       	lddpc	r1,80004668 <xTaskResumeAll+0xc8>
800045c8:	c1 e8       	rjmp	80004604 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800045ca:	6a 38       	ld.w	r8,r5[0xc]
800045cc:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800045ce:	ee cc ff e8 	sub	r12,r7,-24
800045d2:	f0 1f 00 27 	mcall	8000466c <xTaskResumeAll+0xcc>
					vListRemove( &( pxTCB->xGenericListItem ) );
800045d6:	ee c6 ff fc 	sub	r6,r7,-4
800045da:	0c 9c       	mov	r12,r6
800045dc:	f0 1f 00 24 	mcall	8000466c <xTaskResumeAll+0xcc>
					prvAddTaskToReadyQueue( pxTCB );
800045e0:	6e bc       	ld.w	r12,r7[0x2c]
800045e2:	66 08       	ld.w	r8,r3[0x0]
800045e4:	10 3c       	cp.w	r12,r8
800045e6:	e1 fc ba 00 	st.whi	r0[0x0],r12
800045ea:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800045ee:	0c 9b       	mov	r11,r6
800045f0:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800045f4:	f0 1f 00 1f 	mcall	80004670 <xTaskResumeAll+0xd0>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800045f8:	62 08       	ld.w	r8,r1[0x0]
800045fa:	6e b9       	ld.w	r9,r7[0x2c]
800045fc:	70 b8       	ld.w	r8,r8[0x2c]
800045fe:	10 39       	cp.w	r9,r8
80004600:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80004604:	6a 08       	ld.w	r8,r5[0x0]
80004606:	58 08       	cp.w	r8,0
80004608:	ce 11       	brne	800045ca <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000460a:	49 b8       	lddpc	r8,80004674 <xTaskResumeAll+0xd4>
8000460c:	70 08       	ld.w	r8,r8[0x0]
8000460e:	58 08       	cp.w	r8,0
80004610:	c0 f0       	breq	8000462e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004612:	49 98       	lddpc	r8,80004674 <xTaskResumeAll+0xd4>
80004614:	70 08       	ld.w	r8,r8[0x0]
80004616:	58 08       	cp.w	r8,0
80004618:	c1 10       	breq	8000463a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
8000461a:	49 77       	lddpc	r7,80004674 <xTaskResumeAll+0xd4>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
8000461c:	f0 1f 00 17 	mcall	80004678 <xTaskResumeAll+0xd8>
						--uxMissedTicks;
80004620:	6e 08       	ld.w	r8,r7[0x0]
80004622:	20 18       	sub	r8,1
80004624:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80004626:	6e 08       	ld.w	r8,r7[0x0]
80004628:	58 08       	cp.w	r8,0
8000462a:	cf 91       	brne	8000461c <xTaskResumeAll+0x7c>
8000462c:	c0 78       	rjmp	8000463a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
8000462e:	58 14       	cp.w	r4,1
80004630:	c0 50       	breq	8000463a <xTaskResumeAll+0x9a>
80004632:	49 38       	lddpc	r8,8000467c <xTaskResumeAll+0xdc>
80004634:	70 08       	ld.w	r8,r8[0x0]
80004636:	58 18       	cp.w	r8,1
80004638:	c0 71       	brne	80004646 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
8000463a:	30 09       	mov	r9,0
8000463c:	49 08       	lddpc	r8,8000467c <xTaskResumeAll+0xdc>
8000463e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80004640:	d7 33       	scall
80004642:	30 17       	mov	r7,1
80004644:	c0 28       	rjmp	80004648 <xTaskResumeAll+0xa8>
80004646:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80004648:	f0 1f 00 0e 	mcall	80004680 <xTaskResumeAll+0xe0>

	return xAlreadyYielded;
}
8000464c:	0e 9c       	mov	r12,r7
8000464e:	d8 32       	popm	r0-r7,pc
80004650:	80 00       	ld.sh	r0,r0[0x0]
80004652:	41 a8       	lddsp	r8,sp[0x68]
80004654:	00 00       	add	r0,r0
80004656:	09 9c       	ld.ub	r12,r4[0x1]
80004658:	00 00       	add	r0,r0
8000465a:	09 b8       	ld.ub	r8,r4[0x3]
8000465c:	00 00       	add	r0,r0
8000465e:	09 70       	ld.ub	r0,--r4
80004660:	00 00       	add	r0,r0
80004662:	09 d4       	ld.ub	r4,r4[0x5]
80004664:	00 00       	add	r0,r0
80004666:	08 b8       	st.h	r4++,r8
80004668:	00 00       	add	r0,r0
8000466a:	09 6c       	ld.uh	r12,--r4
8000466c:	80 00       	ld.sh	r0,r0[0x0]
8000466e:	40 ee       	lddsp	lr,sp[0x38]
80004670:	80 00       	ld.sh	r0,r0[0x0]
80004672:	40 9e       	lddsp	lr,sp[0x24]
80004674:	00 00       	add	r0,r0
80004676:	08 9c       	mov	r12,r4
80004678:	80 00       	ld.sh	r0,r0[0x0]
8000467a:	44 88       	lddsp	r8,sp[0x120]
8000467c:	00 00       	add	r0,r0
8000467e:	09 bc       	ld.ub	r12,r4[0x3]
80004680:	80 00       	ld.sh	r0,r0[0x0]
80004682:	42 b4       	lddsp	r4,sp[0xac]

80004684 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80004684:	eb cd 40 80 	pushm	r7,lr
80004688:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000468a:	49 08       	lddpc	r8,800046c8 <prvAddCurrentTaskToDelayedList+0x44>
8000468c:	70 08       	ld.w	r8,r8[0x0]
8000468e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80004690:	48 f8       	lddpc	r8,800046cc <prvAddCurrentTaskToDelayedList+0x48>
80004692:	70 08       	ld.w	r8,r8[0x0]
80004694:	10 3c       	cp.w	r12,r8
80004696:	c0 a2       	brcc	800046aa <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004698:	48 c8       	lddpc	r8,800046c8 <prvAddCurrentTaskToDelayedList+0x44>
8000469a:	70 0b       	ld.w	r11,r8[0x0]
8000469c:	48 d8       	lddpc	r8,800046d0 <prvAddCurrentTaskToDelayedList+0x4c>
8000469e:	70 0c       	ld.w	r12,r8[0x0]
800046a0:	2f cb       	sub	r11,-4
800046a2:	f0 1f 00 0d 	mcall	800046d4 <prvAddCurrentTaskToDelayedList+0x50>
800046a6:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800046aa:	48 88       	lddpc	r8,800046c8 <prvAddCurrentTaskToDelayedList+0x44>
800046ac:	70 0b       	ld.w	r11,r8[0x0]
800046ae:	48 b8       	lddpc	r8,800046d8 <prvAddCurrentTaskToDelayedList+0x54>
800046b0:	70 0c       	ld.w	r12,r8[0x0]
800046b2:	2f cb       	sub	r11,-4
800046b4:	f0 1f 00 08 	mcall	800046d4 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800046b8:	48 98       	lddpc	r8,800046dc <prvAddCurrentTaskToDelayedList+0x58>
800046ba:	70 08       	ld.w	r8,r8[0x0]
800046bc:	10 37       	cp.w	r7,r8
800046be:	c0 32       	brcc	800046c4 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800046c0:	48 78       	lddpc	r8,800046dc <prvAddCurrentTaskToDelayedList+0x58>
800046c2:	91 07       	st.w	r8[0x0],r7
800046c4:	e3 cd 80 80 	ldm	sp++,r7,pc
800046c8:	00 00       	add	r0,r0
800046ca:	09 6c       	ld.uh	r12,--r4
800046cc:	00 00       	add	r0,r0
800046ce:	09 98       	ld.ub	r8,r4[0x1]
800046d0:	00 00       	add	r0,r0
800046d2:	08 b4       	st.h	r4++,r4
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	40 ba       	lddsp	r10,sp[0x2c]
800046d8:	00 00       	add	r0,r0
800046da:	08 a4       	st.w	r4++,r4
800046dc:	00 00       	add	r0,r0
800046de:	00 ec       	st.h	--r0,r12

800046e0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800046e0:	eb cd 40 c0 	pushm	r6-r7,lr
800046e4:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
800046e6:	58 0c       	cp.w	r12,0
800046e8:	c1 10       	breq	8000470a <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
800046ea:	f0 1f 00 0a 	mcall	80004710 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
800046ee:	48 a8       	lddpc	r8,80004714 <vTaskDelay+0x34>
800046f0:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800046f2:	48 a8       	lddpc	r8,80004718 <vTaskDelay+0x38>
800046f4:	70 0c       	ld.w	r12,r8[0x0]
800046f6:	2f cc       	sub	r12,-4
800046f8:	f0 1f 00 09 	mcall	8000471c <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800046fc:	ee 06 00 0c 	add	r12,r7,r6
80004700:	f0 1f 00 08 	mcall	80004720 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80004704:	f0 1f 00 08 	mcall	80004724 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80004708:	c0 21       	brne	8000470c <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
8000470a:	d7 33       	scall
8000470c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004710:	80 00       	ld.sh	r0,r0[0x0]
80004712:	43 d8       	lddsp	r8,sp[0xf4]
80004714:	00 00       	add	r0,r0
80004716:	09 98       	ld.ub	r8,r4[0x1]
80004718:	00 00       	add	r0,r0
8000471a:	09 6c       	ld.uh	r12,--r4
8000471c:	80 00       	ld.sh	r0,r0[0x0]
8000471e:	40 ee       	lddsp	lr,sp[0x38]
80004720:	80 00       	ld.sh	r0,r0[0x0]
80004722:	46 84       	lddsp	r4,sp[0x1a0]
80004724:	80 00       	ld.sh	r0,r0[0x0]
80004726:	45 a0       	lddsp	r0,sp[0x168]

80004728 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80004728:	eb cd 40 c0 	pushm	r6-r7,lr
8000472c:	18 96       	mov	r6,r12
8000472e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80004730:	f0 1f 00 18 	mcall	80004790 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80004734:	6c 08       	ld.w	r8,r6[0x0]
80004736:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80004738:	49 79       	lddpc	r9,80004794 <vTaskDelayUntil+0x6c>
8000473a:	72 09       	ld.w	r9,r9[0x0]
8000473c:	12 38       	cp.w	r8,r9
8000473e:	e0 88 00 0c 	brls	80004756 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80004742:	0e 38       	cp.w	r8,r7
80004744:	e0 88 00 22 	brls	80004788 <vTaskDelayUntil+0x60>
80004748:	49 38       	lddpc	r8,80004794 <vTaskDelayUntil+0x6c>
8000474a:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
8000474c:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000474e:	10 37       	cp.w	r7,r8
80004750:	e0 88 00 14 	brls	80004778 <vTaskDelayUntil+0x50>
80004754:	c0 a8       	rjmp	80004768 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80004756:	0e 38       	cp.w	r8,r7
80004758:	e0 8b 00 16 	brhi	80004784 <vTaskDelayUntil+0x5c>
8000475c:	48 e8       	lddpc	r8,80004794 <vTaskDelayUntil+0x6c>
8000475e:	70 08       	ld.w	r8,r8[0x0]
80004760:	10 37       	cp.w	r7,r8
80004762:	e0 8b 00 11 	brhi	80004784 <vTaskDelayUntil+0x5c>
80004766:	c1 18       	rjmp	80004788 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80004768:	48 c8       	lddpc	r8,80004798 <vTaskDelayUntil+0x70>
8000476a:	70 0c       	ld.w	r12,r8[0x0]
8000476c:	2f cc       	sub	r12,-4
8000476e:	f0 1f 00 0c 	mcall	8000479c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80004772:	0e 9c       	mov	r12,r7
80004774:	f0 1f 00 0b 	mcall	800047a0 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80004778:	f0 1f 00 0b 	mcall	800047a4 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000477c:	c0 81       	brne	8000478c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000477e:	d7 33       	scall
80004780:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80004784:	8d 07       	st.w	r6[0x0],r7
80004786:	cf 1b       	rjmp	80004768 <vTaskDelayUntil+0x40>
80004788:	8d 07       	st.w	r6[0x0],r7
8000478a:	cf 7b       	rjmp	80004778 <vTaskDelayUntil+0x50>
8000478c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004790:	80 00       	ld.sh	r0,r0[0x0]
80004792:	43 d8       	lddsp	r8,sp[0xf4]
80004794:	00 00       	add	r0,r0
80004796:	09 98       	ld.ub	r8,r4[0x1]
80004798:	00 00       	add	r0,r0
8000479a:	09 6c       	ld.uh	r12,--r4
8000479c:	80 00       	ld.sh	r0,r0[0x0]
8000479e:	40 ee       	lddsp	lr,sp[0x38]
800047a0:	80 00       	ld.sh	r0,r0[0x0]
800047a2:	46 84       	lddsp	r4,sp[0x1a0]
800047a4:	80 00       	ld.sh	r0,r0[0x0]
800047a6:	45 a0       	lddsp	r0,sp[0x168]

800047a8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800047a8:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800047ac:	49 57       	lddpc	r7,80004800 <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800047ae:	49 64       	lddpc	r4,80004804 <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800047b0:	49 63       	lddpc	r3,80004808 <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800047b2:	49 75       	lddpc	r5,8000480c <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800047b4:	6e 08       	ld.w	r8,r7[0x0]
800047b6:	58 08       	cp.w	r8,0
800047b8:	c1 e0       	breq	800047f4 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800047ba:	f0 1f 00 16 	mcall	80004810 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800047be:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800047c0:	f0 1f 00 15 	mcall	80004814 <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
800047c4:	58 06       	cp.w	r6,0
800047c6:	c1 70       	breq	800047f4 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800047c8:	f0 1f 00 14 	mcall	80004818 <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800047cc:	68 38       	ld.w	r8,r4[0xc]
800047ce:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800047d0:	ec cc ff fc 	sub	r12,r6,-4
800047d4:	f0 1f 00 12 	mcall	8000481c <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
800047d8:	66 08       	ld.w	r8,r3[0x0]
800047da:	20 18       	sub	r8,1
800047dc:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800047de:	6e 08       	ld.w	r8,r7[0x0]
800047e0:	20 18       	sub	r8,1
800047e2:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800047e4:	f0 1f 00 0f 	mcall	80004820 <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800047e8:	6c cc       	ld.w	r12,r6[0x30]
800047ea:	f0 1f 00 0f 	mcall	80004824 <prvIdleTask+0x7c>
		vPortFree( pxTCB );
800047ee:	0c 9c       	mov	r12,r6
800047f0:	f0 1f 00 0d 	mcall	80004824 <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800047f4:	6a 08       	ld.w	r8,r5[0x0]
800047f6:	58 18       	cp.w	r8,1
800047f8:	fe 98 ff de 	brls	800047b4 <prvIdleTask+0xc>
			{
				taskYIELD();
800047fc:	d7 33       	scall
800047fe:	cd bb       	rjmp	800047b4 <prvIdleTask+0xc>
80004800:	00 00       	add	r0,r0
80004802:	08 ac       	st.w	r4++,r12
80004804:	00 00       	add	r0,r0
80004806:	09 58       	ld.sh	r8,--r4
80004808:	00 00       	add	r0,r0
8000480a:	09 b8       	ld.ub	r8,r4[0x3]
8000480c:	00 00       	add	r0,r0
8000480e:	08 b8       	st.h	r4++,r8
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	43 d8       	lddsp	r8,sp[0xf4]
80004814:	80 00       	ld.sh	r0,r0[0x0]
80004816:	45 a0       	lddsp	r0,sp[0x168]
80004818:	80 00       	ld.sh	r0,r0[0x0]
8000481a:	41 a8       	lddsp	r8,sp[0x68]
8000481c:	80 00       	ld.sh	r0,r0[0x0]
8000481e:	40 ee       	lddsp	lr,sp[0x38]
80004820:	80 00       	ld.sh	r0,r0[0x0]
80004822:	42 b4       	lddsp	r4,sp[0xac]
80004824:	80 00       	ld.sh	r0,r0[0x0]
80004826:	43 88       	lddsp	r8,sp[0xe0]

80004828 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80004828:	d4 31       	pushm	r0-r7,lr
8000482a:	20 1d       	sub	sp,4
8000482c:	fa c4 ff d8 	sub	r4,sp,-40
80004830:	50 0c       	stdsp	sp[0x0],r12
80004832:	16 91       	mov	r1,r11
80004834:	14 97       	mov	r7,r10
80004836:	12 90       	mov	r0,r9
80004838:	10 93       	mov	r3,r8
8000483a:	68 02       	ld.w	r2,r4[0x0]
8000483c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
8000483e:	34 4c       	mov	r12,68
80004840:	f0 1f 00 5b 	mcall	800049ac <xTaskGenericCreate+0x184>
80004844:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80004846:	c0 31       	brne	8000484c <xTaskGenericCreate+0x24>
80004848:	3f fc       	mov	r12,-1
8000484a:	ca d8       	rjmp	800049a4 <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
8000484c:	58 06       	cp.w	r6,0
8000484e:	e0 81 00 ad 	brne	800049a8 <xTaskGenericCreate+0x180>
80004852:	0e 9c       	mov	r12,r7
80004854:	5c 7c       	castu.h	r12
80004856:	a3 6c       	lsl	r12,0x2
80004858:	f0 1f 00 55 	mcall	800049ac <xTaskGenericCreate+0x184>
8000485c:	18 96       	mov	r6,r12
8000485e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80004860:	c0 61       	brne	8000486c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80004862:	0a 9c       	mov	r12,r5
80004864:	f0 1f 00 53 	mcall	800049b0 <xTaskGenericCreate+0x188>
80004868:	3f fc       	mov	r12,-1
8000486a:	c9 d8       	rjmp	800049a4 <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
8000486c:	5c 77       	castu.h	r7
8000486e:	ee 0a 15 02 	lsl	r10,r7,0x2
80004872:	e0 6b 00 a5 	mov	r11,165
80004876:	0c 9c       	mov	r12,r6
80004878:	f0 1f 00 4f 	mcall	800049b4 <xTaskGenericCreate+0x18c>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
8000487c:	ee c6 00 01 	sub	r6,r7,1
80004880:	6a c8       	ld.w	r8,r5[0x30]
80004882:	f0 06 00 26 	add	r6,r8,r6<<0x2
80004886:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
8000488a:	31 0a       	mov	r10,16
8000488c:	02 9b       	mov	r11,r1
8000488e:	ea cc ff cc 	sub	r12,r5,-52
80004892:	f0 1f 00 4a 	mcall	800049b8 <xTaskGenericCreate+0x190>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80004896:	30 08       	mov	r8,0
80004898:	eb 68 00 43 	st.b	r5[67],r8
8000489c:	58 73       	cp.w	r3,7
8000489e:	e6 07 17 80 	movls	r7,r3
800048a2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
800048a6:	8b b7       	st.w	r5[0x2c],r7
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
800048a8:	ea c4 ff fc 	sub	r4,r5,-4
800048ac:	08 9c       	mov	r12,r4
800048ae:	f0 1f 00 44 	mcall	800049bc <xTaskGenericCreate+0x194>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
800048b2:	ea cc ff e8 	sub	r12,r5,-24
800048b6:	f0 1f 00 42 	mcall	800049bc <xTaskGenericCreate+0x194>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
800048ba:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
800048bc:	ee 07 11 08 	rsub	r7,r7,8
800048c0:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
800048c2:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
800048c4:	00 9a       	mov	r10,r0
800048c6:	40 0b       	lddsp	r11,sp[0x0]
800048c8:	0c 9c       	mov	r12,r6
800048ca:	f0 1f 00 3e 	mcall	800049c0 <xTaskGenericCreate+0x198>
800048ce:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
800048d0:	58 02       	cp.w	r2,0
800048d2:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
800048d6:	f0 1f 00 3c 	mcall	800049c4 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
800048da:	4b c8       	lddpc	r8,800049c8 <xTaskGenericCreate+0x1a0>
800048dc:	70 09       	ld.w	r9,r8[0x0]
800048de:	2f f9       	sub	r9,-1
800048e0:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
800048e2:	4b b8       	lddpc	r8,800049cc <xTaskGenericCreate+0x1a4>
800048e4:	70 08       	ld.w	r8,r8[0x0]
800048e6:	58 08       	cp.w	r8,0
800048e8:	c2 61       	brne	80004934 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
800048ea:	4b 98       	lddpc	r8,800049cc <xTaskGenericCreate+0x1a4>
800048ec:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
800048ee:	4b 78       	lddpc	r8,800049c8 <xTaskGenericCreate+0x1a0>
800048f0:	70 08       	ld.w	r8,r8[0x0]
800048f2:	58 18       	cp.w	r8,1
800048f4:	c2 b1       	brne	8000494a <xTaskGenericCreate+0x122>
800048f6:	4b 77       	lddpc	r7,800049d0 <xTaskGenericCreate+0x1a8>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
800048f8:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800048fc:	0e 9c       	mov	r12,r7
800048fe:	f0 1f 00 36 	mcall	800049d4 <xTaskGenericCreate+0x1ac>
80004902:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80004904:	0c 37       	cp.w	r7,r6
80004906:	cf b1       	brne	800048fc <xTaskGenericCreate+0xd4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80004908:	4b 47       	lddpc	r7,800049d8 <xTaskGenericCreate+0x1b0>
8000490a:	0e 9c       	mov	r12,r7
8000490c:	f0 1f 00 32 	mcall	800049d4 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80004910:	4b 36       	lddpc	r6,800049dc <xTaskGenericCreate+0x1b4>
80004912:	0c 9c       	mov	r12,r6
80004914:	f0 1f 00 30 	mcall	800049d4 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xPendingReadyList );
80004918:	4b 2c       	lddpc	r12,800049e0 <xTaskGenericCreate+0x1b8>
8000491a:	f0 1f 00 2f 	mcall	800049d4 <xTaskGenericCreate+0x1ac>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
8000491e:	4b 2c       	lddpc	r12,800049e4 <xTaskGenericCreate+0x1bc>
80004920:	f0 1f 00 2d 	mcall	800049d4 <xTaskGenericCreate+0x1ac>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80004924:	4b 1c       	lddpc	r12,800049e8 <xTaskGenericCreate+0x1c0>
80004926:	f0 1f 00 2c 	mcall	800049d4 <xTaskGenericCreate+0x1ac>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000492a:	4b 18       	lddpc	r8,800049ec <xTaskGenericCreate+0x1c4>
8000492c:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
8000492e:	4b 18       	lddpc	r8,800049f0 <xTaskGenericCreate+0x1c8>
80004930:	91 06       	st.w	r8[0x0],r6
80004932:	c0 c8       	rjmp	8000494a <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80004934:	4b 08       	lddpc	r8,800049f4 <xTaskGenericCreate+0x1cc>
80004936:	70 08       	ld.w	r8,r8[0x0]
80004938:	58 08       	cp.w	r8,0
8000493a:	c0 81       	brne	8000494a <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
8000493c:	4a 48       	lddpc	r8,800049cc <xTaskGenericCreate+0x1a4>
8000493e:	70 08       	ld.w	r8,r8[0x0]
80004940:	70 b8       	ld.w	r8,r8[0x2c]
80004942:	10 33       	cp.w	r3,r8
80004944:	c0 33       	brcs	8000494a <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
80004946:	4a 28       	lddpc	r8,800049cc <xTaskGenericCreate+0x1a4>
80004948:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000494a:	6a b8       	ld.w	r8,r5[0x2c]
8000494c:	4a b9       	lddpc	r9,800049f8 <xTaskGenericCreate+0x1d0>
8000494e:	72 09       	ld.w	r9,r9[0x0]
80004950:	12 38       	cp.w	r8,r9
80004952:	e0 88 00 04 	brls	8000495a <xTaskGenericCreate+0x132>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80004956:	4a 99       	lddpc	r9,800049f8 <xTaskGenericCreate+0x1d0>
80004958:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000495a:	4a 98       	lddpc	r8,800049fc <xTaskGenericCreate+0x1d4>
8000495c:	70 09       	ld.w	r9,r8[0x0]
8000495e:	2f f9       	sub	r9,-1
80004960:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80004962:	6a b8       	ld.w	r8,r5[0x2c]
80004964:	4a 79       	lddpc	r9,80004a00 <xTaskGenericCreate+0x1d8>
80004966:	72 09       	ld.w	r9,r9[0x0]
80004968:	12 38       	cp.w	r8,r9
8000496a:	e0 88 00 04 	brls	80004972 <xTaskGenericCreate+0x14a>
8000496e:	4a 59       	lddpc	r9,80004a00 <xTaskGenericCreate+0x1d8>
80004970:	93 08       	st.w	r9[0x0],r8
80004972:	6a bc       	ld.w	r12,r5[0x2c]
80004974:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80004978:	08 9b       	mov	r11,r4
8000497a:	49 68       	lddpc	r8,800049d0 <xTaskGenericCreate+0x1a8>
8000497c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004980:	f0 1f 00 21 	mcall	80004a04 <xTaskGenericCreate+0x1dc>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80004984:	f0 1f 00 21 	mcall	80004a08 <xTaskGenericCreate+0x1e0>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80004988:	49 b8       	lddpc	r8,800049f4 <xTaskGenericCreate+0x1cc>
8000498a:	70 08       	ld.w	r8,r8[0x0]
8000498c:	58 08       	cp.w	r8,0
8000498e:	c0 a0       	breq	800049a2 <xTaskGenericCreate+0x17a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80004990:	48 f8       	lddpc	r8,800049cc <xTaskGenericCreate+0x1a4>
80004992:	70 08       	ld.w	r8,r8[0x0]
80004994:	70 b8       	ld.w	r8,r8[0x2c]
80004996:	10 33       	cp.w	r3,r8
80004998:	e0 88 00 05 	brls	800049a2 <xTaskGenericCreate+0x17a>
			{
				portYIELD_WITHIN_API();
8000499c:	d7 33       	scall
8000499e:	30 1c       	mov	r12,1
800049a0:	c0 28       	rjmp	800049a4 <xTaskGenericCreate+0x17c>
800049a2:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800049a4:	2f fd       	sub	sp,-4
800049a6:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800049a8:	99 c6       	st.w	r12[0x30],r6
800049aa:	c6 1b       	rjmp	8000486c <xTaskGenericCreate+0x44>
800049ac:	80 00       	ld.sh	r0,r0[0x0]
800049ae:	43 b0       	lddsp	r0,sp[0xec]
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	43 88       	lddsp	r8,sp[0xe0]
800049b4:	80 00       	ld.sh	r0,r0[0x0]
800049b6:	51 00       	stdsp	sp[0x40],r0
800049b8:	80 00       	ld.sh	r0,r0[0x0]
800049ba:	52 50       	stdsp	sp[0x94],r0
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	40 98       	lddsp	r8,sp[0x24]
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	41 14       	lddsp	r4,sp[0x44]
800049c4:	80 00       	ld.sh	r0,r0[0x0]
800049c6:	41 a8       	lddsp	r8,sp[0x68]
800049c8:	00 00       	add	r0,r0
800049ca:	09 b8       	ld.ub	r8,r4[0x3]
800049cc:	00 00       	add	r0,r0
800049ce:	09 6c       	ld.uh	r12,--r4
800049d0:	00 00       	add	r0,r0
800049d2:	08 b8       	st.h	r4++,r8
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	40 84       	lddsp	r4,sp[0x20]
800049d8:	00 00       	add	r0,r0
800049da:	09 84       	ld.ub	r4,r4[0x0]
800049dc:	00 00       	add	r0,r0
800049de:	09 a0       	ld.ub	r0,r4[0x2]
800049e0:	00 00       	add	r0,r0
800049e2:	09 70       	ld.ub	r0,--r4
800049e4:	00 00       	add	r0,r0
800049e6:	09 58       	ld.sh	r8,--r4
800049e8:	00 00       	add	r0,r0
800049ea:	09 c0       	ld.ub	r0,r4[0x4]
800049ec:	00 00       	add	r0,r0
800049ee:	08 a4       	st.w	r4++,r4
800049f0:	00 00       	add	r0,r0
800049f2:	08 b4       	st.h	r4++,r4
800049f4:	00 00       	add	r0,r0
800049f6:	08 a8       	st.w	r4++,r8
800049f8:	00 00       	add	r0,r0
800049fa:	08 a0       	st.w	r4++,r0
800049fc:	00 00       	add	r0,r0
800049fe:	09 b4       	ld.ub	r4,r4[0x3]
80004a00:	00 00       	add	r0,r0
80004a02:	09 d4       	ld.ub	r4,r4[0x5]
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	40 9e       	lddsp	lr,sp[0x24]
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	42 b4       	lddsp	r4,sp[0xac]

80004a0c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80004a0c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80004a0e:	30 09       	mov	r9,0
80004a10:	1a d9       	st.w	--sp,r9
80004a12:	1a d9       	st.w	--sp,r9
80004a14:	1a d9       	st.w	--sp,r9
80004a16:	12 98       	mov	r8,r9
80004a18:	e0 6a 01 00 	mov	r10,256
80004a1c:	48 9b       	lddpc	r11,80004a40 <vTaskStartScheduler+0x34>
80004a1e:	48 ac       	lddpc	r12,80004a44 <vTaskStartScheduler+0x38>
80004a20:	f0 1f 00 0a 	mcall	80004a48 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80004a24:	2f dd       	sub	sp,-12
80004a26:	58 1c       	cp.w	r12,1
80004a28:	c0 a1       	brne	80004a3c <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80004a2a:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80004a2c:	30 19       	mov	r9,1
80004a2e:	48 88       	lddpc	r8,80004a4c <vTaskStartScheduler+0x40>
80004a30:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80004a32:	30 09       	mov	r9,0
80004a34:	48 78       	lddpc	r8,80004a50 <vTaskStartScheduler+0x44>
80004a36:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80004a38:	f0 1f 00 07 	mcall	80004a54 <vTaskStartScheduler+0x48>
80004a3c:	d8 02       	popm	pc
80004a3e:	00 00       	add	r0,r0
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	5f 08       	sreq	r8
80004a44:	80 00       	ld.sh	r0,r0[0x0]
80004a46:	47 a8       	lddsp	r8,sp[0x1e8]
80004a48:	80 00       	ld.sh	r0,r0[0x0]
80004a4a:	48 28       	lddpc	r8,80004a50 <vTaskStartScheduler+0x44>
80004a4c:	00 00       	add	r0,r0
80004a4e:	08 a8       	st.w	r4++,r8
80004a50:	00 00       	add	r0,r0
80004a52:	09 98       	ld.ub	r8,r4[0x1]
80004a54:	80 00       	ld.sh	r0,r0[0x0]
80004a56:	41 b8       	lddsp	r8,sp[0x6c]

80004a58 <vCpuWork>:
	// Start the scheduler, anything after this will not run.
	vTaskStartScheduler();
}

static void vCpuWork(void *pvParameters)
{
80004a58:	eb cd 40 c0 	pushm	r6-r7,lr
80004a5c:	30 08       	mov	r8,0
	{
		for(i=0; i<1000000; i++)
		{
			dummy = 2.5 * i; //not important
		}
		gpio_toggle_pin(LED0_GPIO);
80004a5e:	32 36       	mov	r6,35
80004a60:	10 97       	mov	r7,r8
80004a62:	c0 28       	rjmp	80004a66 <vCpuWork+0xe>
{
	int i;
	double dummy;
	while(1)
	{
		for(i=0; i<1000000; i++)
80004a64:	2f f8       	sub	r8,-1
80004a66:	ee 58 42 3f 	cp.w	r8,999999
80004a6a:	fe 9a ff fd 	brle	80004a64 <vCpuWork+0xc>
		{
			dummy = 2.5 * i; //not important
		}
		gpio_toggle_pin(LED0_GPIO);
80004a6e:	0c 9c       	mov	r12,r6
80004a70:	f0 1f 00 02 	mcall	80004a78 <vCpuWork+0x20>
80004a74:	0e 98       	mov	r8,r7
80004a76:	cf 8b       	rjmp	80004a66 <vCpuWork+0xe>
80004a78:	80 00       	ld.sh	r0,r0[0x0]
80004a7a:	22 74       	sub	r4,39

80004a7c <vMonitorC>:
			gpio_set_pin_high(RESPONSE_B);
		}
	}
}

static void vMonitorC(void){
80004a7c:	eb cd 40 f8 	pushm	r3-r7,lr
80004a80:	20 1d       	sub	sp,4
	portTickType startTimeC = xTaskGetTickCount();
80004a82:	f0 1f 00 10 	mcall	80004ac0 <vMonitorC+0x44>
80004a86:	fa c7 ff fc 	sub	r7,sp,-4
80004a8a:	0e dc       	st.w	--r7,r12
	while(1){
		vTaskDelayUntil(&startTimeC,5/portTICK_RATE_MS);
80004a8c:	30 56       	mov	r6,5
		startTimeC = xTaskGetTickCount();
		
		if (!gpio_get_pin_value(TEST_C)) {
80004a8e:	31 b5       	mov	r5,27
			gpio_set_pin_low(RESPONSE_C);
80004a90:	32 04       	mov	r4,32
			vTaskDelay(1);
80004a92:	30 13       	mov	r3,1
}

static void vMonitorC(void){
	portTickType startTimeC = xTaskGetTickCount();
	while(1){
		vTaskDelayUntil(&startTimeC,5/portTICK_RATE_MS);
80004a94:	0c 9b       	mov	r11,r6
80004a96:	1a 9c       	mov	r12,sp
80004a98:	f0 1f 00 0b 	mcall	80004ac4 <vMonitorC+0x48>
		startTimeC = xTaskGetTickCount();
80004a9c:	f0 1f 00 09 	mcall	80004ac0 <vMonitorC+0x44>
80004aa0:	50 0c       	stdsp	sp[0x0],r12
		
		if (!gpio_get_pin_value(TEST_C)) {
80004aa2:	0a 9c       	mov	r12,r5
80004aa4:	f0 1f 00 09 	mcall	80004ac8 <vMonitorC+0x4c>
80004aa8:	cf 61       	brne	80004a94 <vMonitorC+0x18>
			gpio_set_pin_low(RESPONSE_C);
80004aaa:	08 9c       	mov	r12,r4
80004aac:	f0 1f 00 08 	mcall	80004acc <vMonitorC+0x50>
			vTaskDelay(1);
80004ab0:	06 9c       	mov	r12,r3
80004ab2:	f0 1f 00 08 	mcall	80004ad0 <vMonitorC+0x54>
			gpio_set_pin_high(RESPONSE_C);
80004ab6:	08 9c       	mov	r12,r4
80004ab8:	f0 1f 00 07 	mcall	80004ad4 <vMonitorC+0x58>
80004abc:	ce cb       	rjmp	80004a94 <vMonitorC+0x18>
80004abe:	00 00       	add	r0,r0
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	44 64       	lddsp	r4,sp[0x118]
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	47 28       	lddsp	r8,sp[0x1c8]
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	22 32       	sub	r2,35
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	22 5e       	sub	lr,37
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	46 e0       	lddsp	r0,sp[0x1b8]
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	22 48       	sub	r8,36

80004ad8 <vMonitorB>:
			gpio_set_pin_high(RESPONSE_A);
		}
	}
}

static void vMonitorB(void){
80004ad8:	eb cd 40 f8 	pushm	r3-r7,lr
80004adc:	20 1d       	sub	sp,4
	portTickType startTimeB = xTaskGetTickCount();
80004ade:	f0 1f 00 10 	mcall	80004b1c <vMonitorB+0x44>
80004ae2:	fa c7 ff fc 	sub	r7,sp,-4
80004ae6:	0e dc       	st.w	--r7,r12
	while(1){
		vTaskDelayUntil(&startTimeB,5/portTICK_RATE_MS);
80004ae8:	30 56       	mov	r6,5
		startTimeB = xTaskGetTickCount();
		
		if (!gpio_get_pin_value(TEST_B)) {
80004aea:	31 d5       	mov	r5,29
			gpio_set_pin_low(RESPONSE_B);
80004aec:	31 c4       	mov	r4,28
			vTaskDelay(1);
80004aee:	30 13       	mov	r3,1
}

static void vMonitorB(void){
	portTickType startTimeB = xTaskGetTickCount();
	while(1){
		vTaskDelayUntil(&startTimeB,5/portTICK_RATE_MS);
80004af0:	0c 9b       	mov	r11,r6
80004af2:	1a 9c       	mov	r12,sp
80004af4:	f0 1f 00 0b 	mcall	80004b20 <vMonitorB+0x48>
		startTimeB = xTaskGetTickCount();
80004af8:	f0 1f 00 09 	mcall	80004b1c <vMonitorB+0x44>
80004afc:	50 0c       	stdsp	sp[0x0],r12
		
		if (!gpio_get_pin_value(TEST_B)) {
80004afe:	0a 9c       	mov	r12,r5
80004b00:	f0 1f 00 09 	mcall	80004b24 <vMonitorB+0x4c>
80004b04:	cf 61       	brne	80004af0 <vMonitorB+0x18>
			gpio_set_pin_low(RESPONSE_B);
80004b06:	08 9c       	mov	r12,r4
80004b08:	f0 1f 00 08 	mcall	80004b28 <vMonitorB+0x50>
			vTaskDelay(1);
80004b0c:	06 9c       	mov	r12,r3
80004b0e:	f0 1f 00 08 	mcall	80004b2c <vMonitorB+0x54>
			gpio_set_pin_high(RESPONSE_B);
80004b12:	08 9c       	mov	r12,r4
80004b14:	f0 1f 00 07 	mcall	80004b30 <vMonitorB+0x58>
80004b18:	ce cb       	rjmp	80004af0 <vMonitorB+0x18>
80004b1a:	00 00       	add	r0,r0
80004b1c:	80 00       	ld.sh	r0,r0[0x0]
80004b1e:	44 64       	lddsp	r4,sp[0x118]
80004b20:	80 00       	ld.sh	r0,r0[0x0]
80004b22:	47 28       	lddsp	r8,sp[0x1c8]
80004b24:	80 00       	ld.sh	r0,r0[0x0]
80004b26:	22 32       	sub	r2,35
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	22 5e       	sub	lr,37
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	46 e0       	lddsp	r0,sp[0x1b8]
80004b30:	80 00       	ld.sh	r0,r0[0x0]
80004b32:	22 48       	sub	r8,36

80004b34 <vMonitorA>:
		gpio_toggle_pin(LED0_GPIO);
	}
}


static void vMonitorA(void){
80004b34:	eb cd 40 f8 	pushm	r3-r7,lr
80004b38:	20 1d       	sub	sp,4
	portTickType startTimeA = xTaskGetTickCount();
80004b3a:	f0 1f 00 10 	mcall	80004b78 <vMonitorA+0x44>
80004b3e:	fa c7 ff fc 	sub	r7,sp,-4
80004b42:	0e dc       	st.w	--r7,r12
	while(1){
		vTaskDelayUntil(&startTimeA,5/portTICK_RATE_MS);
80004b44:	30 56       	mov	r6,5
		startTimeA = xTaskGetTickCount();
		
		if (!gpio_get_pin_value(TEST_A)) {
80004b46:	31 f5       	mov	r5,31
			gpio_set_pin_low(RESPONSE_A);
80004b48:	31 e4       	mov	r4,30
			vTaskDelay(1);
80004b4a:	30 13       	mov	r3,1


static void vMonitorA(void){
	portTickType startTimeA = xTaskGetTickCount();
	while(1){
		vTaskDelayUntil(&startTimeA,5/portTICK_RATE_MS);
80004b4c:	0c 9b       	mov	r11,r6
80004b4e:	1a 9c       	mov	r12,sp
80004b50:	f0 1f 00 0b 	mcall	80004b7c <vMonitorA+0x48>
		startTimeA = xTaskGetTickCount();
80004b54:	f0 1f 00 09 	mcall	80004b78 <vMonitorA+0x44>
80004b58:	50 0c       	stdsp	sp[0x0],r12
		
		if (!gpio_get_pin_value(TEST_A)) {
80004b5a:	0a 9c       	mov	r12,r5
80004b5c:	f0 1f 00 09 	mcall	80004b80 <vMonitorA+0x4c>
80004b60:	cf 61       	brne	80004b4c <vMonitorA+0x18>
			gpio_set_pin_low(RESPONSE_A);
80004b62:	08 9c       	mov	r12,r4
80004b64:	f0 1f 00 08 	mcall	80004b84 <vMonitorA+0x50>
			vTaskDelay(1);
80004b68:	06 9c       	mov	r12,r3
80004b6a:	f0 1f 00 08 	mcall	80004b88 <vMonitorA+0x54>
			gpio_set_pin_high(RESPONSE_A);
80004b6e:	08 9c       	mov	r12,r4
80004b70:	f0 1f 00 07 	mcall	80004b8c <vMonitorA+0x58>
80004b74:	ce cb       	rjmp	80004b4c <vMonitorA+0x18>
80004b76:	00 00       	add	r0,r0
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	44 64       	lddsp	r4,sp[0x118]
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	47 28       	lddsp	r8,sp[0x1c8]
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	22 32       	sub	r2,35
80004b84:	80 00       	ld.sh	r0,r0[0x0]
80004b86:	22 5e       	sub	lr,37
80004b88:	80 00       	ld.sh	r0,r0[0x0]
80004b8a:	46 e0       	lddsp	r0,sp[0x1b8]
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	22 48       	sub	r8,36

80004b90 <init>:
#define RESPONSE_B AVR32_PIN_PA28
#define TEST_C AVR32_PIN_PA27
#define RESPONSE_C AVR32_PIN_PB00

void init()
{
80004b90:	eb cd 40 80 	pushm	r7,lr
	// board init
	board_init();
80004b94:	f0 1f 00 0e 	mcall	80004bcc <init+0x3c>
		.dfll_f       = EXAMPLE_TARGET_DFLL_FREQ_HZ,
		.pextra_params = &gc_dfllif_ref_opt
	};
	pcl_configure_clocks(&pcl_dfll_freq_param);
#else
	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
80004b98:	30 3a       	mov	r10,3
80004b9a:	e0 6b 1b 00 	mov	r11,6912
80004b9e:	ea 1b 00 b7 	orh	r11,0xb7
80004ba2:	30 0c       	mov	r12,0
80004ba4:	f0 1f 00 0b 	mcall	80004bd0 <init+0x40>
#endif	
	
	// stdio init
	stdio_usb_init(&CONFIG_USART_IF);
80004ba8:	fe 7c 1c 00 	mov	r12,-58368
80004bac:	f0 1f 00 0a 	mcall	80004bd4 <init+0x44>

	// Specify that stdout and stdin should not be buffered.

#if defined(__GNUC__) && defined(__AVR32__)
	setbuf(stdout, NULL);
80004bb0:	48 a7       	lddpc	r7,80004bd8 <init+0x48>
80004bb2:	6e 08       	ld.w	r8,r7[0x0]
80004bb4:	30 0b       	mov	r11,0
80004bb6:	70 1c       	ld.w	r12,r8[0x4]
80004bb8:	f0 1f 00 09 	mcall	80004bdc <init+0x4c>
	setbuf(stdin,  NULL);
80004bbc:	6e 08       	ld.w	r8,r7[0x0]
80004bbe:	30 0b       	mov	r11,0
80004bc0:	70 0c       	ld.w	r12,r8[0x0]
80004bc2:	f0 1f 00 07 	mcall	80004bdc <init+0x4c>
#endif
}
80004bc6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004bca:	00 00       	add	r0,r0
80004bcc:	80 00       	ld.sh	r0,r0[0x0]
80004bce:	20 ec       	sub	r12,14
80004bd0:	80 00       	ld.sh	r0,r0[0x0]
80004bd2:	24 00       	sub	r0,64
80004bd4:	80 00       	ld.sh	r0,r0[0x0]
80004bd6:	3f ac       	mov	r12,-6
80004bd8:	00 00       	add	r0,r0
80004bda:	01 e0       	ld.ub	r0,r0[0x6]
80004bdc:	80 00       	ld.sh	r0,r0[0x0]
80004bde:	51 30       	stdsp	sp[0x4c],r0

80004be0 <main>:

/*********************************************************************
Functions
*********************************************************************/
int main()
{
80004be0:	eb cd 40 80 	pushm	r7,lr
	// initialize
	init();
80004be4:	f0 1f 00 1d 	mcall	80004c58 <main+0x78>
	
	// start code from here
	gpio_toggle_pin(LED0_GPIO);
80004be8:	32 3c       	mov	r12,35
80004bea:	f0 1f 00 1d 	mcall	80004c5c <main+0x7c>
	//xTaskCreate( vBasicTask, (signed char * ) "BASIC", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
	
	//xTaskCreate( vToggleLed0, NULL, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
	//xTaskCreate( vToggleLed1, NULL, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
	
	xTaskCreate( vCpuWork, NULL, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
80004bee:	30 07       	mov	r7,0
80004bf0:	1a d7       	st.w	--sp,r7
80004bf2:	1a d7       	st.w	--sp,r7
80004bf4:	1a d7       	st.w	--sp,r7
80004bf6:	30 18       	mov	r8,1
80004bf8:	0e 99       	mov	r9,r7
80004bfa:	e0 6a 01 00 	mov	r10,256
80004bfe:	0e 9b       	mov	r11,r7
80004c00:	49 8c       	lddpc	r12,80004c60 <main+0x80>
80004c02:	f0 1f 00 19 	mcall	80004c64 <main+0x84>
	
	xTaskCreate( vMonitorA, NULL, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, NULL);
80004c06:	1a d7       	st.w	--sp,r7
80004c08:	1a d7       	st.w	--sp,r7
80004c0a:	1a d7       	st.w	--sp,r7
80004c0c:	30 28       	mov	r8,2
80004c0e:	0e 99       	mov	r9,r7
80004c10:	e0 6a 01 00 	mov	r10,256
80004c14:	0e 9b       	mov	r11,r7
80004c16:	49 5c       	lddpc	r12,80004c68 <main+0x88>
80004c18:	f0 1f 00 13 	mcall	80004c64 <main+0x84>
	xTaskCreate( vMonitorB, NULL, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, NULL);
80004c1c:	1a d7       	st.w	--sp,r7
80004c1e:	1a d7       	st.w	--sp,r7
80004c20:	1a d7       	st.w	--sp,r7
80004c22:	30 28       	mov	r8,2
80004c24:	0e 99       	mov	r9,r7
80004c26:	e0 6a 01 00 	mov	r10,256
80004c2a:	0e 9b       	mov	r11,r7
80004c2c:	49 0c       	lddpc	r12,80004c6c <main+0x8c>
80004c2e:	f0 1f 00 0e 	mcall	80004c64 <main+0x84>
	xTaskCreate( vMonitorC, NULL, configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, NULL);
80004c32:	2f 7d       	sub	sp,-36
80004c34:	1a d7       	st.w	--sp,r7
80004c36:	1a d7       	st.w	--sp,r7
80004c38:	1a d7       	st.w	--sp,r7
80004c3a:	30 28       	mov	r8,2
80004c3c:	0e 99       	mov	r9,r7
80004c3e:	e0 6a 01 00 	mov	r10,256
80004c42:	0e 9b       	mov	r11,r7
80004c44:	48 bc       	lddpc	r12,80004c70 <main+0x90>
80004c46:	f0 1f 00 08 	mcall	80004c64 <main+0x84>

	// Start the scheduler, anything after this will not run.
	vTaskStartScheduler();
80004c4a:	f0 1f 00 0b 	mcall	80004c74 <main+0x94>
80004c4e:	2f dd       	sub	sp,-12
}
80004c50:	0e 9c       	mov	r12,r7
80004c52:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c56:	00 00       	add	r0,r0
80004c58:	80 00       	ld.sh	r0,r0[0x0]
80004c5a:	4b 90       	lddpc	r0,80004d3c <_malloc_r+0x70>
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	22 74       	sub	r4,39
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	4a 58       	lddpc	r8,80004cf4 <_malloc_r+0x28>
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	48 28       	lddpc	r8,80004c6c <main+0x8c>
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	4b 34       	lddpc	r4,80004d34 <_malloc_r+0x68>
80004c6c:	80 00       	ld.sh	r0,r0[0x0]
80004c6e:	4a d8       	lddpc	r8,80004d20 <_malloc_r+0x54>
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	4a 7c       	lddpc	r12,80004d0c <_malloc_r+0x40>
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	4a 0c       	lddpc	r12,80004cf4 <_malloc_r+0x28>

80004c78 <atexit>:
80004c78:	d4 01       	pushm	lr
80004c7a:	30 09       	mov	r9,0
80004c7c:	18 9b       	mov	r11,r12
80004c7e:	12 9a       	mov	r10,r9
80004c80:	12 9c       	mov	r12,r9
80004c82:	e0 a0 03 37 	rcall	800052f0 <__register_exitproc>
80004c86:	d8 02       	popm	pc

80004c88 <exit>:
80004c88:	d4 21       	pushm	r4-r7,lr
80004c8a:	30 0b       	mov	r11,0
80004c8c:	18 97       	mov	r7,r12
80004c8e:	e0 a0 03 85 	rcall	80005398 <__call_exitprocs>
80004c92:	48 58       	lddpc	r8,80004ca4 <exit+0x1c>
80004c94:	70 0c       	ld.w	r12,r8[0x0]
80004c96:	78 a8       	ld.w	r8,r12[0x28]
80004c98:	58 08       	cp.w	r8,0
80004c9a:	c0 20       	breq	80004c9e <exit+0x16>
80004c9c:	5d 18       	icall	r8
80004c9e:	0e 9c       	mov	r12,r7
80004ca0:	e0 a0 02 ed 	rcall	8000527a <_exit>
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	5f 14       	srne	r4

80004ca8 <free>:
80004ca8:	d4 01       	pushm	lr
80004caa:	48 48       	lddpc	r8,80004cb8 <free+0x10>
80004cac:	18 9b       	mov	r11,r12
80004cae:	70 0c       	ld.w	r12,r8[0x0]
80004cb0:	e0 a0 05 5a 	rcall	80005764 <_free_r>
80004cb4:	d8 02       	popm	pc
80004cb6:	d7 03       	nop
80004cb8:	00 00       	add	r0,r0
80004cba:	01 e0       	ld.ub	r0,r0[0x6]

80004cbc <malloc>:
80004cbc:	d4 01       	pushm	lr
80004cbe:	48 38       	lddpc	r8,80004cc8 <malloc+0xc>
80004cc0:	18 9b       	mov	r11,r12
80004cc2:	70 0c       	ld.w	r12,r8[0x0]
80004cc4:	c0 4c       	rcall	80004ccc <_malloc_r>
80004cc6:	d8 02       	popm	pc
80004cc8:	00 00       	add	r0,r0
80004cca:	01 e0       	ld.ub	r0,r0[0x6]

80004ccc <_malloc_r>:
80004ccc:	d4 31       	pushm	r0-r7,lr
80004cce:	f6 c8 ff f5 	sub	r8,r11,-11
80004cd2:	18 95       	mov	r5,r12
80004cd4:	10 97       	mov	r7,r8
80004cd6:	e0 17 ff f8 	andl	r7,0xfff8
80004cda:	59 68       	cp.w	r8,22
80004cdc:	f9 b7 08 10 	movls	r7,16
80004ce0:	16 37       	cp.w	r7,r11
80004ce2:	5f 38       	srlo	r8
80004ce4:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80004ce8:	c0 50       	breq	80004cf2 <_malloc_r+0x26>
80004cea:	30 c8       	mov	r8,12
80004cec:	99 38       	st.w	r12[0xc],r8
80004cee:	e0 8f 01 ed 	bral	800050c8 <_malloc_r+0x3fc>
80004cf2:	fe b0 fb 33 	rcall	80004358 <__malloc_lock>
80004cf6:	e0 47 01 f7 	cp.w	r7,503
80004cfa:	e0 8b 00 1c 	brhi	80004d32 <_malloc_r+0x66>
80004cfe:	ee 03 16 03 	lsr	r3,r7,0x3
80004d02:	4c c8       	lddpc	r8,80004e30 <_malloc_r+0x164>
80004d04:	f0 03 00 38 	add	r8,r8,r3<<0x3
80004d08:	70 36       	ld.w	r6,r8[0xc]
80004d0a:	10 36       	cp.w	r6,r8
80004d0c:	c0 61       	brne	80004d18 <_malloc_r+0x4c>
80004d0e:	ec c8 ff f8 	sub	r8,r6,-8
80004d12:	70 36       	ld.w	r6,r8[0xc]
80004d14:	10 36       	cp.w	r6,r8
80004d16:	c0 c0       	breq	80004d2e <_malloc_r+0x62>
80004d18:	6c 18       	ld.w	r8,r6[0x4]
80004d1a:	e0 18 ff fc 	andl	r8,0xfffc
80004d1e:	6c 3a       	ld.w	r10,r6[0xc]
80004d20:	ec 08 00 09 	add	r9,r6,r8
80004d24:	0a 9c       	mov	r12,r5
80004d26:	6c 28       	ld.w	r8,r6[0x8]
80004d28:	95 28       	st.w	r10[0x8],r8
80004d2a:	91 3a       	st.w	r8[0xc],r10
80004d2c:	c4 68       	rjmp	80004db8 <_malloc_r+0xec>
80004d2e:	2f e3       	sub	r3,-2
80004d30:	c4 c8       	rjmp	80004dc8 <_malloc_r+0xfc>
80004d32:	ee 03 16 09 	lsr	r3,r7,0x9
80004d36:	c0 41       	brne	80004d3e <_malloc_r+0x72>
80004d38:	ee 03 16 03 	lsr	r3,r7,0x3
80004d3c:	c2 68       	rjmp	80004d88 <_malloc_r+0xbc>
80004d3e:	58 43       	cp.w	r3,4
80004d40:	e0 8b 00 06 	brhi	80004d4c <_malloc_r+0x80>
80004d44:	ee 03 16 06 	lsr	r3,r7,0x6
80004d48:	2c 83       	sub	r3,-56
80004d4a:	c1 f8       	rjmp	80004d88 <_malloc_r+0xbc>
80004d4c:	59 43       	cp.w	r3,20
80004d4e:	e0 8b 00 04 	brhi	80004d56 <_malloc_r+0x8a>
80004d52:	2a 53       	sub	r3,-91
80004d54:	c1 a8       	rjmp	80004d88 <_malloc_r+0xbc>
80004d56:	e0 43 00 54 	cp.w	r3,84
80004d5a:	e0 8b 00 06 	brhi	80004d66 <_malloc_r+0x9a>
80004d5e:	ee 03 16 0c 	lsr	r3,r7,0xc
80004d62:	29 23       	sub	r3,-110
80004d64:	c1 28       	rjmp	80004d88 <_malloc_r+0xbc>
80004d66:	e0 43 01 54 	cp.w	r3,340
80004d6a:	e0 8b 00 06 	brhi	80004d76 <_malloc_r+0xaa>
80004d6e:	ee 03 16 0f 	lsr	r3,r7,0xf
80004d72:	28 93       	sub	r3,-119
80004d74:	c0 a8       	rjmp	80004d88 <_malloc_r+0xbc>
80004d76:	e0 43 05 54 	cp.w	r3,1364
80004d7a:	e0 88 00 04 	brls	80004d82 <_malloc_r+0xb6>
80004d7e:	37 e3       	mov	r3,126
80004d80:	c0 48       	rjmp	80004d88 <_malloc_r+0xbc>
80004d82:	ee 03 16 12 	lsr	r3,r7,0x12
80004d86:	28 43       	sub	r3,-124
80004d88:	4a aa       	lddpc	r10,80004e30 <_malloc_r+0x164>
80004d8a:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80004d8e:	74 36       	ld.w	r6,r10[0xc]
80004d90:	c1 98       	rjmp	80004dc2 <_malloc_r+0xf6>
80004d92:	6c 19       	ld.w	r9,r6[0x4]
80004d94:	e0 19 ff fc 	andl	r9,0xfffc
80004d98:	f2 07 01 0b 	sub	r11,r9,r7
80004d9c:	58 fb       	cp.w	r11,15
80004d9e:	e0 8a 00 04 	brle	80004da6 <_malloc_r+0xda>
80004da2:	20 13       	sub	r3,1
80004da4:	c1 18       	rjmp	80004dc6 <_malloc_r+0xfa>
80004da6:	6c 38       	ld.w	r8,r6[0xc]
80004da8:	58 0b       	cp.w	r11,0
80004daa:	c0 b5       	brlt	80004dc0 <_malloc_r+0xf4>
80004dac:	6c 2a       	ld.w	r10,r6[0x8]
80004dae:	ec 09 00 09 	add	r9,r6,r9
80004db2:	0a 9c       	mov	r12,r5
80004db4:	91 2a       	st.w	r8[0x8],r10
80004db6:	95 38       	st.w	r10[0xc],r8
80004db8:	72 18       	ld.w	r8,r9[0x4]
80004dba:	a1 a8       	sbr	r8,0x0
80004dbc:	93 18       	st.w	r9[0x4],r8
80004dbe:	cb a8       	rjmp	80004f32 <_malloc_r+0x266>
80004dc0:	10 96       	mov	r6,r8
80004dc2:	14 36       	cp.w	r6,r10
80004dc4:	ce 71       	brne	80004d92 <_malloc_r+0xc6>
80004dc6:	2f f3       	sub	r3,-1
80004dc8:	49 aa       	lddpc	r10,80004e30 <_malloc_r+0x164>
80004dca:	f4 cc ff f8 	sub	r12,r10,-8
80004dce:	78 26       	ld.w	r6,r12[0x8]
80004dd0:	18 36       	cp.w	r6,r12
80004dd2:	c6 c0       	breq	80004eaa <_malloc_r+0x1de>
80004dd4:	6c 19       	ld.w	r9,r6[0x4]
80004dd6:	e0 19 ff fc 	andl	r9,0xfffc
80004dda:	f2 07 01 08 	sub	r8,r9,r7
80004dde:	58 f8       	cp.w	r8,15
80004de0:	e0 89 00 8e 	brgt	80004efc <_malloc_r+0x230>
80004de4:	99 3c       	st.w	r12[0xc],r12
80004de6:	99 2c       	st.w	r12[0x8],r12
80004de8:	58 08       	cp.w	r8,0
80004dea:	c0 55       	brlt	80004df4 <_malloc_r+0x128>
80004dec:	ec 09 00 09 	add	r9,r6,r9
80004df0:	0a 9c       	mov	r12,r5
80004df2:	ce 3b       	rjmp	80004db8 <_malloc_r+0xec>
80004df4:	e0 49 01 ff 	cp.w	r9,511
80004df8:	e0 8b 00 13 	brhi	80004e1e <_malloc_r+0x152>
80004dfc:	a3 99       	lsr	r9,0x3
80004dfe:	f4 09 00 38 	add	r8,r10,r9<<0x3
80004e02:	70 2b       	ld.w	r11,r8[0x8]
80004e04:	8d 38       	st.w	r6[0xc],r8
80004e06:	8d 2b       	st.w	r6[0x8],r11
80004e08:	97 36       	st.w	r11[0xc],r6
80004e0a:	91 26       	st.w	r8[0x8],r6
80004e0c:	a3 49       	asr	r9,0x2
80004e0e:	74 18       	ld.w	r8,r10[0x4]
80004e10:	30 1b       	mov	r11,1
80004e12:	f6 09 09 49 	lsl	r9,r11,r9
80004e16:	f1 e9 10 09 	or	r9,r8,r9
80004e1a:	95 19       	st.w	r10[0x4],r9
80004e1c:	c4 78       	rjmp	80004eaa <_malloc_r+0x1de>
80004e1e:	f2 0a 16 09 	lsr	r10,r9,0x9
80004e22:	58 4a       	cp.w	r10,4
80004e24:	e0 8b 00 08 	brhi	80004e34 <_malloc_r+0x168>
80004e28:	f2 0a 16 06 	lsr	r10,r9,0x6
80004e2c:	2c 8a       	sub	r10,-56
80004e2e:	c2 18       	rjmp	80004e70 <_malloc_r+0x1a4>
80004e30:	00 00       	add	r0,r0
80004e32:	01 e4       	ld.ub	r4,r0[0x6]
80004e34:	59 4a       	cp.w	r10,20
80004e36:	e0 8b 00 04 	brhi	80004e3e <_malloc_r+0x172>
80004e3a:	2a 5a       	sub	r10,-91
80004e3c:	c1 a8       	rjmp	80004e70 <_malloc_r+0x1a4>
80004e3e:	e0 4a 00 54 	cp.w	r10,84
80004e42:	e0 8b 00 06 	brhi	80004e4e <_malloc_r+0x182>
80004e46:	f2 0a 16 0c 	lsr	r10,r9,0xc
80004e4a:	29 2a       	sub	r10,-110
80004e4c:	c1 28       	rjmp	80004e70 <_malloc_r+0x1a4>
80004e4e:	e0 4a 01 54 	cp.w	r10,340
80004e52:	e0 8b 00 06 	brhi	80004e5e <_malloc_r+0x192>
80004e56:	f2 0a 16 0f 	lsr	r10,r9,0xf
80004e5a:	28 9a       	sub	r10,-119
80004e5c:	c0 a8       	rjmp	80004e70 <_malloc_r+0x1a4>
80004e5e:	e0 4a 05 54 	cp.w	r10,1364
80004e62:	e0 88 00 04 	brls	80004e6a <_malloc_r+0x19e>
80004e66:	37 ea       	mov	r10,126
80004e68:	c0 48       	rjmp	80004e70 <_malloc_r+0x1a4>
80004e6a:	f2 0a 16 12 	lsr	r10,r9,0x12
80004e6e:	28 4a       	sub	r10,-124
80004e70:	4c 8b       	lddpc	r11,80004f90 <_malloc_r+0x2c4>
80004e72:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80004e76:	68 28       	ld.w	r8,r4[0x8]
80004e78:	08 38       	cp.w	r8,r4
80004e7a:	c0 e1       	brne	80004e96 <_malloc_r+0x1ca>
80004e7c:	76 19       	ld.w	r9,r11[0x4]
80004e7e:	a3 4a       	asr	r10,0x2
80004e80:	30 1e       	mov	lr,1
80004e82:	fc 0a 09 4a 	lsl	r10,lr,r10
80004e86:	f3 ea 10 0a 	or	r10,r9,r10
80004e8a:	10 99       	mov	r9,r8
80004e8c:	97 1a       	st.w	r11[0x4],r10
80004e8e:	c0 a8       	rjmp	80004ea2 <_malloc_r+0x1d6>
80004e90:	70 28       	ld.w	r8,r8[0x8]
80004e92:	08 38       	cp.w	r8,r4
80004e94:	c0 60       	breq	80004ea0 <_malloc_r+0x1d4>
80004e96:	70 1a       	ld.w	r10,r8[0x4]
80004e98:	e0 1a ff fc 	andl	r10,0xfffc
80004e9c:	14 39       	cp.w	r9,r10
80004e9e:	cf 93       	brcs	80004e90 <_malloc_r+0x1c4>
80004ea0:	70 39       	ld.w	r9,r8[0xc]
80004ea2:	8d 39       	st.w	r6[0xc],r9
80004ea4:	8d 28       	st.w	r6[0x8],r8
80004ea6:	91 36       	st.w	r8[0xc],r6
80004ea8:	93 26       	st.w	r9[0x8],r6
80004eaa:	e6 08 14 02 	asr	r8,r3,0x2
80004eae:	30 1b       	mov	r11,1
80004eb0:	4b 84       	lddpc	r4,80004f90 <_malloc_r+0x2c4>
80004eb2:	f6 08 09 4b 	lsl	r11,r11,r8
80004eb6:	68 18       	ld.w	r8,r4[0x4]
80004eb8:	10 3b       	cp.w	r11,r8
80004eba:	e0 8b 00 6d 	brhi	80004f94 <_malloc_r+0x2c8>
80004ebe:	f7 e8 00 09 	and	r9,r11,r8
80004ec2:	c0 b1       	brne	80004ed8 <_malloc_r+0x20c>
80004ec4:	e0 13 ff fc 	andl	r3,0xfffc
80004ec8:	a1 7b       	lsl	r11,0x1
80004eca:	2f c3       	sub	r3,-4
80004ecc:	c0 38       	rjmp	80004ed2 <_malloc_r+0x206>
80004ece:	2f c3       	sub	r3,-4
80004ed0:	a1 7b       	lsl	r11,0x1
80004ed2:	f7 e8 00 09 	and	r9,r11,r8
80004ed6:	cf c0       	breq	80004ece <_malloc_r+0x202>
80004ed8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80004edc:	06 92       	mov	r2,r3
80004ede:	1c 91       	mov	r1,lr
80004ee0:	62 36       	ld.w	r6,r1[0xc]
80004ee2:	c2 e8       	rjmp	80004f3e <_malloc_r+0x272>
80004ee4:	6c 1a       	ld.w	r10,r6[0x4]
80004ee6:	e0 1a ff fc 	andl	r10,0xfffc
80004eea:	f4 07 01 08 	sub	r8,r10,r7
80004eee:	58 f8       	cp.w	r8,15
80004ef0:	e0 8a 00 15 	brle	80004f1a <_malloc_r+0x24e>
80004ef4:	6c 3a       	ld.w	r10,r6[0xc]
80004ef6:	6c 29       	ld.w	r9,r6[0x8]
80004ef8:	95 29       	st.w	r10[0x8],r9
80004efa:	93 3a       	st.w	r9[0xc],r10
80004efc:	0e 99       	mov	r9,r7
80004efe:	ec 07 00 07 	add	r7,r6,r7
80004f02:	a1 a9       	sbr	r9,0x0
80004f04:	99 37       	st.w	r12[0xc],r7
80004f06:	99 27       	st.w	r12[0x8],r7
80004f08:	8d 19       	st.w	r6[0x4],r9
80004f0a:	ee 08 09 08 	st.w	r7[r8],r8
80004f0e:	8f 2c       	st.w	r7[0x8],r12
80004f10:	8f 3c       	st.w	r7[0xc],r12
80004f12:	a1 a8       	sbr	r8,0x0
80004f14:	0a 9c       	mov	r12,r5
80004f16:	8f 18       	st.w	r7[0x4],r8
80004f18:	c0 d8       	rjmp	80004f32 <_malloc_r+0x266>
80004f1a:	6c 39       	ld.w	r9,r6[0xc]
80004f1c:	58 08       	cp.w	r8,0
80004f1e:	c0 f5       	brlt	80004f3c <_malloc_r+0x270>
80004f20:	ec 0a 00 0a 	add	r10,r6,r10
80004f24:	74 18       	ld.w	r8,r10[0x4]
80004f26:	a1 a8       	sbr	r8,0x0
80004f28:	0a 9c       	mov	r12,r5
80004f2a:	95 18       	st.w	r10[0x4],r8
80004f2c:	6c 28       	ld.w	r8,r6[0x8]
80004f2e:	93 28       	st.w	r9[0x8],r8
80004f30:	91 39       	st.w	r8[0xc],r9
80004f32:	fe b0 fa 19 	rcall	80004364 <__malloc_unlock>
80004f36:	ec cc ff f8 	sub	r12,r6,-8
80004f3a:	d8 32       	popm	r0-r7,pc
80004f3c:	12 96       	mov	r6,r9
80004f3e:	02 36       	cp.w	r6,r1
80004f40:	cd 21       	brne	80004ee4 <_malloc_r+0x218>
80004f42:	2f f2       	sub	r2,-1
80004f44:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80004f48:	c0 30       	breq	80004f4e <_malloc_r+0x282>
80004f4a:	2f 81       	sub	r1,-8
80004f4c:	cc ab       	rjmp	80004ee0 <_malloc_r+0x214>
80004f4e:	1c 98       	mov	r8,lr
80004f50:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80004f54:	c0 81       	brne	80004f64 <_malloc_r+0x298>
80004f56:	68 19       	ld.w	r9,r4[0x4]
80004f58:	f6 08 11 ff 	rsub	r8,r11,-1
80004f5c:	f3 e8 00 08 	and	r8,r9,r8
80004f60:	89 18       	st.w	r4[0x4],r8
80004f62:	c0 78       	rjmp	80004f70 <_malloc_r+0x2a4>
80004f64:	f0 c9 00 08 	sub	r9,r8,8
80004f68:	20 13       	sub	r3,1
80004f6a:	70 08       	ld.w	r8,r8[0x0]
80004f6c:	12 38       	cp.w	r8,r9
80004f6e:	cf 10       	breq	80004f50 <_malloc_r+0x284>
80004f70:	a1 7b       	lsl	r11,0x1
80004f72:	68 18       	ld.w	r8,r4[0x4]
80004f74:	10 3b       	cp.w	r11,r8
80004f76:	e0 8b 00 0f 	brhi	80004f94 <_malloc_r+0x2c8>
80004f7a:	58 0b       	cp.w	r11,0
80004f7c:	c0 c0       	breq	80004f94 <_malloc_r+0x2c8>
80004f7e:	04 93       	mov	r3,r2
80004f80:	c0 38       	rjmp	80004f86 <_malloc_r+0x2ba>
80004f82:	2f c3       	sub	r3,-4
80004f84:	a1 7b       	lsl	r11,0x1
80004f86:	f7 e8 00 09 	and	r9,r11,r8
80004f8a:	ca 71       	brne	80004ed8 <_malloc_r+0x20c>
80004f8c:	cf bb       	rjmp	80004f82 <_malloc_r+0x2b6>
80004f8e:	d7 03       	nop
80004f90:	00 00       	add	r0,r0
80004f92:	01 e4       	ld.ub	r4,r0[0x6]
80004f94:	68 23       	ld.w	r3,r4[0x8]
80004f96:	66 12       	ld.w	r2,r3[0x4]
80004f98:	e0 12 ff fc 	andl	r2,0xfffc
80004f9c:	0e 32       	cp.w	r2,r7
80004f9e:	5f 39       	srlo	r9
80004fa0:	e4 07 01 08 	sub	r8,r2,r7
80004fa4:	58 f8       	cp.w	r8,15
80004fa6:	5f aa       	srle	r10
80004fa8:	f5 e9 10 09 	or	r9,r10,r9
80004fac:	e0 80 00 9a 	breq	800050e0 <_malloc_r+0x414>
80004fb0:	4c 78       	lddpc	r8,800050cc <_malloc_r+0x400>
80004fb2:	70 01       	ld.w	r1,r8[0x0]
80004fb4:	4c 78       	lddpc	r8,800050d0 <_malloc_r+0x404>
80004fb6:	2f 01       	sub	r1,-16
80004fb8:	70 08       	ld.w	r8,r8[0x0]
80004fba:	0e 01       	add	r1,r7
80004fbc:	5b f8       	cp.w	r8,-1
80004fbe:	c0 40       	breq	80004fc6 <_malloc_r+0x2fa>
80004fc0:	28 11       	sub	r1,-127
80004fc2:	e0 11 ff 80 	andl	r1,0xff80
80004fc6:	02 9b       	mov	r11,r1
80004fc8:	0a 9c       	mov	r12,r5
80004fca:	ca 3c       	rcall	80005110 <_sbrk_r>
80004fcc:	18 96       	mov	r6,r12
80004fce:	5b fc       	cp.w	r12,-1
80004fd0:	c6 d0       	breq	800050aa <_malloc_r+0x3de>
80004fd2:	e6 02 00 08 	add	r8,r3,r2
80004fd6:	10 3c       	cp.w	r12,r8
80004fd8:	c0 32       	brcc	80004fde <_malloc_r+0x312>
80004fda:	08 33       	cp.w	r3,r4
80004fdc:	c6 71       	brne	800050aa <_malloc_r+0x3de>
80004fde:	4b ea       	lddpc	r10,800050d4 <_malloc_r+0x408>
80004fe0:	74 09       	ld.w	r9,r10[0x0]
80004fe2:	e2 09 00 09 	add	r9,r1,r9
80004fe6:	95 09       	st.w	r10[0x0],r9
80004fe8:	10 36       	cp.w	r6,r8
80004fea:	c0 a1       	brne	80004ffe <_malloc_r+0x332>
80004fec:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80004ff0:	c0 71       	brne	80004ffe <_malloc_r+0x332>
80004ff2:	e2 02 00 02 	add	r2,r1,r2
80004ff6:	68 28       	ld.w	r8,r4[0x8]
80004ff8:	a1 a2       	sbr	r2,0x0
80004ffa:	91 12       	st.w	r8[0x4],r2
80004ffc:	c4 b8       	rjmp	80005092 <_malloc_r+0x3c6>
80004ffe:	4b 5a       	lddpc	r10,800050d0 <_malloc_r+0x404>
80005000:	74 0b       	ld.w	r11,r10[0x0]
80005002:	5b fb       	cp.w	r11,-1
80005004:	c0 31       	brne	8000500a <_malloc_r+0x33e>
80005006:	95 06       	st.w	r10[0x0],r6
80005008:	c0 68       	rjmp	80005014 <_malloc_r+0x348>
8000500a:	ec 09 00 09 	add	r9,r6,r9
8000500e:	4b 2a       	lddpc	r10,800050d4 <_malloc_r+0x408>
80005010:	10 19       	sub	r9,r8
80005012:	95 09       	st.w	r10[0x0],r9
80005014:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80005018:	f0 09 11 08 	rsub	r9,r8,8
8000501c:	58 08       	cp.w	r8,0
8000501e:	f2 08 17 10 	movne	r8,r9
80005022:	ed d8 e1 06 	addne	r6,r6,r8
80005026:	28 08       	sub	r8,-128
80005028:	ec 01 00 01 	add	r1,r6,r1
8000502c:	0a 9c       	mov	r12,r5
8000502e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80005032:	f0 01 01 01 	sub	r1,r8,r1
80005036:	02 9b       	mov	r11,r1
80005038:	c6 cc       	rcall	80005110 <_sbrk_r>
8000503a:	4a 78       	lddpc	r8,800050d4 <_malloc_r+0x408>
8000503c:	5b fc       	cp.w	r12,-1
8000503e:	ec 0c 17 00 	moveq	r12,r6
80005042:	f9 b1 00 00 	moveq	r1,0
80005046:	70 09       	ld.w	r9,r8[0x0]
80005048:	0c 1c       	sub	r12,r6
8000504a:	89 26       	st.w	r4[0x8],r6
8000504c:	02 0c       	add	r12,r1
8000504e:	12 01       	add	r1,r9
80005050:	a1 ac       	sbr	r12,0x0
80005052:	91 01       	st.w	r8[0x0],r1
80005054:	8d 1c       	st.w	r6[0x4],r12
80005056:	08 33       	cp.w	r3,r4
80005058:	c1 d0       	breq	80005092 <_malloc_r+0x3c6>
8000505a:	58 f2       	cp.w	r2,15
8000505c:	e0 8b 00 05 	brhi	80005066 <_malloc_r+0x39a>
80005060:	30 18       	mov	r8,1
80005062:	8d 18       	st.w	r6[0x4],r8
80005064:	c2 38       	rjmp	800050aa <_malloc_r+0x3de>
80005066:	30 59       	mov	r9,5
80005068:	20 c2       	sub	r2,12
8000506a:	e0 12 ff f8 	andl	r2,0xfff8
8000506e:	e6 02 00 08 	add	r8,r3,r2
80005072:	91 29       	st.w	r8[0x8],r9
80005074:	91 19       	st.w	r8[0x4],r9
80005076:	66 18       	ld.w	r8,r3[0x4]
80005078:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000507c:	e5 e8 10 08 	or	r8,r2,r8
80005080:	87 18       	st.w	r3[0x4],r8
80005082:	58 f2       	cp.w	r2,15
80005084:	e0 88 00 07 	brls	80005092 <_malloc_r+0x3c6>
80005088:	e6 cb ff f8 	sub	r11,r3,-8
8000508c:	0a 9c       	mov	r12,r5
8000508e:	e0 a0 03 6b 	rcall	80005764 <_free_r>
80005092:	49 29       	lddpc	r9,800050d8 <_malloc_r+0x40c>
80005094:	72 0a       	ld.w	r10,r9[0x0]
80005096:	49 08       	lddpc	r8,800050d4 <_malloc_r+0x408>
80005098:	70 08       	ld.w	r8,r8[0x0]
8000509a:	14 38       	cp.w	r8,r10
8000509c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800050a0:	48 f9       	lddpc	r9,800050dc <_malloc_r+0x410>
800050a2:	72 0a       	ld.w	r10,r9[0x0]
800050a4:	14 38       	cp.w	r8,r10
800050a6:	f3 f8 ba 00 	st.whi	r9[0x0],r8
800050aa:	68 28       	ld.w	r8,r4[0x8]
800050ac:	70 18       	ld.w	r8,r8[0x4]
800050ae:	e0 18 ff fc 	andl	r8,0xfffc
800050b2:	0e 38       	cp.w	r8,r7
800050b4:	5f 39       	srlo	r9
800050b6:	0e 18       	sub	r8,r7
800050b8:	58 f8       	cp.w	r8,15
800050ba:	5f aa       	srle	r10
800050bc:	f5 e9 10 09 	or	r9,r10,r9
800050c0:	c1 00       	breq	800050e0 <_malloc_r+0x414>
800050c2:	0a 9c       	mov	r12,r5
800050c4:	fe b0 f9 50 	rcall	80004364 <__malloc_unlock>
800050c8:	d8 3a       	popm	r0-r7,pc,r12=0
800050ca:	d7 03       	nop
800050cc:	00 00       	add	r0,r0
800050ce:	09 e0       	ld.ub	r0,r4[0x6]
800050d0:	00 00       	add	r0,r0
800050d2:	05 f0       	ld.ub	r0,r2[0x7]
800050d4:	00 00       	add	r0,r0
800050d6:	09 e4       	ld.ub	r4,r4[0x6]
800050d8:	00 00       	add	r0,r0
800050da:	09 dc       	ld.ub	r12,r4[0x5]
800050dc:	00 00       	add	r0,r0
800050de:	09 d8       	ld.ub	r8,r4[0x5]
800050e0:	68 26       	ld.w	r6,r4[0x8]
800050e2:	a1 a8       	sbr	r8,0x0
800050e4:	0e 99       	mov	r9,r7
800050e6:	a1 a9       	sbr	r9,0x0
800050e8:	8d 19       	st.w	r6[0x4],r9
800050ea:	ec 07 00 07 	add	r7,r6,r7
800050ee:	0a 9c       	mov	r12,r5
800050f0:	89 27       	st.w	r4[0x8],r7
800050f2:	8f 18       	st.w	r7[0x4],r8
800050f4:	fe b0 f9 38 	rcall	80004364 <__malloc_unlock>
800050f8:	ec cc ff f8 	sub	r12,r6,-8
800050fc:	d8 32       	popm	r0-r7,pc
800050fe:	d7 03       	nop

80005100 <memset>:
80005100:	18 98       	mov	r8,r12
80005102:	c0 38       	rjmp	80005108 <memset+0x8>
80005104:	10 cb       	st.b	r8++,r11
80005106:	20 1a       	sub	r10,1
80005108:	58 0a       	cp.w	r10,0
8000510a:	cf d1       	brne	80005104 <memset+0x4>
8000510c:	5e fc       	retal	r12
8000510e:	d7 03       	nop

80005110 <_sbrk_r>:
80005110:	d4 21       	pushm	r4-r7,lr
80005112:	30 08       	mov	r8,0
80005114:	18 97       	mov	r7,r12
80005116:	48 66       	lddpc	r6,8000512c <_sbrk_r+0x1c>
80005118:	16 9c       	mov	r12,r11
8000511a:	8d 08       	st.w	r6[0x0],r8
8000511c:	cc cc       	rcall	800052b4 <_sbrk>
8000511e:	5b fc       	cp.w	r12,-1
80005120:	c0 51       	brne	8000512a <_sbrk_r+0x1a>
80005122:	6c 08       	ld.w	r8,r6[0x0]
80005124:	58 08       	cp.w	r8,0
80005126:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000512a:	d8 22       	popm	r4-r7,pc
8000512c:	00 00       	add	r0,r0
8000512e:	0a 3c       	cp.w	r12,r5

80005130 <setbuf>:
80005130:	d4 01       	pushm	lr
80005132:	e0 69 04 00 	mov	r9,1024
80005136:	58 0b       	cp.w	r11,0
80005138:	f9 ba 00 02 	moveq	r10,2
8000513c:	f9 ba 01 00 	movne	r10,0
80005140:	c0 2c       	rcall	80005144 <setvbuf>
80005142:	d8 02       	popm	pc

80005144 <setvbuf>:
80005144:	d4 31       	pushm	r0-r7,lr
80005146:	4b f8       	lddpc	r8,80005240 <setvbuf+0xfc>
80005148:	18 97       	mov	r7,r12
8000514a:	16 96       	mov	r6,r11
8000514c:	14 95       	mov	r5,r10
8000514e:	12 94       	mov	r4,r9
80005150:	70 0c       	ld.w	r12,r8[0x0]
80005152:	58 0c       	cp.w	r12,0
80005154:	c0 60       	breq	80005160 <setvbuf+0x1c>
80005156:	78 68       	ld.w	r8,r12[0x18]
80005158:	58 08       	cp.w	r8,0
8000515a:	c0 31       	brne	80005160 <setvbuf+0x1c>
8000515c:	e0 a0 02 68 	rcall	8000562c <__sinit>
80005160:	4b 98       	lddpc	r8,80005244 <setvbuf+0x100>
80005162:	10 37       	cp.w	r7,r8
80005164:	c0 51       	brne	8000516e <setvbuf+0x2a>
80005166:	4b 78       	lddpc	r8,80005240 <setvbuf+0xfc>
80005168:	70 08       	ld.w	r8,r8[0x0]
8000516a:	70 07       	ld.w	r7,r8[0x0]
8000516c:	c0 e8       	rjmp	80005188 <setvbuf+0x44>
8000516e:	4b 78       	lddpc	r8,80005248 <setvbuf+0x104>
80005170:	10 37       	cp.w	r7,r8
80005172:	c0 51       	brne	8000517c <setvbuf+0x38>
80005174:	4b 38       	lddpc	r8,80005240 <setvbuf+0xfc>
80005176:	70 08       	ld.w	r8,r8[0x0]
80005178:	70 17       	ld.w	r7,r8[0x4]
8000517a:	c0 78       	rjmp	80005188 <setvbuf+0x44>
8000517c:	4b 48       	lddpc	r8,8000524c <setvbuf+0x108>
8000517e:	10 37       	cp.w	r7,r8
80005180:	c0 41       	brne	80005188 <setvbuf+0x44>
80005182:	4b 08       	lddpc	r8,80005240 <setvbuf+0xfc>
80005184:	70 08       	ld.w	r8,r8[0x0]
80005186:	70 27       	ld.w	r7,r8[0x8]
80005188:	58 25       	cp.w	r5,2
8000518a:	5f b8       	srhi	r8
8000518c:	f1 e4 13 f8 	or	r8,r8,r4>>0x1f
80005190:	c0 20       	breq	80005194 <setvbuf+0x50>
80005192:	dc 3a       	popm	r0-r7,pc,r12=-1
80005194:	4a b3       	lddpc	r3,80005240 <setvbuf+0xfc>
80005196:	0e 9b       	mov	r11,r7
80005198:	66 0c       	ld.w	r12,r3[0x0]
8000519a:	c6 dd       	rcall	80005474 <_fflush_r>
8000519c:	30 08       	mov	r8,0
8000519e:	8f 68       	st.w	r7[0x18],r8
800051a0:	8f 18       	st.w	r7[0x4],r8
800051a2:	8e 68       	ld.sh	r8,r7[0xc]
800051a4:	ed b8 00 07 	bld	r8,0x7
800051a8:	c0 51       	brne	800051b2 <setvbuf+0x6e>
800051aa:	66 0c       	ld.w	r12,r3[0x0]
800051ac:	6e 4b       	ld.w	r11,r7[0x10]
800051ae:	e0 a0 02 db 	rcall	80005764 <_free_r>
800051b2:	8e 68       	ld.sh	r8,r7[0xc]
800051b4:	e0 18 ff 7c 	andl	r8,0xff7c
800051b8:	ae 68       	st.h	r7[0xc],r8
800051ba:	58 25       	cp.w	r5,2
800051bc:	c0 31       	brne	800051c2 <setvbuf+0x7e>
800051be:	30 0c       	mov	r12,0
800051c0:	c1 38       	rjmp	800051e6 <setvbuf+0xa2>
800051c2:	58 06       	cp.w	r6,0
800051c4:	c2 11       	brne	80005206 <setvbuf+0xc2>
800051c6:	e0 63 04 00 	mov	r3,1024
800051ca:	58 04       	cp.w	r4,0
800051cc:	e6 04 17 00 	moveq	r4,r3
800051d0:	08 9c       	mov	r12,r4
800051d2:	fe b0 fd 75 	rcall	80004cbc <malloc>
800051d6:	18 96       	mov	r6,r12
800051d8:	c1 41       	brne	80005200 <setvbuf+0xbc>
800051da:	06 9c       	mov	r12,r3
800051dc:	fe b0 fd 70 	rcall	80004cbc <malloc>
800051e0:	18 96       	mov	r6,r12
800051e2:	c0 e1       	brne	800051fe <setvbuf+0xba>
800051e4:	3f fc       	mov	r12,-1
800051e6:	8e 68       	ld.sh	r8,r7[0xc]
800051e8:	a1 b8       	sbr	r8,0x1
800051ea:	ae 68       	st.h	r7[0xc],r8
800051ec:	ee c8 ff b9 	sub	r8,r7,-71
800051f0:	8f 48       	st.w	r7[0x10],r8
800051f2:	8f 08       	st.w	r7[0x0],r8
800051f4:	30 08       	mov	r8,0
800051f6:	8f 28       	st.w	r7[0x8],r8
800051f8:	30 18       	mov	r8,1
800051fa:	8f 58       	st.w	r7[0x14],r8
800051fc:	d8 32       	popm	r0-r7,pc
800051fe:	06 94       	mov	r4,r3
80005200:	8e 68       	ld.sh	r8,r7[0xc]
80005202:	a7 b8       	sbr	r8,0x7
80005204:	ae 68       	st.h	r7[0xc],r8
80005206:	58 15       	cp.w	r5,1
80005208:	c0 71       	brne	80005216 <setvbuf+0xd2>
8000520a:	8e 68       	ld.sh	r8,r7[0xc]
8000520c:	a1 a8       	sbr	r8,0x0
8000520e:	ae 68       	st.h	r7[0xc],r8
80005210:	e8 08 11 00 	rsub	r8,r4,0
80005214:	8f 68       	st.w	r7[0x18],r8
80005216:	48 b8       	lddpc	r8,80005240 <setvbuf+0xfc>
80005218:	fe c9 fc 90 	sub	r9,pc,-880
8000521c:	70 08       	ld.w	r8,r8[0x0]
8000521e:	8f 46       	st.w	r7[0x10],r6
80005220:	91 a9       	st.w	r8[0x28],r9
80005222:	8f 06       	st.w	r7[0x0],r6
80005224:	8f 54       	st.w	r7[0x14],r4
80005226:	8e 68       	ld.sh	r8,r7[0xc]
80005228:	10 9c       	mov	r12,r8
8000522a:	e2 1c 00 08 	andl	r12,0x8,COH
8000522e:	c0 70       	breq	8000523c <setvbuf+0xf8>
80005230:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80005234:	30 0c       	mov	r12,0
80005236:	f9 b4 01 00 	movne	r4,0
8000523a:	8f 24       	st.w	r7[0x8],r4
8000523c:	d8 32       	popm	r0-r7,pc
8000523e:	d7 03       	nop
80005240:	00 00       	add	r0,r0
80005242:	01 e0       	ld.ub	r0,r0[0x6]
80005244:	80 00       	ld.sh	r0,r0[0x0]
80005246:	5f 18       	srne	r8
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	5f 38       	srlo	r8
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	5f 58       	srlt	r8

80005250 <strncpy>:
80005250:	30 08       	mov	r8,0
80005252:	10 3a       	cp.w	r10,r8
80005254:	5e 0c       	reteq	r12
80005256:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000525a:	f8 08 0b 09 	st.b	r12[r8],r9
8000525e:	2f f8       	sub	r8,-1
80005260:	58 09       	cp.w	r9,0
80005262:	cf 81       	brne	80005252 <strncpy+0x2>
80005264:	10 3a       	cp.w	r10,r8
80005266:	5e 0c       	reteq	r12
80005268:	f8 08 0b 09 	st.b	r12[r8],r9
8000526c:	2f f8       	sub	r8,-1
8000526e:	cf bb       	rjmp	80005264 <strncpy+0x14>

80005270 <_init_argv>:
80005270:	30 e8       	mov	r8,14
80005272:	d6 73       	breakpoint
80005274:	3f fc       	mov	r12,-1
80005276:	35 8b       	mov	r11,88
80005278:	5e fc       	retal	r12

8000527a <_exit>:
8000527a:	30 d8       	mov	r8,13
8000527c:	d6 73       	breakpoint
8000527e:	3f fc       	mov	r12,-1
80005280:	35 8b       	mov	r11,88
80005282:	c0 08       	rjmp	80005282 <_exit+0x8>

80005284 <_close>:
80005284:	30 28       	mov	r8,2
80005286:	d6 73       	breakpoint
80005288:	3f fc       	mov	r12,-1
8000528a:	35 8b       	mov	r11,88
8000528c:	58 0c       	cp.w	r12,0
8000528e:	5e 4c       	retge	r12
80005290:	48 2a       	lddpc	r10,80005298 <_close+0x14>
80005292:	95 0b       	st.w	r10[0x0],r11
80005294:	5e fc       	retal	r12
80005296:	d7 03       	nop
80005298:	00 00       	add	r0,r0
8000529a:	0a 3c       	cp.w	r12,r5

8000529c <_lseek>:
8000529c:	30 58       	mov	r8,5
8000529e:	d6 73       	breakpoint
800052a0:	3f fc       	mov	r12,-1
800052a2:	35 8b       	mov	r11,88
800052a4:	58 0c       	cp.w	r12,0
800052a6:	5e 4c       	retge	r12
800052a8:	48 2a       	lddpc	r10,800052b0 <_lseek+0x14>
800052aa:	95 0b       	st.w	r10[0x0],r11
800052ac:	5e fc       	retal	r12
800052ae:	d7 03       	nop
800052b0:	00 00       	add	r0,r0
800052b2:	0a 3c       	cp.w	r12,r5

800052b4 <_sbrk>:
800052b4:	d4 01       	pushm	lr
800052b6:	48 c8       	lddpc	r8,800052e4 <_sbrk+0x30>
800052b8:	70 09       	ld.w	r9,r8[0x0]
800052ba:	58 09       	cp.w	r9,0
800052bc:	c0 31       	brne	800052c2 <_sbrk+0xe>
800052be:	48 b9       	lddpc	r9,800052e8 <_sbrk+0x34>
800052c0:	91 09       	st.w	r8[0x0],r9
800052c2:	48 99       	lddpc	r9,800052e4 <_sbrk+0x30>
800052c4:	48 aa       	lddpc	r10,800052ec <_sbrk+0x38>
800052c6:	72 08       	ld.w	r8,r9[0x0]
800052c8:	f0 0c 00 0c 	add	r12,r8,r12
800052cc:	14 3c       	cp.w	r12,r10
800052ce:	e0 8b 00 04 	brhi	800052d6 <_sbrk+0x22>
800052d2:	93 0c       	st.w	r9[0x0],r12
800052d4:	c0 58       	rjmp	800052de <_sbrk+0x2a>
800052d6:	cc 9c       	rcall	80005468 <__errno>
800052d8:	30 c8       	mov	r8,12
800052da:	99 08       	st.w	r12[0x0],r8
800052dc:	3f f8       	mov	r8,-1
800052de:	10 9c       	mov	r12,r8
800052e0:	d8 02       	popm	pc
800052e2:	d7 03       	nop
800052e4:	00 00       	add	r0,r0
800052e6:	0a 0c       	add	r12,r5
800052e8:	00 00       	add	r0,r0
800052ea:	0a 40       	or	r0,r5
800052ec:	00 00       	add	r0,r0
800052ee:	f0 00       	*unknown*

800052f0 <__register_exitproc>:
800052f0:	d4 31       	pushm	r0-r7,lr
800052f2:	4a 98       	lddpc	r8,80005394 <__register_exitproc+0xa4>
800052f4:	70 03       	ld.w	r3,r8[0x0]
800052f6:	67 24       	ld.w	r4,r3[0x48]
800052f8:	e6 c8 ff b4 	sub	r8,r3,-76
800052fc:	58 04       	cp.w	r4,0
800052fe:	f0 04 17 00 	moveq	r4,r8
80005302:	e7 f4 0a 12 	st.weq	r3[0x48],r4
80005306:	18 97       	mov	r7,r12
80005308:	16 96       	mov	r6,r11
8000530a:	14 95       	mov	r5,r10
8000530c:	12 92       	mov	r2,r9
8000530e:	68 18       	ld.w	r8,r4[0x4]
80005310:	59 f8       	cp.w	r8,31
80005312:	e0 8a 00 0e 	brle	8000532e <__register_exitproc+0x3e>
80005316:	e0 6c 00 8c 	mov	r12,140
8000531a:	fe b0 fc d1 	rcall	80004cbc <malloc>
8000531e:	18 94       	mov	r4,r12
80005320:	c3 80       	breq	80005390 <__register_exitproc+0xa0>
80005322:	67 28       	ld.w	r8,r3[0x48]
80005324:	99 08       	st.w	r12[0x0],r8
80005326:	e7 4c 00 48 	st.w	r3[72],r12
8000532a:	30 08       	mov	r8,0
8000532c:	99 18       	st.w	r12[0x4],r8
8000532e:	58 07       	cp.w	r7,0
80005330:	c2 70       	breq	8000537e <__register_exitproc+0x8e>
80005332:	e8 fc 00 88 	ld.w	r12,r4[136]
80005336:	58 0c       	cp.w	r12,0
80005338:	c0 d1       	brne	80005352 <__register_exitproc+0x62>
8000533a:	e0 6c 01 08 	mov	r12,264
8000533e:	fe b0 fc bf 	rcall	80004cbc <malloc>
80005342:	c2 70       	breq	80005390 <__register_exitproc+0xa0>
80005344:	30 08       	mov	r8,0
80005346:	e9 4c 00 88 	st.w	r4[136],r12
8000534a:	f9 48 01 04 	st.w	r12[260],r8
8000534e:	f9 48 01 00 	st.w	r12[256],r8
80005352:	68 18       	ld.w	r8,r4[0x4]
80005354:	f0 c9 ff e0 	sub	r9,r8,-32
80005358:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
8000535c:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
80005360:	30 1a       	mov	r10,1
80005362:	f8 f9 01 00 	ld.w	r9,r12[256]
80005366:	f4 08 09 48 	lsl	r8,r10,r8
8000536a:	10 49       	or	r9,r8
8000536c:	f9 49 01 00 	st.w	r12[256],r9
80005370:	58 27       	cp.w	r7,2
80005372:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
80005376:	f3 d8 e0 38 	oreq	r8,r9,r8
8000537a:	f9 f8 0a 41 	st.weq	r12[0x104],r8
8000537e:	68 18       	ld.w	r8,r4[0x4]
80005380:	30 0c       	mov	r12,0
80005382:	f0 c9 ff ff 	sub	r9,r8,-1
80005386:	2f e8       	sub	r8,-2
80005388:	89 19       	st.w	r4[0x4],r9
8000538a:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
8000538e:	d8 32       	popm	r0-r7,pc
80005390:	dc 3a       	popm	r0-r7,pc,r12=-1
80005392:	d7 03       	nop
80005394:	80 00       	ld.sh	r0,r0[0x0]
80005396:	5f 14       	srne	r4

80005398 <__call_exitprocs>:
80005398:	d4 31       	pushm	r0-r7,lr
8000539a:	20 3d       	sub	sp,12
8000539c:	4b 28       	lddpc	r8,80005464 <__call_exitprocs+0xcc>
8000539e:	50 2c       	stdsp	sp[0x8],r12
800053a0:	70 08       	ld.w	r8,r8[0x0]
800053a2:	16 91       	mov	r1,r11
800053a4:	50 08       	stdsp	sp[0x0],r8
800053a6:	2b 88       	sub	r8,-72
800053a8:	50 18       	stdsp	sp[0x4],r8
800053aa:	40 0a       	lddsp	r10,sp[0x0]
800053ac:	40 14       	lddsp	r4,sp[0x4]
800053ae:	75 27       	ld.w	r7,r10[0x48]
800053b0:	c5 58       	rjmp	8000545a <__call_exitprocs+0xc2>
800053b2:	6e 15       	ld.w	r5,r7[0x4]
800053b4:	ee f6 00 88 	ld.w	r6,r7[136]
800053b8:	ea c2 ff ff 	sub	r2,r5,-1
800053bc:	20 15       	sub	r5,1
800053be:	ee 02 00 22 	add	r2,r7,r2<<0x2
800053c2:	ec 05 00 23 	add	r3,r6,r5<<0x2
800053c6:	c3 58       	rjmp	80005430 <__call_exitprocs+0x98>
800053c8:	58 01       	cp.w	r1,0
800053ca:	c0 70       	breq	800053d8 <__call_exitprocs+0x40>
800053cc:	58 06       	cp.w	r6,0
800053ce:	c2 e0       	breq	8000542a <__call_exitprocs+0x92>
800053d0:	e6 f8 00 80 	ld.w	r8,r3[128]
800053d4:	02 38       	cp.w	r8,r1
800053d6:	c2 a1       	brne	8000542a <__call_exitprocs+0x92>
800053d8:	6e 19       	ld.w	r9,r7[0x4]
800053da:	64 08       	ld.w	r8,r2[0x0]
800053dc:	20 19       	sub	r9,1
800053de:	12 35       	cp.w	r5,r9
800053e0:	ef f5 0a 01 	st.weq	r7[0x4],r5
800053e4:	f9 b9 01 00 	movne	r9,0
800053e8:	e5 f9 1a 00 	st.wne	r2[0x0],r9
800053ec:	58 08       	cp.w	r8,0
800053ee:	c1 e0       	breq	8000542a <__call_exitprocs+0x92>
800053f0:	6e 10       	ld.w	r0,r7[0x4]
800053f2:	58 06       	cp.w	r6,0
800053f4:	c0 90       	breq	80005406 <__call_exitprocs+0x6e>
800053f6:	30 1a       	mov	r10,1
800053f8:	f4 05 09 49 	lsl	r9,r10,r5
800053fc:	ec fa 01 00 	ld.w	r10,r6[256]
80005400:	f3 ea 00 0a 	and	r10,r9,r10
80005404:	c0 31       	brne	8000540a <__call_exitprocs+0x72>
80005406:	5d 18       	icall	r8
80005408:	c0 b8       	rjmp	8000541e <__call_exitprocs+0x86>
8000540a:	ec fa 01 04 	ld.w	r10,r6[260]
8000540e:	66 0b       	ld.w	r11,r3[0x0]
80005410:	14 69       	and	r9,r10
80005412:	c0 41       	brne	8000541a <__call_exitprocs+0x82>
80005414:	40 2c       	lddsp	r12,sp[0x8]
80005416:	5d 18       	icall	r8
80005418:	c0 38       	rjmp	8000541e <__call_exitprocs+0x86>
8000541a:	16 9c       	mov	r12,r11
8000541c:	5d 18       	icall	r8
8000541e:	6e 18       	ld.w	r8,r7[0x4]
80005420:	10 30       	cp.w	r0,r8
80005422:	cc 41       	brne	800053aa <__call_exitprocs+0x12>
80005424:	68 08       	ld.w	r8,r4[0x0]
80005426:	0e 38       	cp.w	r8,r7
80005428:	cc 11       	brne	800053aa <__call_exitprocs+0x12>
8000542a:	20 15       	sub	r5,1
8000542c:	20 43       	sub	r3,4
8000542e:	20 42       	sub	r2,4
80005430:	58 05       	cp.w	r5,0
80005432:	cc b4       	brge	800053c8 <__call_exitprocs+0x30>
80005434:	6e 18       	ld.w	r8,r7[0x4]
80005436:	58 08       	cp.w	r8,0
80005438:	c0 f1       	brne	80005456 <__call_exitprocs+0xbe>
8000543a:	6e 08       	ld.w	r8,r7[0x0]
8000543c:	58 08       	cp.w	r8,0
8000543e:	c0 c0       	breq	80005456 <__call_exitprocs+0xbe>
80005440:	89 08       	st.w	r4[0x0],r8
80005442:	58 06       	cp.w	r6,0
80005444:	c0 40       	breq	8000544c <__call_exitprocs+0xb4>
80005446:	0c 9c       	mov	r12,r6
80005448:	fe b0 fc 30 	rcall	80004ca8 <free>
8000544c:	0e 9c       	mov	r12,r7
8000544e:	fe b0 fc 2d 	rcall	80004ca8 <free>
80005452:	68 07       	ld.w	r7,r4[0x0]
80005454:	c0 38       	rjmp	8000545a <__call_exitprocs+0xc2>
80005456:	0e 94       	mov	r4,r7
80005458:	6e 07       	ld.w	r7,r7[0x0]
8000545a:	58 07       	cp.w	r7,0
8000545c:	ca b1       	brne	800053b2 <__call_exitprocs+0x1a>
8000545e:	2f dd       	sub	sp,-12
80005460:	d8 32       	popm	r0-r7,pc
80005462:	d7 03       	nop
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	5f 14       	srne	r4

80005468 <__errno>:
80005468:	48 28       	lddpc	r8,80005470 <__errno+0x8>
8000546a:	70 0c       	ld.w	r12,r8[0x0]
8000546c:	2f 4c       	sub	r12,-12
8000546e:	5e fc       	retal	r12
80005470:	00 00       	add	r0,r0
80005472:	01 e0       	ld.ub	r0,r0[0x6]

80005474 <_fflush_r>:
80005474:	d4 21       	pushm	r4-r7,lr
80005476:	16 97       	mov	r7,r11
80005478:	18 96       	mov	r6,r12
8000547a:	76 48       	ld.w	r8,r11[0x10]
8000547c:	58 08       	cp.w	r8,0
8000547e:	c7 c0       	breq	80005576 <_fflush_r+0x102>
80005480:	58 0c       	cp.w	r12,0
80005482:	c0 50       	breq	8000548c <_fflush_r+0x18>
80005484:	78 68       	ld.w	r8,r12[0x18]
80005486:	58 08       	cp.w	r8,0
80005488:	c0 21       	brne	8000548c <_fflush_r+0x18>
8000548a:	cd 1c       	rcall	8000562c <__sinit>
8000548c:	4b b8       	lddpc	r8,80005578 <_fflush_r+0x104>
8000548e:	10 37       	cp.w	r7,r8
80005490:	c0 31       	brne	80005496 <_fflush_r+0x22>
80005492:	6c 07       	ld.w	r7,r6[0x0]
80005494:	c0 a8       	rjmp	800054a8 <_fflush_r+0x34>
80005496:	4b a8       	lddpc	r8,8000557c <_fflush_r+0x108>
80005498:	10 37       	cp.w	r7,r8
8000549a:	c0 31       	brne	800054a0 <_fflush_r+0x2c>
8000549c:	6c 17       	ld.w	r7,r6[0x4]
8000549e:	c0 58       	rjmp	800054a8 <_fflush_r+0x34>
800054a0:	4b 88       	lddpc	r8,80005580 <_fflush_r+0x10c>
800054a2:	10 37       	cp.w	r7,r8
800054a4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
800054a8:	8e 6a       	ld.sh	r10,r7[0xc]
800054aa:	14 98       	mov	r8,r10
800054ac:	ed ba 00 03 	bld	r10,0x3
800054b0:	c4 20       	breq	80005534 <_fflush_r+0xc0>
800054b2:	ab ba       	sbr	r10,0xb
800054b4:	ae 6a       	st.h	r7[0xc],r10
800054b6:	6e 18       	ld.w	r8,r7[0x4]
800054b8:	58 08       	cp.w	r8,0
800054ba:	e0 89 00 06 	brgt	800054c6 <_fflush_r+0x52>
800054be:	6f 08       	ld.w	r8,r7[0x40]
800054c0:	58 08       	cp.w	r8,0
800054c2:	e0 8a 00 5a 	brle	80005576 <_fflush_r+0x102>
800054c6:	6e b8       	ld.w	r8,r7[0x2c]
800054c8:	58 08       	cp.w	r8,0
800054ca:	c5 60       	breq	80005576 <_fflush_r+0x102>
800054cc:	e2 1a 10 00 	andl	r10,0x1000,COH
800054d0:	c0 30       	breq	800054d6 <_fflush_r+0x62>
800054d2:	6f 55       	ld.w	r5,r7[0x54]
800054d4:	c0 f8       	rjmp	800054f2 <_fflush_r+0x7e>
800054d6:	30 19       	mov	r9,1
800054d8:	6e 8b       	ld.w	r11,r7[0x20]
800054da:	0c 9c       	mov	r12,r6
800054dc:	5d 18       	icall	r8
800054de:	18 95       	mov	r5,r12
800054e0:	5b fc       	cp.w	r12,-1
800054e2:	c0 81       	brne	800054f2 <_fflush_r+0x7e>
800054e4:	6c 38       	ld.w	r8,r6[0xc]
800054e6:	59 d8       	cp.w	r8,29
800054e8:	c4 70       	breq	80005576 <_fflush_r+0x102>
800054ea:	8e 68       	ld.sh	r8,r7[0xc]
800054ec:	a7 a8       	sbr	r8,0x6
800054ee:	ae 68       	st.h	r7[0xc],r8
800054f0:	d8 22       	popm	r4-r7,pc
800054f2:	8e 68       	ld.sh	r8,r7[0xc]
800054f4:	ed b8 00 02 	bld	r8,0x2
800054f8:	c0 91       	brne	8000550a <_fflush_r+0x96>
800054fa:	6e 18       	ld.w	r8,r7[0x4]
800054fc:	10 15       	sub	r5,r8
800054fe:	6e d8       	ld.w	r8,r7[0x34]
80005500:	58 08       	cp.w	r8,0
80005502:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80005506:	eb d8 e1 15 	subne	r5,r5,r8
8000550a:	6e b8       	ld.w	r8,r7[0x2c]
8000550c:	0c 9c       	mov	r12,r6
8000550e:	30 09       	mov	r9,0
80005510:	0a 9a       	mov	r10,r5
80005512:	6e 8b       	ld.w	r11,r7[0x20]
80005514:	5d 18       	icall	r8
80005516:	8e 68       	ld.sh	r8,r7[0xc]
80005518:	0a 3c       	cp.w	r12,r5
8000551a:	c2 61       	brne	80005566 <_fflush_r+0xf2>
8000551c:	ab d8       	cbr	r8,0xb
8000551e:	30 0c       	mov	r12,0
80005520:	6e 49       	ld.w	r9,r7[0x10]
80005522:	ae 68       	st.h	r7[0xc],r8
80005524:	8f 1c       	st.w	r7[0x4],r12
80005526:	8f 09       	st.w	r7[0x0],r9
80005528:	ed b8 00 0c 	bld	r8,0xc
8000552c:	c2 51       	brne	80005576 <_fflush_r+0x102>
8000552e:	ef 45 00 54 	st.w	r7[84],r5
80005532:	d8 22       	popm	r4-r7,pc
80005534:	6e 45       	ld.w	r5,r7[0x10]
80005536:	58 05       	cp.w	r5,0
80005538:	c1 f0       	breq	80005576 <_fflush_r+0x102>
8000553a:	6e 04       	ld.w	r4,r7[0x0]
8000553c:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80005540:	8f 05       	st.w	r7[0x0],r5
80005542:	f9 b8 01 00 	movne	r8,0
80005546:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000554a:	0a 14       	sub	r4,r5
8000554c:	8f 28       	st.w	r7[0x8],r8
8000554e:	c1 18       	rjmp	80005570 <_fflush_r+0xfc>
80005550:	08 99       	mov	r9,r4
80005552:	0a 9a       	mov	r10,r5
80005554:	6e a8       	ld.w	r8,r7[0x28]
80005556:	6e 8b       	ld.w	r11,r7[0x20]
80005558:	0c 9c       	mov	r12,r6
8000555a:	5d 18       	icall	r8
8000555c:	18 14       	sub	r4,r12
8000555e:	58 0c       	cp.w	r12,0
80005560:	e0 89 00 07 	brgt	8000556e <_fflush_r+0xfa>
80005564:	8e 68       	ld.sh	r8,r7[0xc]
80005566:	a7 a8       	sbr	r8,0x6
80005568:	3f fc       	mov	r12,-1
8000556a:	ae 68       	st.h	r7[0xc],r8
8000556c:	d8 22       	popm	r4-r7,pc
8000556e:	18 05       	add	r5,r12
80005570:	58 04       	cp.w	r4,0
80005572:	fe 99 ff ef 	brgt	80005550 <_fflush_r+0xdc>
80005576:	d8 2a       	popm	r4-r7,pc,r12=0
80005578:	80 00       	ld.sh	r0,r0[0x0]
8000557a:	5f 18       	srne	r8
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	5f 38       	srlo	r8
80005580:	80 00       	ld.sh	r0,r0[0x0]
80005582:	5f 58       	srlt	r8

80005584 <__sfp_lock_acquire>:
80005584:	5e fc       	retal	r12

80005586 <__sfp_lock_release>:
80005586:	5e fc       	retal	r12

80005588 <_cleanup_r>:
80005588:	d4 01       	pushm	lr
8000558a:	fe cb fa de 	sub	r11,pc,-1314
8000558e:	cb 3d       	rcall	800058f4 <_fwalk>
80005590:	d8 02       	popm	pc
80005592:	d7 03       	nop

80005594 <__sfmoreglue>:
80005594:	d4 21       	pushm	r4-r7,lr
80005596:	16 95       	mov	r5,r11
80005598:	f6 06 10 5c 	mul	r6,r11,92
8000559c:	ec cb ff f4 	sub	r11,r6,-12
800055a0:	fe b0 fb 96 	rcall	80004ccc <_malloc_r>
800055a4:	18 97       	mov	r7,r12
800055a6:	c0 90       	breq	800055b8 <__sfmoreglue+0x24>
800055a8:	99 15       	st.w	r12[0x4],r5
800055aa:	30 0b       	mov	r11,0
800055ac:	2f 4c       	sub	r12,-12
800055ae:	0c 9a       	mov	r10,r6
800055b0:	8f 2c       	st.w	r7[0x8],r12
800055b2:	8f 0b       	st.w	r7[0x0],r11
800055b4:	fe b0 fd a6 	rcall	80005100 <memset>
800055b8:	0e 9c       	mov	r12,r7
800055ba:	d8 22       	popm	r4-r7,pc

800055bc <__sfp>:
800055bc:	d4 21       	pushm	r4-r7,lr
800055be:	49 b8       	lddpc	r8,80005628 <__sfp+0x6c>
800055c0:	18 96       	mov	r6,r12
800055c2:	70 07       	ld.w	r7,r8[0x0]
800055c4:	6e 68       	ld.w	r8,r7[0x18]
800055c6:	58 08       	cp.w	r8,0
800055c8:	c0 31       	brne	800055ce <__sfp+0x12>
800055ca:	0e 9c       	mov	r12,r7
800055cc:	c3 0c       	rcall	8000562c <__sinit>
800055ce:	ee c7 ff 28 	sub	r7,r7,-216
800055d2:	30 05       	mov	r5,0
800055d4:	6e 2c       	ld.w	r12,r7[0x8]
800055d6:	6e 18       	ld.w	r8,r7[0x4]
800055d8:	c0 68       	rjmp	800055e4 <__sfp+0x28>
800055da:	98 69       	ld.sh	r9,r12[0xc]
800055dc:	ea 09 19 00 	cp.h	r9,r5
800055e0:	c1 10       	breq	80005602 <__sfp+0x46>
800055e2:	2a 4c       	sub	r12,-92
800055e4:	20 18       	sub	r8,1
800055e6:	cf a7       	brpl	800055da <__sfp+0x1e>
800055e8:	6e 08       	ld.w	r8,r7[0x0]
800055ea:	58 08       	cp.w	r8,0
800055ec:	c0 61       	brne	800055f8 <__sfp+0x3c>
800055ee:	30 4b       	mov	r11,4
800055f0:	0c 9c       	mov	r12,r6
800055f2:	cd 1f       	rcall	80005594 <__sfmoreglue>
800055f4:	8f 0c       	st.w	r7[0x0],r12
800055f6:	c0 30       	breq	800055fc <__sfp+0x40>
800055f8:	6e 07       	ld.w	r7,r7[0x0]
800055fa:	ce db       	rjmp	800055d4 <__sfp+0x18>
800055fc:	30 c8       	mov	r8,12
800055fe:	8d 38       	st.w	r6[0xc],r8
80005600:	d8 22       	popm	r4-r7,pc
80005602:	30 08       	mov	r8,0
80005604:	f9 48 00 4c 	st.w	r12[76],r8
80005608:	99 08       	st.w	r12[0x0],r8
8000560a:	99 28       	st.w	r12[0x8],r8
8000560c:	99 18       	st.w	r12[0x4],r8
8000560e:	99 48       	st.w	r12[0x10],r8
80005610:	99 58       	st.w	r12[0x14],r8
80005612:	99 68       	st.w	r12[0x18],r8
80005614:	99 d8       	st.w	r12[0x34],r8
80005616:	99 e8       	st.w	r12[0x38],r8
80005618:	f9 48 00 48 	st.w	r12[72],r8
8000561c:	3f f8       	mov	r8,-1
8000561e:	b8 78       	st.h	r12[0xe],r8
80005620:	30 18       	mov	r8,1
80005622:	b8 68       	st.h	r12[0xc],r8
80005624:	d8 22       	popm	r4-r7,pc
80005626:	d7 03       	nop
80005628:	80 00       	ld.sh	r0,r0[0x0]
8000562a:	5f 14       	srne	r4

8000562c <__sinit>:
8000562c:	d4 21       	pushm	r4-r7,lr
8000562e:	18 96       	mov	r6,r12
80005630:	78 67       	ld.w	r7,r12[0x18]
80005632:	58 07       	cp.w	r7,0
80005634:	c4 91       	brne	800056c6 <__sinit+0x9a>
80005636:	fe c8 00 ae 	sub	r8,pc,174
8000563a:	30 15       	mov	r5,1
8000563c:	99 a8       	st.w	r12[0x28],r8
8000563e:	f9 47 00 d8 	st.w	r12[216],r7
80005642:	f9 47 00 dc 	st.w	r12[220],r7
80005646:	f9 47 00 e0 	st.w	r12[224],r7
8000564a:	99 65       	st.w	r12[0x18],r5
8000564c:	cb 8f       	rcall	800055bc <__sfp>
8000564e:	8d 0c       	st.w	r6[0x0],r12
80005650:	0c 9c       	mov	r12,r6
80005652:	cb 5f       	rcall	800055bc <__sfp>
80005654:	8d 1c       	st.w	r6[0x4],r12
80005656:	0c 9c       	mov	r12,r6
80005658:	cb 2f       	rcall	800055bc <__sfp>
8000565a:	6c 09       	ld.w	r9,r6[0x0]
8000565c:	30 48       	mov	r8,4
8000565e:	93 07       	st.w	r9[0x0],r7
80005660:	b2 68       	st.h	r9[0xc],r8
80005662:	93 17       	st.w	r9[0x4],r7
80005664:	93 27       	st.w	r9[0x8],r7
80005666:	6c 18       	ld.w	r8,r6[0x4]
80005668:	b2 77       	st.h	r9[0xe],r7
8000566a:	93 47       	st.w	r9[0x10],r7
8000566c:	93 57       	st.w	r9[0x14],r7
8000566e:	93 67       	st.w	r9[0x18],r7
80005670:	93 89       	st.w	r9[0x20],r9
80005672:	91 07       	st.w	r8[0x0],r7
80005674:	91 17       	st.w	r8[0x4],r7
80005676:	91 27       	st.w	r8[0x8],r7
80005678:	fe ce fc e8 	sub	lr,pc,-792
8000567c:	fe cb fd 18 	sub	r11,pc,-744
80005680:	93 9e       	st.w	r9[0x24],lr
80005682:	93 ab       	st.w	r9[0x28],r11
80005684:	fe ca fd 40 	sub	r10,pc,-704
80005688:	fe c4 fd 4c 	sub	r4,pc,-692
8000568c:	93 ba       	st.w	r9[0x2c],r10
8000568e:	93 c4       	st.w	r9[0x30],r4
80005690:	30 99       	mov	r9,9
80005692:	b0 69       	st.h	r8[0xc],r9
80005694:	b0 75       	st.h	r8[0xe],r5
80005696:	91 c4       	st.w	r8[0x30],r4
80005698:	91 47       	st.w	r8[0x10],r7
8000569a:	91 57       	st.w	r8[0x14],r7
8000569c:	91 67       	st.w	r8[0x18],r7
8000569e:	91 88       	st.w	r8[0x20],r8
800056a0:	91 9e       	st.w	r8[0x24],lr
800056a2:	91 ab       	st.w	r8[0x28],r11
800056a4:	91 ba       	st.w	r8[0x2c],r10
800056a6:	8d 2c       	st.w	r6[0x8],r12
800056a8:	31 28       	mov	r8,18
800056aa:	99 07       	st.w	r12[0x0],r7
800056ac:	b8 68       	st.h	r12[0xc],r8
800056ae:	99 17       	st.w	r12[0x4],r7
800056b0:	99 27       	st.w	r12[0x8],r7
800056b2:	30 28       	mov	r8,2
800056b4:	b8 78       	st.h	r12[0xe],r8
800056b6:	99 c4       	st.w	r12[0x30],r4
800056b8:	99 67       	st.w	r12[0x18],r7
800056ba:	99 9e       	st.w	r12[0x24],lr
800056bc:	99 ab       	st.w	r12[0x28],r11
800056be:	99 ba       	st.w	r12[0x2c],r10
800056c0:	99 47       	st.w	r12[0x10],r7
800056c2:	99 57       	st.w	r12[0x14],r7
800056c4:	99 8c       	st.w	r12[0x20],r12
800056c6:	d8 22       	popm	r4-r7,pc

800056c8 <_malloc_trim_r>:
800056c8:	d4 21       	pushm	r4-r7,lr
800056ca:	16 95       	mov	r5,r11
800056cc:	18 97       	mov	r7,r12
800056ce:	fe b0 f6 45 	rcall	80004358 <__malloc_lock>
800056d2:	4a 24       	lddpc	r4,80005758 <_malloc_trim_r+0x90>
800056d4:	68 28       	ld.w	r8,r4[0x8]
800056d6:	70 16       	ld.w	r6,r8[0x4]
800056d8:	e0 16 ff fc 	andl	r6,0xfffc
800056dc:	ec c8 ff 91 	sub	r8,r6,-111
800056e0:	f0 05 01 05 	sub	r5,r8,r5
800056e4:	e0 15 ff 80 	andl	r5,0xff80
800056e8:	ea c5 00 80 	sub	r5,r5,128
800056ec:	e0 45 00 7f 	cp.w	r5,127
800056f0:	e0 8a 00 23 	brle	80005736 <_malloc_trim_r+0x6e>
800056f4:	30 0b       	mov	r11,0
800056f6:	0e 9c       	mov	r12,r7
800056f8:	fe b0 fd 0c 	rcall	80005110 <_sbrk_r>
800056fc:	68 28       	ld.w	r8,r4[0x8]
800056fe:	0c 08       	add	r8,r6
80005700:	10 3c       	cp.w	r12,r8
80005702:	c1 a1       	brne	80005736 <_malloc_trim_r+0x6e>
80005704:	ea 0b 11 00 	rsub	r11,r5,0
80005708:	0e 9c       	mov	r12,r7
8000570a:	fe b0 fd 03 	rcall	80005110 <_sbrk_r>
8000570e:	5b fc       	cp.w	r12,-1
80005710:	c1 71       	brne	8000573e <_malloc_trim_r+0x76>
80005712:	30 0b       	mov	r11,0
80005714:	0e 9c       	mov	r12,r7
80005716:	fe b0 fc fd 	rcall	80005110 <_sbrk_r>
8000571a:	68 28       	ld.w	r8,r4[0x8]
8000571c:	f8 08 01 09 	sub	r9,r12,r8
80005720:	58 f9       	cp.w	r9,15
80005722:	e0 8a 00 0a 	brle	80005736 <_malloc_trim_r+0x6e>
80005726:	a1 a9       	sbr	r9,0x0
80005728:	91 19       	st.w	r8[0x4],r9
8000572a:	48 d8       	lddpc	r8,8000575c <_malloc_trim_r+0x94>
8000572c:	70 09       	ld.w	r9,r8[0x0]
8000572e:	48 d8       	lddpc	r8,80005760 <_malloc_trim_r+0x98>
80005730:	f8 09 01 09 	sub	r9,r12,r9
80005734:	91 09       	st.w	r8[0x0],r9
80005736:	0e 9c       	mov	r12,r7
80005738:	fe b0 f6 16 	rcall	80004364 <__malloc_unlock>
8000573c:	d8 2a       	popm	r4-r7,pc,r12=0
8000573e:	68 28       	ld.w	r8,r4[0x8]
80005740:	0a 16       	sub	r6,r5
80005742:	a1 a6       	sbr	r6,0x0
80005744:	91 16       	st.w	r8[0x4],r6
80005746:	48 78       	lddpc	r8,80005760 <_malloc_trim_r+0x98>
80005748:	70 09       	ld.w	r9,r8[0x0]
8000574a:	0a 19       	sub	r9,r5
8000574c:	0e 9c       	mov	r12,r7
8000574e:	91 09       	st.w	r8[0x0],r9
80005750:	fe b0 f6 0a 	rcall	80004364 <__malloc_unlock>
80005754:	da 2a       	popm	r4-r7,pc,r12=1
80005756:	d7 03       	nop
80005758:	00 00       	add	r0,r0
8000575a:	01 e4       	ld.ub	r4,r0[0x6]
8000575c:	00 00       	add	r0,r0
8000575e:	05 f0       	ld.ub	r0,r2[0x7]
80005760:	00 00       	add	r0,r0
80005762:	09 e4       	ld.ub	r4,r4[0x6]

80005764 <_free_r>:
80005764:	d4 21       	pushm	r4-r7,lr
80005766:	16 96       	mov	r6,r11
80005768:	18 97       	mov	r7,r12
8000576a:	58 0b       	cp.w	r11,0
8000576c:	e0 80 00 c2 	breq	800058f0 <_free_r+0x18c>
80005770:	fe b0 f5 f4 	rcall	80004358 <__malloc_lock>
80005774:	20 86       	sub	r6,8
80005776:	4c ba       	lddpc	r10,800058a0 <_free_r+0x13c>
80005778:	6c 18       	ld.w	r8,r6[0x4]
8000577a:	74 2e       	ld.w	lr,r10[0x8]
8000577c:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80005780:	a1 c8       	cbr	r8,0x0
80005782:	ec 08 00 09 	add	r9,r6,r8
80005786:	72 1b       	ld.w	r11,r9[0x4]
80005788:	e0 1b ff fc 	andl	r11,0xfffc
8000578c:	1c 39       	cp.w	r9,lr
8000578e:	c1 c1       	brne	800057c6 <_free_r+0x62>
80005790:	f6 08 00 08 	add	r8,r11,r8
80005794:	58 0c       	cp.w	r12,0
80005796:	c0 81       	brne	800057a6 <_free_r+0x42>
80005798:	6c 09       	ld.w	r9,r6[0x0]
8000579a:	12 16       	sub	r6,r9
8000579c:	12 08       	add	r8,r9
8000579e:	6c 3b       	ld.w	r11,r6[0xc]
800057a0:	6c 29       	ld.w	r9,r6[0x8]
800057a2:	97 29       	st.w	r11[0x8],r9
800057a4:	93 3b       	st.w	r9[0xc],r11
800057a6:	10 99       	mov	r9,r8
800057a8:	95 26       	st.w	r10[0x8],r6
800057aa:	a1 a9       	sbr	r9,0x0
800057ac:	8d 19       	st.w	r6[0x4],r9
800057ae:	4b e9       	lddpc	r9,800058a4 <_free_r+0x140>
800057b0:	72 09       	ld.w	r9,r9[0x0]
800057b2:	12 38       	cp.w	r8,r9
800057b4:	c0 53       	brcs	800057be <_free_r+0x5a>
800057b6:	4b d8       	lddpc	r8,800058a8 <_free_r+0x144>
800057b8:	0e 9c       	mov	r12,r7
800057ba:	70 0b       	ld.w	r11,r8[0x0]
800057bc:	c8 6f       	rcall	800056c8 <_malloc_trim_r>
800057be:	0e 9c       	mov	r12,r7
800057c0:	fe b0 f5 d2 	rcall	80004364 <__malloc_unlock>
800057c4:	d8 22       	popm	r4-r7,pc
800057c6:	93 1b       	st.w	r9[0x4],r11
800057c8:	58 0c       	cp.w	r12,0
800057ca:	c0 30       	breq	800057d0 <_free_r+0x6c>
800057cc:	30 0c       	mov	r12,0
800057ce:	c1 08       	rjmp	800057ee <_free_r+0x8a>
800057d0:	6c 0e       	ld.w	lr,r6[0x0]
800057d2:	f4 c5 ff f8 	sub	r5,r10,-8
800057d6:	1c 16       	sub	r6,lr
800057d8:	1c 08       	add	r8,lr
800057da:	6c 2e       	ld.w	lr,r6[0x8]
800057dc:	0a 3e       	cp.w	lr,r5
800057de:	f9 bc 00 01 	moveq	r12,1
800057e2:	ed f5 10 03 	ld.wne	r5,r6[0xc]
800057e6:	eb fe 1a 02 	st.wne	r5[0x8],lr
800057ea:	fd f5 1a 03 	st.wne	lr[0xc],r5
800057ee:	f2 0b 00 0e 	add	lr,r9,r11
800057f2:	7c 1e       	ld.w	lr,lr[0x4]
800057f4:	ed be 00 00 	bld	lr,0x0
800057f8:	c1 30       	breq	8000581e <_free_r+0xba>
800057fa:	16 08       	add	r8,r11
800057fc:	58 0c       	cp.w	r12,0
800057fe:	c0 c1       	brne	80005816 <_free_r+0xb2>
80005800:	4a 8e       	lddpc	lr,800058a0 <_free_r+0x13c>
80005802:	72 2b       	ld.w	r11,r9[0x8]
80005804:	2f 8e       	sub	lr,-8
80005806:	1c 3b       	cp.w	r11,lr
80005808:	c0 71       	brne	80005816 <_free_r+0xb2>
8000580a:	97 36       	st.w	r11[0xc],r6
8000580c:	97 26       	st.w	r11[0x8],r6
8000580e:	8d 2b       	st.w	r6[0x8],r11
80005810:	8d 3b       	st.w	r6[0xc],r11
80005812:	30 1c       	mov	r12,1
80005814:	c0 58       	rjmp	8000581e <_free_r+0xba>
80005816:	72 2b       	ld.w	r11,r9[0x8]
80005818:	72 39       	ld.w	r9,r9[0xc]
8000581a:	93 2b       	st.w	r9[0x8],r11
8000581c:	97 39       	st.w	r11[0xc],r9
8000581e:	10 99       	mov	r9,r8
80005820:	ec 08 09 08 	st.w	r6[r8],r8
80005824:	a1 a9       	sbr	r9,0x0
80005826:	8d 19       	st.w	r6[0x4],r9
80005828:	58 0c       	cp.w	r12,0
8000582a:	c6 01       	brne	800058ea <_free_r+0x186>
8000582c:	e0 48 01 ff 	cp.w	r8,511
80005830:	e0 8b 00 13 	brhi	80005856 <_free_r+0xf2>
80005834:	a3 98       	lsr	r8,0x3
80005836:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000583a:	72 2b       	ld.w	r11,r9[0x8]
8000583c:	8d 39       	st.w	r6[0xc],r9
8000583e:	8d 2b       	st.w	r6[0x8],r11
80005840:	97 36       	st.w	r11[0xc],r6
80005842:	93 26       	st.w	r9[0x8],r6
80005844:	a3 48       	asr	r8,0x2
80005846:	74 19       	ld.w	r9,r10[0x4]
80005848:	30 1b       	mov	r11,1
8000584a:	f6 08 09 48 	lsl	r8,r11,r8
8000584e:	f3 e8 10 08 	or	r8,r9,r8
80005852:	95 18       	st.w	r10[0x4],r8
80005854:	c4 b8       	rjmp	800058ea <_free_r+0x186>
80005856:	f0 0b 16 09 	lsr	r11,r8,0x9
8000585a:	58 4b       	cp.w	r11,4
8000585c:	e0 8b 00 06 	brhi	80005868 <_free_r+0x104>
80005860:	f0 0b 16 06 	lsr	r11,r8,0x6
80005864:	2c 8b       	sub	r11,-56
80005866:	c2 68       	rjmp	800058b2 <_free_r+0x14e>
80005868:	59 4b       	cp.w	r11,20
8000586a:	e0 8b 00 04 	brhi	80005872 <_free_r+0x10e>
8000586e:	2a 5b       	sub	r11,-91
80005870:	c2 18       	rjmp	800058b2 <_free_r+0x14e>
80005872:	e0 4b 00 54 	cp.w	r11,84
80005876:	e0 8b 00 06 	brhi	80005882 <_free_r+0x11e>
8000587a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000587e:	29 2b       	sub	r11,-110
80005880:	c1 98       	rjmp	800058b2 <_free_r+0x14e>
80005882:	e0 4b 01 54 	cp.w	r11,340
80005886:	e0 8b 00 06 	brhi	80005892 <_free_r+0x12e>
8000588a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000588e:	28 9b       	sub	r11,-119
80005890:	c1 18       	rjmp	800058b2 <_free_r+0x14e>
80005892:	e0 4b 05 54 	cp.w	r11,1364
80005896:	e0 88 00 0b 	brls	800058ac <_free_r+0x148>
8000589a:	37 eb       	mov	r11,126
8000589c:	c0 b8       	rjmp	800058b2 <_free_r+0x14e>
8000589e:	d7 03       	nop
800058a0:	00 00       	add	r0,r0
800058a2:	01 e4       	ld.ub	r4,r0[0x6]
800058a4:	00 00       	add	r0,r0
800058a6:	05 ec       	ld.ub	r12,r2[0x6]
800058a8:	00 00       	add	r0,r0
800058aa:	09 e0       	ld.ub	r0,r4[0x6]
800058ac:	f0 0b 16 12 	lsr	r11,r8,0x12
800058b0:	28 4b       	sub	r11,-124
800058b2:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
800058b6:	78 29       	ld.w	r9,r12[0x8]
800058b8:	18 39       	cp.w	r9,r12
800058ba:	c0 e1       	brne	800058d6 <_free_r+0x172>
800058bc:	74 18       	ld.w	r8,r10[0x4]
800058be:	a3 4b       	asr	r11,0x2
800058c0:	30 1c       	mov	r12,1
800058c2:	f8 0b 09 4b 	lsl	r11,r12,r11
800058c6:	f1 eb 10 0b 	or	r11,r8,r11
800058ca:	12 98       	mov	r8,r9
800058cc:	95 1b       	st.w	r10[0x4],r11
800058ce:	c0 a8       	rjmp	800058e2 <_free_r+0x17e>
800058d0:	72 29       	ld.w	r9,r9[0x8]
800058d2:	18 39       	cp.w	r9,r12
800058d4:	c0 60       	breq	800058e0 <_free_r+0x17c>
800058d6:	72 1a       	ld.w	r10,r9[0x4]
800058d8:	e0 1a ff fc 	andl	r10,0xfffc
800058dc:	14 38       	cp.w	r8,r10
800058de:	cf 93       	brcs	800058d0 <_free_r+0x16c>
800058e0:	72 38       	ld.w	r8,r9[0xc]
800058e2:	8d 38       	st.w	r6[0xc],r8
800058e4:	8d 29       	st.w	r6[0x8],r9
800058e6:	93 36       	st.w	r9[0xc],r6
800058e8:	91 26       	st.w	r8[0x8],r6
800058ea:	0e 9c       	mov	r12,r7
800058ec:	fe b0 f5 3c 	rcall	80004364 <__malloc_unlock>
800058f0:	d8 22       	popm	r4-r7,pc
800058f2:	d7 03       	nop

800058f4 <_fwalk>:
800058f4:	d4 31       	pushm	r0-r7,lr
800058f6:	30 05       	mov	r5,0
800058f8:	16 91       	mov	r1,r11
800058fa:	f8 c7 ff 28 	sub	r7,r12,-216
800058fe:	0a 92       	mov	r2,r5
80005900:	c4 2e       	rcall	80005584 <__sfp_lock_acquire>
80005902:	3f f3       	mov	r3,-1
80005904:	c1 68       	rjmp	80005930 <_fwalk+0x3c>
80005906:	6e 26       	ld.w	r6,r7[0x8]
80005908:	6e 14       	ld.w	r4,r7[0x4]
8000590a:	2f 46       	sub	r6,-12
8000590c:	c0 c8       	rjmp	80005924 <_fwalk+0x30>
8000590e:	8c 08       	ld.sh	r8,r6[0x0]
80005910:	e4 08 19 00 	cp.h	r8,r2
80005914:	c0 70       	breq	80005922 <_fwalk+0x2e>
80005916:	8c 18       	ld.sh	r8,r6[0x2]
80005918:	e6 08 19 00 	cp.h	r8,r3
8000591c:	c0 30       	breq	80005922 <_fwalk+0x2e>
8000591e:	5d 11       	icall	r1
80005920:	18 45       	or	r5,r12
80005922:	2a 46       	sub	r6,-92
80005924:	20 14       	sub	r4,1
80005926:	ec cc 00 0c 	sub	r12,r6,12
8000592a:	58 04       	cp.w	r4,0
8000592c:	cf 14       	brge	8000590e <_fwalk+0x1a>
8000592e:	6e 07       	ld.w	r7,r7[0x0]
80005930:	58 07       	cp.w	r7,0
80005932:	ce a1       	brne	80005906 <_fwalk+0x12>
80005934:	c2 9e       	rcall	80005586 <__sfp_lock_release>
80005936:	0a 9c       	mov	r12,r5
80005938:	d8 32       	popm	r0-r7,pc
8000593a:	d7 03       	nop

8000593c <__sclose>:
8000593c:	d4 01       	pushm	lr
8000593e:	96 7b       	ld.sh	r11,r11[0xe]
80005940:	c4 ac       	rcall	800059d4 <_close_r>
80005942:	d8 02       	popm	pc

80005944 <__sseek>:
80005944:	d4 21       	pushm	r4-r7,lr
80005946:	16 97       	mov	r7,r11
80005948:	96 7b       	ld.sh	r11,r11[0xe]
8000594a:	cb 9c       	rcall	80005abc <_lseek_r>
8000594c:	8e 68       	ld.sh	r8,r7[0xc]
8000594e:	10 99       	mov	r9,r8
80005950:	ad c8       	cbr	r8,0xc
80005952:	ad a9       	sbr	r9,0xc
80005954:	5b fc       	cp.w	r12,-1
80005956:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000595a:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000595e:	ef fc 1a 15 	st.wne	r7[0x54],r12
80005962:	d8 22       	popm	r4-r7,pc

80005964 <__swrite>:
80005964:	d4 21       	pushm	r4-r7,lr
80005966:	96 68       	ld.sh	r8,r11[0xc]
80005968:	16 97       	mov	r7,r11
8000596a:	14 95       	mov	r5,r10
8000596c:	12 94       	mov	r4,r9
8000596e:	e2 18 01 00 	andl	r8,0x100,COH
80005972:	18 96       	mov	r6,r12
80005974:	c0 50       	breq	8000597e <__swrite+0x1a>
80005976:	30 29       	mov	r9,2
80005978:	30 0a       	mov	r10,0
8000597a:	96 7b       	ld.sh	r11,r11[0xe]
8000597c:	ca 0c       	rcall	80005abc <_lseek_r>
8000597e:	8e 68       	ld.sh	r8,r7[0xc]
80005980:	ad c8       	cbr	r8,0xc
80005982:	08 99       	mov	r9,r4
80005984:	0a 9a       	mov	r10,r5
80005986:	8e 7b       	ld.sh	r11,r7[0xe]
80005988:	0c 9c       	mov	r12,r6
8000598a:	ae 68       	st.h	r7[0xc],r8
8000598c:	c1 0c       	rcall	800059ac <_write_r>
8000598e:	d8 22       	popm	r4-r7,pc

80005990 <__sread>:
80005990:	d4 21       	pushm	r4-r7,lr
80005992:	16 97       	mov	r7,r11
80005994:	96 7b       	ld.sh	r11,r11[0xe]
80005996:	ca 7c       	rcall	80005ae4 <_read_r>
80005998:	c0 65       	brlt	800059a4 <__sread+0x14>
8000599a:	6f 58       	ld.w	r8,r7[0x54]
8000599c:	18 08       	add	r8,r12
8000599e:	ef 48 00 54 	st.w	r7[84],r8
800059a2:	d8 22       	popm	r4-r7,pc
800059a4:	8e 68       	ld.sh	r8,r7[0xc]
800059a6:	ad c8       	cbr	r8,0xc
800059a8:	ae 68       	st.h	r7[0xc],r8
800059aa:	d8 22       	popm	r4-r7,pc

800059ac <_write_r>:
800059ac:	d4 21       	pushm	r4-r7,lr
800059ae:	16 98       	mov	r8,r11
800059b0:	18 97       	mov	r7,r12
800059b2:	10 9c       	mov	r12,r8
800059b4:	30 08       	mov	r8,0
800059b6:	14 9b       	mov	r11,r10
800059b8:	48 66       	lddpc	r6,800059d0 <_write_r+0x24>
800059ba:	12 9a       	mov	r10,r9
800059bc:	8d 08       	st.w	r6[0x0],r8
800059be:	fe b0 f3 41 	rcall	80004040 <_write>
800059c2:	5b fc       	cp.w	r12,-1
800059c4:	c0 51       	brne	800059ce <_write_r+0x22>
800059c6:	6c 08       	ld.w	r8,r6[0x0]
800059c8:	58 08       	cp.w	r8,0
800059ca:	ef f8 1a 03 	st.wne	r7[0xc],r8
800059ce:	d8 22       	popm	r4-r7,pc
800059d0:	00 00       	add	r0,r0
800059d2:	0a 3c       	cp.w	r12,r5

800059d4 <_close_r>:
800059d4:	d4 21       	pushm	r4-r7,lr
800059d6:	30 08       	mov	r8,0
800059d8:	18 97       	mov	r7,r12
800059da:	48 76       	lddpc	r6,800059f4 <_close_r+0x20>
800059dc:	16 9c       	mov	r12,r11
800059de:	8d 08       	st.w	r6[0x0],r8
800059e0:	fe b0 fc 52 	rcall	80005284 <_close>
800059e4:	5b fc       	cp.w	r12,-1
800059e6:	c0 51       	brne	800059f0 <_close_r+0x1c>
800059e8:	6c 08       	ld.w	r8,r6[0x0]
800059ea:	58 08       	cp.w	r8,0
800059ec:	ef f8 1a 03 	st.wne	r7[0xc],r8
800059f0:	d8 22       	popm	r4-r7,pc
800059f2:	d7 03       	nop
800059f4:	00 00       	add	r0,r0
800059f6:	0a 3c       	cp.w	r12,r5

800059f8 <_fclose_r>:
800059f8:	d4 21       	pushm	r4-r7,lr
800059fa:	18 96       	mov	r6,r12
800059fc:	16 97       	mov	r7,r11
800059fe:	58 0b       	cp.w	r11,0
80005a00:	c0 31       	brne	80005a06 <_fclose_r+0xe>
80005a02:	16 95       	mov	r5,r11
80005a04:	c4 c8       	rjmp	80005a9c <_fclose_r+0xa4>
80005a06:	fe b0 fd bf 	rcall	80005584 <__sfp_lock_acquire>
80005a0a:	58 06       	cp.w	r6,0
80005a0c:	c0 60       	breq	80005a18 <_fclose_r+0x20>
80005a0e:	6c 68       	ld.w	r8,r6[0x18]
80005a10:	58 08       	cp.w	r8,0
80005a12:	c0 31       	brne	80005a18 <_fclose_r+0x20>
80005a14:	0c 9c       	mov	r12,r6
80005a16:	c0 be       	rcall	8000562c <__sinit>
80005a18:	4a 28       	lddpc	r8,80005aa0 <_fclose_r+0xa8>
80005a1a:	10 37       	cp.w	r7,r8
80005a1c:	c0 31       	brne	80005a22 <_fclose_r+0x2a>
80005a1e:	6c 07       	ld.w	r7,r6[0x0]
80005a20:	c0 a8       	rjmp	80005a34 <_fclose_r+0x3c>
80005a22:	4a 18       	lddpc	r8,80005aa4 <_fclose_r+0xac>
80005a24:	10 37       	cp.w	r7,r8
80005a26:	c0 31       	brne	80005a2c <_fclose_r+0x34>
80005a28:	6c 17       	ld.w	r7,r6[0x4]
80005a2a:	c0 58       	rjmp	80005a34 <_fclose_r+0x3c>
80005a2c:	49 f8       	lddpc	r8,80005aa8 <_fclose_r+0xb0>
80005a2e:	10 37       	cp.w	r7,r8
80005a30:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80005a34:	8e 69       	ld.sh	r9,r7[0xc]
80005a36:	30 08       	mov	r8,0
80005a38:	f0 09 19 00 	cp.h	r9,r8
80005a3c:	c0 51       	brne	80005a46 <_fclose_r+0x4e>
80005a3e:	fe b0 fd a4 	rcall	80005586 <__sfp_lock_release>
80005a42:	30 05       	mov	r5,0
80005a44:	c2 c8       	rjmp	80005a9c <_fclose_r+0xa4>
80005a46:	0e 9b       	mov	r11,r7
80005a48:	0c 9c       	mov	r12,r6
80005a4a:	fe b0 fd 15 	rcall	80005474 <_fflush_r>
80005a4e:	6e c8       	ld.w	r8,r7[0x30]
80005a50:	18 95       	mov	r5,r12
80005a52:	58 08       	cp.w	r8,0
80005a54:	c0 60       	breq	80005a60 <_fclose_r+0x68>
80005a56:	6e 8b       	ld.w	r11,r7[0x20]
80005a58:	0c 9c       	mov	r12,r6
80005a5a:	5d 18       	icall	r8
80005a5c:	f9 b5 05 ff 	movlt	r5,-1
80005a60:	8e 68       	ld.sh	r8,r7[0xc]
80005a62:	ed b8 00 07 	bld	r8,0x7
80005a66:	c0 41       	brne	80005a6e <_fclose_r+0x76>
80005a68:	6e 4b       	ld.w	r11,r7[0x10]
80005a6a:	0c 9c       	mov	r12,r6
80005a6c:	c7 ce       	rcall	80005764 <_free_r>
80005a6e:	6e db       	ld.w	r11,r7[0x34]
80005a70:	58 0b       	cp.w	r11,0
80005a72:	c0 90       	breq	80005a84 <_fclose_r+0x8c>
80005a74:	ee c8 ff bc 	sub	r8,r7,-68
80005a78:	10 3b       	cp.w	r11,r8
80005a7a:	c0 30       	breq	80005a80 <_fclose_r+0x88>
80005a7c:	0c 9c       	mov	r12,r6
80005a7e:	c7 3e       	rcall	80005764 <_free_r>
80005a80:	30 08       	mov	r8,0
80005a82:	8f d8       	st.w	r7[0x34],r8
80005a84:	6f 2b       	ld.w	r11,r7[0x48]
80005a86:	58 0b       	cp.w	r11,0
80005a88:	c0 60       	breq	80005a94 <_fclose_r+0x9c>
80005a8a:	0c 9c       	mov	r12,r6
80005a8c:	c6 ce       	rcall	80005764 <_free_r>
80005a8e:	30 08       	mov	r8,0
80005a90:	ef 48 00 48 	st.w	r7[72],r8
80005a94:	30 08       	mov	r8,0
80005a96:	ae 68       	st.h	r7[0xc],r8
80005a98:	fe b0 fd 77 	rcall	80005586 <__sfp_lock_release>
80005a9c:	0a 9c       	mov	r12,r5
80005a9e:	d8 22       	popm	r4-r7,pc
80005aa0:	80 00       	ld.sh	r0,r0[0x0]
80005aa2:	5f 18       	srne	r8
80005aa4:	80 00       	ld.sh	r0,r0[0x0]
80005aa6:	5f 38       	srlo	r8
80005aa8:	80 00       	ld.sh	r0,r0[0x0]
80005aaa:	5f 58       	srlt	r8

80005aac <fclose>:
80005aac:	d4 01       	pushm	lr
80005aae:	48 38       	lddpc	r8,80005ab8 <fclose+0xc>
80005ab0:	18 9b       	mov	r11,r12
80005ab2:	70 0c       	ld.w	r12,r8[0x0]
80005ab4:	ca 2f       	rcall	800059f8 <_fclose_r>
80005ab6:	d8 02       	popm	pc
80005ab8:	00 00       	add	r0,r0
80005aba:	01 e0       	ld.ub	r0,r0[0x6]

80005abc <_lseek_r>:
80005abc:	d4 21       	pushm	r4-r7,lr
80005abe:	16 98       	mov	r8,r11
80005ac0:	18 97       	mov	r7,r12
80005ac2:	10 9c       	mov	r12,r8
80005ac4:	30 08       	mov	r8,0
80005ac6:	14 9b       	mov	r11,r10
80005ac8:	48 66       	lddpc	r6,80005ae0 <_lseek_r+0x24>
80005aca:	12 9a       	mov	r10,r9
80005acc:	8d 08       	st.w	r6[0x0],r8
80005ace:	fe b0 fb e7 	rcall	8000529c <_lseek>
80005ad2:	5b fc       	cp.w	r12,-1
80005ad4:	c0 51       	brne	80005ade <_lseek_r+0x22>
80005ad6:	6c 08       	ld.w	r8,r6[0x0]
80005ad8:	58 08       	cp.w	r8,0
80005ada:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005ade:	d8 22       	popm	r4-r7,pc
80005ae0:	00 00       	add	r0,r0
80005ae2:	0a 3c       	cp.w	r12,r5

80005ae4 <_read_r>:
80005ae4:	d4 21       	pushm	r4-r7,lr
80005ae6:	16 98       	mov	r8,r11
80005ae8:	18 97       	mov	r7,r12
80005aea:	10 9c       	mov	r12,r8
80005aec:	30 08       	mov	r8,0
80005aee:	14 9b       	mov	r11,r10
80005af0:	48 66       	lddpc	r6,80005b08 <_read_r+0x24>
80005af2:	12 9a       	mov	r10,r9
80005af4:	8d 08       	st.w	r6[0x0],r8
80005af6:	fe b0 f2 17 	rcall	80003f24 <_read>
80005afa:	5b fc       	cp.w	r12,-1
80005afc:	c0 51       	brne	80005b06 <_read_r+0x22>
80005afe:	6c 08       	ld.w	r8,r6[0x0]
80005b00:	58 08       	cp.w	r8,0
80005b02:	ef f8 1a 03 	st.wne	r7[0xc],r8
80005b06:	d8 22       	popm	r4-r7,pc
80005b08:	00 00       	add	r0,r0
80005b0a:	0a 3c       	cp.w	r12,r5

80005b0c <__do_global_ctors_aux>:
80005b0c:	d4 21       	pushm	r4-r7,lr
80005b0e:	48 57       	lddpc	r7,80005b20 <__do_global_ctors_aux+0x14>
80005b10:	c0 28       	rjmp	80005b14 <__do_global_ctors_aux+0x8>
80005b12:	5d 18       	icall	r8
80005b14:	20 47       	sub	r7,4
80005b16:	6e 08       	ld.w	r8,r7[0x0]
80005b18:	5b f8       	cp.w	r8,-1
80005b1a:	cf c1       	brne	80005b12 <__do_global_ctors_aux+0x6>
80005b1c:	d8 22       	popm	r4-r7,pc
80005b1e:	d7 03       	nop
80005b20:	00 00       	add	r0,r0
80005b22:	00 0c       	add	r12,r0

Disassembly of section .exception:

80005c00 <_evba>:
80005c00:	c0 08       	rjmp	80005c00 <_evba>
	...

80005c04 <_handle_TLB_Multiple_Hit>:
80005c04:	c0 08       	rjmp	80005c04 <_handle_TLB_Multiple_Hit>
	...

80005c08 <_handle_Bus_Error_Data_Fetch>:
80005c08:	c0 08       	rjmp	80005c08 <_handle_Bus_Error_Data_Fetch>
	...

80005c0c <_handle_Bus_Error_Instruction_Fetch>:
80005c0c:	c0 08       	rjmp	80005c0c <_handle_Bus_Error_Instruction_Fetch>
	...

80005c10 <_handle_NMI>:
80005c10:	c0 08       	rjmp	80005c10 <_handle_NMI>
	...

80005c14 <_handle_Instruction_Address>:
80005c14:	c0 08       	rjmp	80005c14 <_handle_Instruction_Address>
	...

80005c18 <_handle_ITLB_Protection>:
80005c18:	c0 08       	rjmp	80005c18 <_handle_ITLB_Protection>
	...

80005c1c <_handle_Breakpoint>:
80005c1c:	c0 08       	rjmp	80005c1c <_handle_Breakpoint>
	...

80005c20 <_handle_Illegal_Opcode>:
80005c20:	c0 08       	rjmp	80005c20 <_handle_Illegal_Opcode>
	...

80005c24 <_handle_Unimplemented_Instruction>:
80005c24:	c0 08       	rjmp	80005c24 <_handle_Unimplemented_Instruction>
	...

80005c28 <_handle_Privilege_Violation>:
80005c28:	c0 08       	rjmp	80005c28 <_handle_Privilege_Violation>
	...

80005c2c <_handle_Floating_Point>:
80005c2c:	c0 08       	rjmp	80005c2c <_handle_Floating_Point>
	...

80005c30 <_handle_Coprocessor_Absent>:
80005c30:	c0 08       	rjmp	80005c30 <_handle_Coprocessor_Absent>
	...

80005c34 <_handle_Data_Address_Read>:
80005c34:	c0 08       	rjmp	80005c34 <_handle_Data_Address_Read>
	...

80005c38 <_handle_Data_Address_Write>:
80005c38:	c0 08       	rjmp	80005c38 <_handle_Data_Address_Write>
	...

80005c3c <_handle_DTLB_Protection_Read>:
80005c3c:	c0 08       	rjmp	80005c3c <_handle_DTLB_Protection_Read>
	...

80005c40 <_handle_DTLB_Protection_Write>:
80005c40:	c0 08       	rjmp	80005c40 <_handle_DTLB_Protection_Write>
	...

80005c44 <_handle_DTLB_Modified>:
80005c44:	c0 08       	rjmp	80005c44 <_handle_DTLB_Modified>
	...

80005c50 <_handle_ITLB_Miss>:
80005c50:	c0 08       	rjmp	80005c50 <_handle_ITLB_Miss>
	...

80005c60 <_handle_DTLB_Miss_Read>:
80005c60:	c0 08       	rjmp	80005c60 <_handle_DTLB_Miss_Read>
	...

80005c70 <_handle_DTLB_Miss_Write>:
80005c70:	c0 08       	rjmp	80005c70 <_handle_DTLB_Miss_Write>
	...

80005d00 <_handle_Supervisor_Call>:
80005d00:	fe cf 1a f0 	sub	pc,pc,6896

80005d04 <_int0>:
80005d04:	30 0c       	mov	r12,0
80005d06:	fe b0 e3 05 	rcall	80002310 <_get_interrupt_handler>
80005d0a:	58 0c       	cp.w	r12,0
80005d0c:	f8 0f 17 10 	movne	pc,r12
80005d10:	d6 03       	rete

80005d12 <_int1>:
80005d12:	30 1c       	mov	r12,1
80005d14:	fe b0 e2 fe 	rcall	80002310 <_get_interrupt_handler>
80005d18:	58 0c       	cp.w	r12,0
80005d1a:	f8 0f 17 10 	movne	pc,r12
80005d1e:	d6 03       	rete

80005d20 <_int2>:
80005d20:	30 2c       	mov	r12,2
80005d22:	fe b0 e2 f7 	rcall	80002310 <_get_interrupt_handler>
80005d26:	58 0c       	cp.w	r12,0
80005d28:	f8 0f 17 10 	movne	pc,r12
80005d2c:	d6 03       	rete

80005d2e <_int3>:
80005d2e:	30 3c       	mov	r12,3
80005d30:	fe b0 e2 f0 	rcall	80002310 <_get_interrupt_handler>
80005d34:	58 0c       	cp.w	r12,0
80005d36:	f8 0f 17 10 	movne	pc,r12
80005d3a:	d6 03       	rete

80005d3c <ipr_val>:
80005d3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
80005d4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005d5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005d6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005d7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005d8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005d9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005dac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005dbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005dcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005ddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005dec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
80005dfc:	d7 03 d7 03                                         ....

Disassembly of section .fini:

80005e00 <_fini>:
80005e00:	eb cd 40 40 	pushm	r6,lr
80005e04:	48 26       	lddpc	r6,80005e0c <_fini+0xc>
80005e06:	1e 26       	rsub	r6,pc
80005e08:	c0 48       	rjmp	80005e10 <_fini+0x10>
80005e0a:	d7 03       	nop
80005e0c:	80 00       	ld.sh	r0,r0[0x0]
80005e0e:	5d ea       	*unknown*
80005e10:	fe b0 e1 3c 	rcall	80002088 <__do_global_dtors_aux>
80005e14:	e3 cd 80 40 	ldm	sp++,r6,pc
